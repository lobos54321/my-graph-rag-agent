<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CreatorMind AI - Intelligent Content Workflow</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        /* Header */
        .header {
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 0;
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
            font-size: 18px;
            font-weight: 600;
        }

        .knowledge-btn {
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* Main Content */
        .main-content {
            max-width: 1200px;
            margin: 60px auto;
            padding: 0 20px;
        }

        /* Workflow Steps */
        .workflow-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 60px 40px;
            margin-bottom: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
        }

        .workflow-steps {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 60px;
            flex-wrap: wrap;
            gap: 20px;
        }

        .step {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            flex: 1;
            min-width: 100px;
        }

        .step-icon {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: #f8f9ff;
            border: 3px solid #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            margin-bottom: 16px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .step.active .step-icon {
            background: #10b981;
            border-color: #10b981;
            color: white;
            transform: scale(1.1);
        }

        .step-icon:hover {
            transform: scale(1.05);
            border-color: #8b5cf6;
        }

        .step-title {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 4px;
            text-align: center;
        }

        .step-desc {
            font-size: 12px;
            color: #6b7280;
            text-align: center;
        }

        /* Connector Lines */
        .step:not(:last-child)::after {
            content: '';
            position: absolute;
            top: 35px;
            right: -50%;
            width: 100%;
            height: 2px;
            background: #e5e7eb;
            z-index: -1;
        }

        .step.completed::after {
            background: #10b981;
        }

        /* Trending Analysis Section */
        .trending-section {
            background: linear-gradient(135deg, #ff6b6b, #ff8e53);
            border-radius: 16px;
            padding: 24px;
            color: white;
            margin: 24px 0;
            box-shadow: 0 8px 32px rgba(255, 107, 107, 0.3);
        }

        .trending-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .trending-title {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 20px;
            font-weight: 600;
        }

        .trending-status {
            background: rgba(255, 255, 255, 0.2);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
        }

        .trending-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .trending-card {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            padding: 16px;
            backdrop-filter: blur(10px);
        }

        .trending-card h4 {
            margin-bottom: 12px;
            font-size: 14px;
            opacity: 0.9;
        }

        .trend-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .trend-item:last-child {
            border-bottom: none;
        }

        .trend-name {
            font-size: 13px;
            font-weight: 500;
        }

        .trend-score {
            font-size: 12px;
            background: rgba(255, 255, 255, 0.3);
            padding: 2px 8px;
            border-radius: 10px;
        }

        .trending-insights {
            margin-top: 16px;
            padding: 16px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
        }

        .insight-tag {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            margin: 2px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        /* AI Assistant Section */
        .ai-assistant {
            text-align: center;
            margin-bottom: 40px;
        }

        .ai-title {
            font-size: 28px;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        /* Input Section */
        .input-section {
            background: rgba(139, 92, 246, 0.05);
            border: 2px dashed rgba(139, 92, 246, 0.3);
            border-radius: 16px;
            padding: 24px;
            transition: all 0.3s ease;
        }

        .input-section:hover {
            border-color: rgba(139, 92, 246, 0.5);
            background: rgba(139, 92, 246, 0.08);
        }

        .input-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .input-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 16px;
        }

        .input-info h3 {
            font-size: 16px;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 4px;
        }

        .input-info p {
            font-size: 14px;
            color: #6b7280;
        }

        .input-area {
            width: 100%;
            min-height: 120px;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 16px;
            font-size: 14px;
            line-height: 1.6;
            resize: vertical;
            transition: all 0.3s ease;
            background: white;
        }

        .input-area:focus {
            outline: none;
            border-color: #8b5cf6;
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 12px;
            margin-top: 20px;
            justify-content: flex-end;
        }

        .btn {
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(139, 92, 246, 0.3);
        }

        .btn-secondary {
            background: #f8f9ff;
            color: #8b5cf6;
            border: 1px solid #e5e7eb;
        }

        .btn-secondary:hover {
            background: #f3f4f6;
        }

        /* Results Section */
        .results-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            padding: 24px;
            margin-top: 30px;
            display: none;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .results-section.show {
            display: block;
            animation: slideInUp 0.5s ease;
        }

        @keyframes slideInUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .result-card {
            background: linear-gradient(135deg, #fef3c7, #fed7d7);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .result-score {
            font-size: 32px;
            font-weight: bold;
            color: #10b981;
            text-align: center;
            margin: 20px 0;
        }

        .result-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 16px 0;
        }

        .tag {
            background: rgba(255, 255, 255, 0.8);
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 500;
        }

        /* Loading Animation */
        .loading {
            text-align: center;
            padding: 40px;
            color: #6b7280;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #f3f4f6;
            border-top: 3px solid #8b5cf6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }
        
        @keyframes slideInFromRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOutToRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }
        
        @keyframes bounceIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.05); }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); opacity: 1; }
        }
        
        @keyframes slideInLeft {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        /* Multi-modal Input Styles */
        .input-mode-btn {
            background: none;
            border: 2px solid #e5e7eb;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 500;
        }
        
        .input-mode-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        
        .input-mode-btn:hover:not(.active) {
            border-color: #cbd5e1;
            background: #f8fafc;
        }
        
        .file-drop-zone.dragover {
            border-color: #667eea !important;
            background: #e0e7ff !important;
        }
        
        .multimodal-input-container.dragover {
            border-color: #667eea !important;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .workflow-steps {
                flex-direction: column;
                gap: 30px;
            }
            
            .step::after {
                display: none;
            }
            
            .main-content {
                margin: 30px auto;
                padding: 0 15px;
            }
            
            .workflow-container {
                padding: 40px 20px;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <div class="logo">
                üß† CreatorMind AI
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main-content">
        <div class="workflow-container">
            <!-- Trending Analysis Section -->
            <div class="trending-section" id="trendingSection" style="display: none;">
                <div class="trending-header">
                    <div class="trending-title">
                        <span>üî•</span>
                        Hot Topic Analysis
                    </div>
                    <div class="trending-status">Live ‚Ä¢ Australian Market</div>
                </div>
                
                <div class="trending-grid">
                    <div class="trending-card">
                        <h4>üöÄ Trending Topics</h4>
                        <div class="trend-item">
                            <span class="trend-name">AI Content Marketing</span>
                            <span class="trend-score">94%</span>
                        </div>
                        <div class="trend-item">
                            <span class="trend-name">Digital Transformation</span>
                            <span class="trend-score">87%</span>
                        </div>
                        <div class="trend-item">
                            <span class="trend-name">Sydney Tech Hub</span>
                            <span class="trend-score">76%</span>
                        </div>
                        <div class="trend-item">
                            <span class="trend-name">Remote Work Tools</span>
                            <span class="trend-score">68%</span>
                        </div>
                    </div>
                    
                    <div class="trending-card">
                        <h4>üìä Social Signals</h4>
                        <div class="trend-item">
                            <span class="trend-name">LinkedIn Engagement</span>
                            <span class="trend-score">+340%</span>
                        </div>
                        <div class="trend-item">
                            <span class="trend-name">Twitter Mentions</span>
                            <span class="trend-score">+250%</span>
                        </div>
                        <div class="trend-item">
                            <span class="trend-name">Reddit Discussions</span>
                            <span class="trend-score">+180%</span>
                        </div>
                        <div class="trend-item">
                            <span class="trend-name">YouTube Views</span>
                            <span class="trend-score">+150%</span>
                        </div>
                    </div>
                </div>
                
                <div class="trending-insights">
                    <strong>üß† Smart Recommendations:</strong><br>
                    <span class="insight-tag">Focus on AI efficiency stories</span>
                    <span class="insight-tag">Target business decision makers</span>
                    <span class="insight-tag">Use local Sydney case studies</span>
                    <span class="insight-tag">Emphasize ROI metrics</span>
                    <span class="insight-tag">Post during 9-11 AM AEST</span>
                    <span class="insight-tag">Cross-post to LinkedIn first</span>
                </div>
            </div>

            <!-- Workflow Steps -->
            <div class="workflow-steps">
                <div class="step" data-step="knowledge" onclick="openKnowledgePanel()" style="cursor: pointer;">
                    <div class="step-icon">üìö</div>
                    <div class="step-title">Knowledge</div>
                    <div class="step-desc">Choose relevant knowledge</div>
                </div>
                
                <div class="step active" data-step="input">
                    <div class="step-icon">üìù</div>
                    <div class="step-title">Input</div>
                    <div class="step-desc">Content or documents</div>
                </div>
                
                <div class="step" data-step="analysis">
                    <div class="step-icon">üß†</div>
                    <div class="step-title">Analysis</div>
                    <div class="step-desc">Intelligent understanding</div>
                </div>
                
                <div class="step" data-step="research">
                    <div class="step-icon">üîç</div>
                    <div class="step-title">Research</div>
                    <div class="step-desc">Deep analysis</div>
                </div>
                
                <div class="step" data-step="trends">
                    <div class="step-icon">üî•</div>
                    <div class="step-title">Trends</div>
                    <div class="step-desc">Trend matching</div>
                </div>
                
                <div class="step" data-step="create">
                    <div class="step-icon">‚ú®</div>
                    <div class="step-title">Create</div>
                    <div class="step-desc">Content generation</div>
                </div>
                
                <div class="step" data-step="optimize">
                    <div class="step-icon">üéØ</div>
                    <div class="step-title">Optimize</div>
                    <div class="step-desc">Effect improvement</div>
                </div>
                
                <div class="step" data-step="video">
                    <div class="step-icon">üé¨</div>
                    <div class="step-title">Video</div>
                    <div class="step-desc">Digital human</div>
                </div>
                
                <div class="step" data-step="publish">
                    <div class="step-icon">üöÄ</div>
                    <div class="step-title">Publish</div>
                    <div class="step-desc">Multi-platform push</div>
                </div>
            </div>

            <!-- AI Assistant Section -->
            <div class="ai-assistant">
                <h2 class="ai-title">
                    ‚ú® AI Smart Creative Assistant
                </h2>
                
                <div class="input-section">
                    <div class="input-header">
                        <div class="input-avatar">üí¨</div>
                        <div class="input-info">
                            <h3>Text Input</h3>
                            <p>Input your creative ideas, questions or content, AI will provide intelligent analysis and optimal processing solutions</p>
                        </div>
                    </div>
                    
                    <!-- Multi-modal Input Area -->
                    <div class="multimodal-input-container" style="
                        background: white; border: 2px solid #e2e8f0; border-radius: 16px;
                        padding: 20px; transition: border-color 0.3s ease;
                    ">
                        
                        <!-- Smart Input Area - Auto-detects content type -->
                        <div style="margin-bottom: 16px;">
                            <div style="
                                background: linear-gradient(135deg, #f8fafc, #e2e8f0);
                                padding: 8px; border-radius: 12px; text-align: center;
                                font-size: 14px; color: #6b7280; margin-bottom: 12px;
                            ">
                                ü§ñ Smart Input - Drop files, paste URLs, type text, or click voice button
                            </div>
                        </div>
                        
                        <!-- Unified Smart Input Area -->
                        <div id="smartInputArea" style="position: relative;">
                            <!-- Multi-purpose input area with file drop support -->
                            <div class="smart-input-container" style="
                                border: 2px dashed #cbd5e1; border-radius: 12px; 
                                background: #f8fafc; transition: all 0.3s ease;
                                position: relative; min-height: 200px;
                            " 
                            ondrop="handleSmartDrop(event)" 
                            ondragover="event.preventDefault(); this.style.borderColor='#3b82f6'; this.style.backgroundColor='#eff6ff';"
                            ondragleave="this.style.borderColor='#cbd5e1'; this.style.backgroundColor='#f8fafc';">
                                
                                <!-- Main text input area -->
                                <textarea 
                                    class="input-area" 
                                    id="contentInput"
                                    style="
                                        width: 100%; min-height: 180px; padding: 16px;
                                        border: none; background: transparent; resize: vertical;
                                        outline: none; font-size: 14px; line-height: 1.5;
                                    "
                                    placeholder="Smart Input - Type text, paste URLs, or drop files here...

üåê URL Examples:
‚Ä¢ YouTube: https://www.youtube.com/watch?v=dQw4w9WgXcQ
‚Ä¢ Website: https://example.com
‚Ä¢ Article: https://blog.example.com/post

üìù Text Examples:
üìä Marketing campaign strategy
‚úçÔ∏è Blog article draft  
üì± Social media content
üõçÔ∏è Product description
üìà Market analysis
üîó https://example.com/article
üìÅ Drop files: PDF, Word, Excel, Images, Text files"
                                    oninput="handleSmartInput(this.value)"
                                ></textarea>
                                
                                <!-- File input (hidden) -->
                                <input type="file" id="fileInput" multiple 
                                       accept=".pdf,.doc,.docx,.xls,.xlsx,.txt,.png,.jpg,.jpeg,.gif,.md" 
                                       style="display: none;" 
                                       onchange="handleFileInput(this.files)">
                                
                                <!-- Smart input controls -->
                                <div style="
                                    position: absolute; bottom: 12px; right: 12px;
                                    display: flex; gap: 8px; align-items: center;
                                ">
                                    <!-- Voice input button -->
                                    <button id="voiceBtn" onclick="toggleVoiceRecording()" style="
                                        background: #f3f4f6; border: none; width: 36px; height: 36px;
                                        border-radius: 50%; cursor: pointer; color: #6b7280;
                                        display: flex; align-items: center; justify-content: center;
                                        transition: all 0.2s ease; font-size: 16px;
                                    " onmouseover="this.style.background='#e5e7eb'" 
                                       onmouseout="this.style.background='#f3f4f6'">üé§</button>
                                    
                                    <!-- File browse button -->
                                    <button onclick="document.getElementById('fileInput').click()" style="
                                        background: #f3f4f6; border: none; width: 36px; height: 36px;
                                        border-radius: 50%; cursor: pointer; color: #6b7280;
                                        display: flex; align-items: center; justify-content: center;
                                        transition: all 0.2s ease; font-size: 16px;
                                    " onmouseover="this.style.background='#e5e7eb'" 
                                       onmouseout="this.style.background='#f3f4f6'">üìÅ</button>
                                </div>
                            </div>
                            
                            <!-- Uploaded files display area -->
                            <div id="uploadedFiles" style="margin-top: 16px;"></div>
                            
                            <!-- Voice transcript area -->
                            <div id="voiceTranscript" style="
                                background: #f8fafc; border: 1px solid #e5e7eb; 
                                border-radius: 8px; padding: 16px; margin-top: 16px;
                                min-height: 100px; display: none;
                            "></div>
                            
                            <!-- URL content area -->
                            <div id="urlContent" style="
                                background: #f8fafc; border: 1px solid #e5e7eb; 
                                border-radius: 8px; padding: 16px; margin-top: 16px;
                                min-height: 200px; display: none; max-height: 300px; overflow-y: auto;
                            "></div>
                        </div>
                    </div>
                    
                    <div class="action-buttons">
                        <button class="btn btn-primary" onclick="sendContent()" style="width: 100%; font-size: 16px; padding: 12px 24px;">
                            üì§ Send
                        </button>
                    </div>
                </div>
            </div>

            <!-- Loading Section -->
            <div id="loading" class="loading" style="display: none;">
                <div class="loading-spinner"></div>
                <h3>ü§ñ AI Analysis in Progress...</h3>
                <p>Analyzing content with GPT-5 for Australian market...</p>
            </div>

            <!-- Results Section -->
            <div id="results" class="results-section">
                <div class="result-card">
                    <h3>üß† AI Analysis Results</h3>
                    <div class="result-score">8.7/10</div>
                    <p><strong>Viral Potential Score</strong></p>
                    
                    <div class="result-tags">
                        <span class="tag">üé≠ FOMO + Opportunity</span>
                        <span class="tag">üß† Innovation Paradigm</span>
                        <span class="tag">üë§ Aussie Marketers</span>
                        <span class="tag">‚ö° Competitive Edge</span>
                    </div>
                    
                    <div style="margin-top: 20px;">
                        <strong>üéØ Target Audience:</strong><br>
                        Australian marketing professionals, content creators, agency owners (25-45 years)
                    </div>
                    
                    <div style="margin-top: 16px;">
                        <strong>üì± Best Channels:</strong><br>
                        LinkedIn, Twitter, Australian marketing communities, industry newsletters
                    </div>
                    
                    <div style="margin-top: 16px;">
                        <strong>üöÄ Key Optimizations:</strong>
                        <ul style="margin-top: 8px; margin-left: 20px;">
                            <li>Add Australian case study metrics</li>
                            <li>Include local marketing leader quotes</li>
                            <li>Strengthen call-to-action</li>
                            <li>Add region-specific examples</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // üî• È°µÈù¢Âä†ËΩΩÊµãËØï
        console.log('üî• JavaScriptÂºÄÂßãÊâßË°å');
        
        // üß™ Ê∑ªÂä†ÊµãËØïÂáΩÊï∞
        window.testDocumentPreview = function() {
            console.log('üß™ ÊµãËØïÊñáÊ°£È¢ÑËßàÂäüËÉΩ');
            
            // ÊµãËØïÁ´†ËäÇÊï∞ÊçÆ
            const sectionsKeys = Object.keys(window).filter(key => key.startsWith('sections_'));
            console.log('üß™ ÊâæÂà∞ÁöÑÁ´†ËäÇÊï∞ÊçÆÈîÆ:', sectionsKeys);
            
            sectionsKeys.forEach(key => {
                const sections = window[key];
                console.log(`üß™ ${key}: ${sections ? sections.length : 0} ‰∏™Á´†ËäÇ`);
                if (sections && sections.length > 0) {
                    console.log('üß™ Á¨¨‰∏Ä‰∏™Á´†ËäÇ:', sections[0]);
                }
            });
            
            // ÊµãËØïÈ¢ÑËßàÂÆπÂô®
            const container = document.getElementById('documentPreviewContent');
            console.log('üß™ È¢ÑËßàÂÆπÂô®Â≠òÂú®:', !!container);
            if (container) {
                console.log('üß™ È¢ÑËßàÂÆπÂô®:', container);
            }
            
            // ÊµãËØïshowSectionContentÂáΩÊï∞
            console.log('üß™ showSectionContentÂáΩÊï∞Â≠òÂú®:', typeof window.showSectionContent);
        };
        
        // üî• Á´ãÂç≥ÂÆö‰πâÂÖ≥ÈîÆÂáΩÊï∞ÔºåÈÅøÂÖçËØ≠Ê≥ïÈîôËØØÂΩ±Âìç
        window.openKnowledgePanel = function() {
            console.log('üöÄ Áü•ËØÜÂ∫ìÈù¢ÊùøÊâìÂºÄ');
            
            const panel = document.getElementById('knowledgePanel');
            const overlay = document.getElementById('panelOverlay');
            
            if (panel) {
                panel.classList.add('open');
                console.log('‚úÖ Èù¢ÊùøÊâìÂºÄ');
            } else {
                console.error('‚ùå Êâæ‰∏çÂà∞Áü•ËØÜÂ∫ìÈù¢ÊùøÂÖÉÁ¥†');
            }
            
            if (overlay) {
                overlay.classList.add('show');
                console.log('‚úÖ ÈÅÆÁΩ©ÊòæÁ§∫');
            } else {
                console.error('‚ùå Êâæ‰∏çÂà∞ÈÅÆÁΩ©ÂÖÉÁ¥†');
            }
        };
        
        // Á´ãÂç≥ÂÆö‰πâÂÖ≥Èó≠ÂáΩÊï∞
        window.closeKnowledgePanel = function() {
            const panel = document.getElementById('knowledgePanel');
            const overlay = document.getElementById('panelOverlay');
            
            if (panel) {
                panel.classList.remove('open');
            }
            if (overlay) {
                overlay.classList.remove('show');
            }
        };
        
        // üîß Á¥ßÊÄ•‰øÆÂ§ç - Áü•ËØÜÂ∫ìÂáΩÊï∞ÂÆö‰πâ
        window.testOpenPanel = function() {
            console.log('üß™ Test function called!');
            const panel = document.getElementById('knowledgePanel');
            if (panel) {
                panel.style.right = '0px';
                console.log('üß™ Panel forced open');
            } else {
                console.log('üß™ Panel not found');
            }
        }
        
        // Áü•ËØÜÂ∫ìÂáΩÊï∞Â∑≤Âú®È°µÈù¢È°∂ÈÉ®ÂÆö‰πâ
        
        // Ê∑ªÂä†ÂÖ®Â±ÄÊµãËØïÂáΩÊï∞
        window.testPanel = function() {
            console.log('üß™ Áõ¥Êé•ÊµãËØïÈù¢Êùø');
            const panel = document.getElementById('knowledgePanel');
            if (panel) {
                panel.style.right = '0px';
                panel.style.display = 'flex';
                console.log('Âº∫Âà∂ÊòæÁ§∫Èù¢Êùø');
            }
        }
        
        // Load demo content
        function loadDemoContent() {
            const demoContent = `The Australian digital marketing landscape is experiencing unprecedented growth, with AI-powered content tools driving 300% efficiency increases across Sydney and Melbourne agencies.

Recent case study: A Perth-based startup achieved 450% social media engagement growth through strategic AI implementation, maintaining authentic Aussie voice while leveraging automation.

Key insight: 78% of Australian consumers prefer brands demonstrating local market understanding. This creates opportunities for content creators who blend AI efficiency with cultural authenticity.

The challenge: How do we scale content production while preserving the casual, authentic tone that resonates with Australian audiences? The answer lies in strategic human-AI collaboration.`;
            
            document.getElementById('contentInput').value = demoContent;
            isManualInput = false; // Mark as automatic content
        }

        // Add event listeners to detect manual user input
        document.addEventListener('DOMContentLoaded', function() {
            const contentInput = document.getElementById('contentInput');
            if (contentInput) {
                // Detect manual typing
                contentInput.addEventListener('input', function(e) {
                    // Only mark as manual if the event is from user interaction
                    if (e.isTrusted) {
                        isManualInput = true;
                        
                        // üî• ÂΩìÁî®Êà∑ÂºÄÂßãËæìÂÖ•Êñ∞ÂÜÖÂÆπÊó∂ÔºåÊ∏ÖÁêÜ‰πãÂâçÁöÑÁªìÊûú
                        if (contentInput.value.trim().length > 0) {
                            clearPreviousResults();
                        }
                    }
                });
                
                // Detect manual paste
                contentInput.addEventListener('paste', function(e) {
                    if (e.isTrusted) {
                        isManualInput = true;
                    }
                });
                
                // Reset manual flag when content is cleared
                contentInput.addEventListener('focus', function() {
                    if (!contentInput.value.trim()) {
                        isManualInput = false;
                    }
                });
            }
        });

        // üî• Ê∏ÖÁêÜ‰πãÂâçÁöÑÁªìÊûúÊòæÁ§∫Ôºà‰∏çÊ∏ÖÁêÜËæìÂÖ•ÂÜÖÂÆπÔºâ
        function clearPreviousResults() {
            console.log('üßπ Ê∏ÖÁêÜ‰πãÂâçÁöÑÁªìÊûúÊòæÁ§∫');
            
            // Ê∏ÖÁ©∫ÁªìÊûúÊòæÁ§∫Âå∫Âüü
            const resultsContainer = document.getElementById('results');
            if (resultsContainer) {
                resultsContainer.innerHTML = '';
            }
            
            // Ê∏ÖÁ©∫URLÂÜÖÂÆπÂå∫Âüü
            const urlContent = document.getElementById('urlContent');
            if (urlContent) {
                urlContent.style.display = 'none';
                urlContent.innerHTML = '';
            }
            
            // Ê∏ÖÁ©∫‰∏ä‰º†Êñá‰ª∂ÊòæÁ§∫Âå∫Âüü
            const uploadedFiles = document.getElementById('uploadedFiles');
            if (uploadedFiles) {
                uploadedFiles.innerHTML = '';
            }
            
            // Ê∏ÖÁ©∫ÂÖ®Â±ÄÁªìÊûúÁºìÂ≠ò
            window.lastAnalysisResult = null;
            window.lastProcessedContent = null;
            window.currentUploadedFiles = [];
            
            console.log('‚úÖ Â∑≤Ê∏ÖÁêÜ‰πãÂâçÁöÑÁªìÊûúÊòæÁ§∫');
        }

        // Send content function (combines load demo and analyze)
        function sendContent() {
            const content = document.getElementById('contentInput').value.trim();
            if (!content) {
                alert('ËØ∑ËæìÂÖ•ÂÜÖÂÆπÂêéÂÜçÂèëÈÄÅ');
                return;
            }
            
            // Check if content is from manual user input
            if (!isManualInput) {
                alert('ËØ∑ÊâãÂä®ËæìÂÖ•ÂÜÖÂÆπÊàñ‰øÆÊîπÁé∞ÊúâÂÜÖÂÆπÂêéÂÜçÂèëÈÄÅ„ÄÇ\nÁ≥ªÁªüÊ£ÄÊµãÂà∞ÂΩìÂâçÂÜÖÂÆπÊù•Ëá™Ëá™Âä®Âä†ËΩΩÔºåËÄåÈùûÁî®Êà∑ËæìÂÖ•„ÄÇ');
                return;
            }
            
            // Call the existing analyze function
            analyzeContent();
        }

        // Analyze content with smart URL detection
        function analyzeContent() {
            const content = document.getElementById('contentInput').value.trim();
            if (!content) {
                alert('Please enter some content to analyze');
                return;
            }

            console.log('üîç Êô∫ËÉΩÂÜÖÂÆπÂàÜÊûêÂºÄÂßã:', content.substring(0, 100) + '...');

            // Smart detection: Check if content is a URL
            if (isValidURL(content)) {
                console.log('üåê Ê£ÄÊµãÂà∞URLËæìÂÖ•Ôºå‰ΩøÁî®URLÂàÜÊûêÊ®°Âºè');
                analyzeURL(content);
                return;
            }

            // If not URL, proceed with regular text analysis
            console.log('üìù Ê£ÄÊµãÂà∞ÊñáÊú¨ËæìÂÖ•Ôºå‰ΩøÁî®ÊñáÊú¨ÂàÜÊûêÊ®°Âºè');
            analyzeTextContent(content);
        }

        // URL validation function
        function isValidURL(string) {
            try {
                new URL(string);
                return true;
            } catch (_) {
                return false;
            }
        }

        // Analyze URL content
        async function analyzeURL(url) {
            console.log('üåê ÂºÄÂßãURLÂàÜÊûê:', url);
            
            // Update workflow step
            updateActiveStep('analysis');
            
            // Show loading
            document.getElementById('loading').style.display = 'block';
            document.getElementById('results').classList.remove('show');
            
            try {
                console.log('üì° ÂèëÈÄÅURLÂà∞GraphRAG API...');
                
                // Call the URL scraping API
                const response = await fetch('http://localhost:8000/api/scrape', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ url: url })
                });
                
                const data = await response.json();
                console.log('üì° GraphRAG APIÂìçÂ∫îÁä∂ÊÄÅ:', response.status);
                console.log('‚úÖ GraphRAG AgentÂàÜÊûêÂÆåÊàê!');
                console.log('üîç ÂÆåÊï¥ÂàÜÊûêÁªìÊûú:', data);
                
                if (data.status === 'success' && data.analysis) {
                    // Hide loading and show results
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('results').classList.add('show');
                    updateActiveStep('research');
                    
                    // Display URL analysis results
                    displayURLAnalysisResults(data.analysis, url);
                    
                    // üî• Ëá™Âä®‰øùÂ≠òÂà∞Áü•ËØÜÊ†ë
                    const urlFile = new File([data.analysis.content], 
                        `url_${new URL(url).hostname}_${Date.now()}.txt`, 
                        { type: 'text/plain' });
                    urlFile.sourceUrl = url;
                    
                    await autoSaveToKnowledgeTree(urlFile, data);
                    console.log('‚úÖ URLÂÜÖÂÆπÂ∑≤Ëá™Âä®‰øùÂ≠òÂà∞Áü•ËØÜÊ†ë');
                    
                } else {
                    throw new Error(data.message || data.error || 'URLÂàÜÊûêÂ§±Ë¥•');
                }
                
            } catch (error) {
                console.error('‚ùå URLÂàÜÊûêÈîôËØØ:', error);
                document.getElementById('loading').style.display = 'none';
                alert('URLÂàÜÊûêÂ§±Ë¥•: ' + error.message + '\nËØ∑Ê£ÄÊü•URLÊòØÂê¶ÊúâÊïàÊàñÊúçÂä°ÊòØÂê¶Ê≠£Â∏∏ËøêË°å');
            }
        }

        // Analyze regular text content (original function)
        async function analyzeTextContent(content) {
            console.log('üìù ÂºÄÂßãÊñáÊú¨ÂÜÖÂÆπÂàÜÊûê');
            
            // Analyze trends first
            const trendMatches = analyzeTrendsForContent(content);
            if (trendMatches.length > 0) {
                // Auto-trigger trending analysis
                setTimeout(() => {
                    showTrendingAnalysis();
                    updateTrendingInsightsForContent(trendMatches);
                }, 1000);
            }

            // Update workflow step
            updateActiveStep('analysis');
            
            // Show loading
            document.getElementById('loading').style.display = 'block';
            document.getElementById('results').classList.remove('show');
            
            try {
                console.log('üì° ÂèëÈÄÅÊñáÊú¨ÂÜÖÂÆπÂà∞GraphRAG APIËøõË°åÂàÜÊûê...');
                
                // Call the text analysis API
                const response = await fetch('http://localhost:8000/api/analyze-text', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ content: content })
                });
                
                const data = await response.json();
                console.log('üì° ÊñáÊú¨ÂàÜÊûêAPIÂìçÂ∫îÁä∂ÊÄÅ:', response.status);
                console.log('‚úÖ ÊñáÊú¨ÂàÜÊûêÂÆåÊàê!');
                console.log('üîç ÂÆåÊï¥ÂàÜÊûêÁªìÊûú:', data);
                
                if (data.status === 'success' && data.analysis) {
                    // Hide loading and show results
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('results').classList.add('show');
                    updateActiveStep('research');
                    
                    // Display text analysis results
                    displayTextAnalysisResults(data.analysis, content);
                    
                    // üî• Ëá™Âä®‰øùÂ≠òÂà∞Áü•ËØÜÊ†ë
                    const textFile = new File([content], 
                        `manual_input_${Date.now()}.txt`, 
                        { type: 'text/plain' });
                    
                    await autoSaveToKnowledgeTree(textFile, data);
                    console.log('‚úÖ ÊñáÊú¨ÂÜÖÂÆπÂ∑≤Ëá™Âä®‰øùÂ≠òÂà∞Áü•ËØÜÊ†ë');
                    
                } else {
                    throw new Error(data.message || data.error || 'ÊñáÊú¨ÂàÜÊûêÂ§±Ë¥•');
                }
                
            } catch (error) {
                console.error('‚ùå ÊñáÊú¨ÂàÜÊûêÈîôËØØ:', error);
                console.log('‚ö†Ô∏è APIË∞ÉÁî®Â§±Ë¥•Ôºå‰ΩøÁî®Êú¨Âú∞Ê®°ÊãüÂàÜÊûê');
                
                // Â¶ÇÊûúAPIÂ§±Ë¥•Ôºå‰ΩøÁî®Êú¨Âú∞Ê®°ÊãüÂàÜÊûê
                await performLocalTextAnalysis(content);
            }
        }
        
        // Êú¨Âú∞ÊñáÊú¨ÂàÜÊûêÔºàÂΩìAPI‰∏çÂèØÁî®Êó∂ÁöÑÂêéÂ§áÊñπÊ°àÔºâ
        async function performLocalTextAnalysis(content) {
            console.log('üîß ‰ΩøÁî®Êú¨Âú∞Ê®°ÊãüÂàÜÊûê');
            
            // ÁÆÄÂçïÁöÑÊú¨Âú∞ÂàÜÊûêÈÄªËæë
            const entities = extractEntitiesFromText(content);
            const concepts = extractConceptsFromText(content);
            
            const localAnalysis = {
                content: content,
                entities: entities,
                concepts: concepts,
                confidence: 0.7,
                source: 'local_analysis'
            };
            
            // Ê®°ÊãüÂàÜÊûêÁªìÊûú
            const mockResult = {
                status: 'success',
                analysis: localAnalysis,
                positionSuggestion: {
                    primarySuggestion: {
                        path: 'ÊñáÊú¨ÂÜÖÂÆπ/Áî®Êà∑ËæìÂÖ•/ÊâãÂä®ËæìÂÖ•'
                    }
                }
            };
            
            setTimeout(async () => {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('results').classList.add('show');
                updateActiveStep('research');
                
                // Display local analysis results
                displayTextAnalysisResults(localAnalysis, content);
                
                // üî• Ëá™Âä®‰øùÂ≠òÂà∞Áü•ËØÜÊ†ë
                const textFile = new File([content], 
                    `manual_input_${Date.now()}.txt`, 
                    { type: 'text/plain' });
                
                await autoSaveToKnowledgeTree(textFile, mockResult);
                console.log('‚úÖ ÊñáÊú¨ÂÜÖÂÆπÂ∑≤Ëá™Âä®‰øùÂ≠òÂà∞Áü•ËØÜÊ†ëÔºàÊú¨Âú∞ÂàÜÊûêÔºâ');
                
            }, 2000);
        }
        
        // ÁÆÄÂçïÁöÑÂÆû‰ΩìÊèêÂèñ
        function extractEntitiesFromText(text) {
            const entities = [];
            
            // Ê£ÄÊµã‰∫∫ÂêçÔºàÁÆÄÂçïÁöÑ‰∏≠Ëã±Êñá‰∫∫ÂêçÊ®°ÂºèÔºâ
            const namePattern = /[A-Z][a-z]+\s+[A-Z][a-z]+|[\u4e00-\u9fa5]{2,4}(?:ÂÖàÁîü|Â•≥Â£´|ÊïôÊéà|ÂçöÂ£´)?/g;
            let matches = text.match(namePattern);
            if (matches) {
                entities.push(...matches.slice(0, 5));
            }
            
            // Ê£ÄÊµãÁªÑÁªáÊú∫ÊûÑ
            const orgPattern = /[A-Z][A-Za-z]*(?:\s+[A-Z][A-Za-z]*)*(?:\s+(?:Inc|Corp|LLC|Ltd|Company|University|School))?/g;
            matches = text.match(orgPattern);
            if (matches) {
                entities.push(...matches.filter(m => m.length > 3).slice(0, 3));
            }
            
            // Ê£ÄÊµã‰∏≠ÊñáÂÖ≥ÈîÆËØç
            const chineseKeywords = text.match(/[\u4e00-\u9fa5]{2,6}/g);
            if (chineseKeywords) {
                const filtered = chineseKeywords.filter(k => 
                    !['Ëøô‰∏™', 'ÈÇ£‰∏™', 'Êàë‰ª¨', '‰ªñ‰ª¨', 'ÂèØ‰ª•', 'Â∫îËØ•', 'Âõ†‰∏∫', 'ÊâÄ‰ª•', '‰ΩÜÊòØ', 'Â¶ÇÊûú', 'ËôΩÁÑ∂', 'ÁÑ∂ËÄå'].includes(k)
                );
                entities.push(...filtered.slice(0, 5));
            }
            
            return [...new Set(entities)].slice(0, 10); // ÂéªÈáçÂπ∂ÈôêÂà∂Êï∞Èáè
        }
        
        // ÁÆÄÂçïÁöÑÊ¶ÇÂøµÊèêÂèñ
        function extractConceptsFromText(text) {
            const concepts = [];
            
            // ÊäÄÊúØÊ¶ÇÂøµ
            const techConcepts = ['AI', '‰∫∫Â∑•Êô∫ËÉΩ', 'Êú∫Âô®Â≠¶‰π†', 'Ê∑±Â∫¶Â≠¶‰π†', 'ÁÆóÊ≥ï', 'Êï∞ÊçÆ', 'Á≥ªÁªü', 'Âπ≥Âè∞', 'ÊäÄÊúØ', 'ÂºÄÂèë', 'ÁºñÁ®ã', '‰ª£Á†Å'];
            techConcepts.forEach(concept => {
                if (text.includes(concept)) {
                    concepts.push(concept);
                }
            });
            
            // ÂïÜ‰∏öÊ¶ÇÂøµ
            const businessConcepts = ['ÁÆ°ÁêÜ', 'Ëê•ÈîÄ', 'Á≠ñÁï•', 'Â∏ÇÂú∫', 'ÂÆ¢Êà∑', 'ÊúçÂä°', '‰∫ßÂìÅ', 'ÂìÅÁâå', '‰ª∑ÂÄº', 'ÂàõÊñ∞'];
            businessConcepts.forEach(concept => {
                if (text.includes(concept)) {
                    concepts.push(concept);
                }
            });
            
            // Â≠¶‰π†Ê¶ÇÂøµ
            const learningConcepts = ['Â≠¶‰π†', 'ÊïôËÇ≤', 'ÂüπËÆ≠', 'Áü•ËØÜ', 'ÊäÄËÉΩ', 'ÁªèÈ™å', 'ÊñπÊ≥ï', 'ÁêÜËÆ∫', 'ÂÆûË∑µ'];
            learningConcepts.forEach(concept => {
                if (text.includes(concept)) {
                    concepts.push(concept);
                }
            });
            
            return [...new Set(concepts)].slice(0, 8); // ÂéªÈáçÂπ∂ÈôêÂà∂Êï∞Èáè
        }
        
        // Display text analysis results
        function displayTextAnalysisResults(analysis, originalContent) {
            console.log('üé® ÊòæÁ§∫ÊñáÊú¨ÂàÜÊûêÁªìÊûú:', analysis);
            
            // Update the results section with real analysis data
            const resultsContainer = document.getElementById('results');
            if (resultsContainer) {
                // Create analysis summary
                const content = analysis.content || originalContent;
                const entities = analysis.entities || [];
                const concepts = analysis.concepts || [];
                
                // Add text-specific results display
                const textResultsHtml = `
                    <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 12px; margin: 20px 0;">
                        <h3>üìù ÊñáÊú¨ÂàÜÊûêÁªìÊûú</h3>
                        <div style="margin: 10px 0;">
                            <strong>üìÑ ÂÜÖÂÆπÈïøÂ∫¶:</strong> ${content.length} Â≠óÁ¨¶
                        </div>
                        <div style="margin: 10px 0;">
                            <strong>üè∑Ô∏è ÊèêÂèñÂÆû‰Ωì:</strong> ${entities.length} ‰∏™
                            ${entities.slice(0,8).map(e => `<span style="background: #8b5cf6; color: white; padding: 2px 6px; border-radius: 4px; font-size: 12px; margin: 2px;">${e}</span>`).join('')}
                        </div>
                        <div style="margin: 10px 0;">
                            <strong>üí° ËØÜÂà´Ê¶ÇÂøµ:</strong> ${concepts.length} ‰∏™
                            ${concepts.slice(0,6).map(c => `<span style="background: #10b981; color: white; padding: 2px 6px; border-radius: 4px; font-size: 12px; margin: 2px;">${c}</span>`).join('')}
                        </div>
                        <div style="margin: 10px 0;">
                            <strong>üìù ÂÆåÊï¥ÂÜÖÂÆπ:</strong>
                            <div style="background: rgba(0,0,0,0.1); padding: 15px; border-radius: 8px; font-size: 13px; max-height: 400px; overflow-y: auto; margin-top: 5px; white-space: pre-wrap;">
                                ${content}
                            </div>
                        </div>
                        <div style="margin: 10px 0; font-size: 12px; color: rgba(255,255,255,0.7);">
                            ${analysis.source === 'local_analysis' ? 'üîß Êú¨Âú∞ÂàÜÊûêÁªìÊûú' : 'ü§ñ AIÂàÜÊûêÁªìÊûú'}
                        </div>
                    </div>
                `;
                
                // Insert text results at the beginning of the results container
                resultsContainer.insertAdjacentHTML('afterbegin', textResultsHtml);
            }
            
            console.log('‚úÖ ÊñáÊú¨ÂàÜÊûêÁªìÊûúÊòæÁ§∫ÂÆåÊàê');
        }

        // Display URL analysis results
        function displayURLAnalysisResults(analysis, originalUrl) {
            console.log('üé® ÊòæÁ§∫URLÂàÜÊûêÁªìÊûú:', analysis);
            
            // Update the results section with real analysis data
            const resultsContainer = document.getElementById('results');
            if (resultsContainer) {
                // Create analysis summary
                const content = analysis.content || '';
                const entities = analysis.entities || [];
                const concepts = analysis.concepts || [];
                
                // Add URL-specific results display
                const urlResultsHtml = `
                    <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 12px; margin: 20px 0;">
                        <h3>üåê URLÂàÜÊûêÁªìÊûú</h3>
                        <div style="margin: 10px 0;">
                            <strong>üìä ÂàÜÊûêURL:</strong> ${originalUrl}
                        </div>
                        <div style="margin: 10px 0;">
                            <strong>üìÑ ÂÜÖÂÆπÈïøÂ∫¶:</strong> ${content.length} Â≠óÁ¨¶
                        </div>
                        <div style="margin: 10px 0;">
                            <strong>üè∑Ô∏è ÊèêÂèñÂÆû‰Ωì:</strong> ${entities.length} ‰∏™
                            ${entities.slice(0,5).map(e => `<span style="background: #8b5cf6; color: white; padding: 2px 6px; border-radius: 4px; font-size: 12px; margin: 2px;">${e}</span>`).join('')}
                        </div>
                        <div style="margin: 10px 0;">
                            <strong>üí° ËØÜÂà´Ê¶ÇÂøµ:</strong> ${concepts.length} ‰∏™
                            ${concepts.slice(0,5).map(c => `<span style="background: #10b981; color: white; padding: 2px 6px; border-radius: 4px; font-size: 12px; margin: 2px;">${c}</span>`).join('')}
                        </div>
                        <div style="margin: 10px 0;">
                            <strong>üìù ÂÆåÊï¥ÂÜÖÂÆπ:</strong>
                            <div style="background: rgba(0,0,0,0.1); padding: 15px; border-radius: 8px; font-size: 13px; max-height: 400px; overflow-y: auto; margin-top: 5px; white-space: pre-wrap;">
                                ${content}
                            </div>
                        </div>
                    </div>
                `;
                
                // Insert URL results at the beginning of the results container
                resultsContainer.insertAdjacentHTML('afterbegin', urlResultsHtml);
            }
            
            console.log('‚úÖ URLÂàÜÊûêÁªìÊûúÊòæÁ§∫ÂÆåÊàê');
        }

        function updateTrendingInsightsForContent(matches) {
            const insightsContainer = document.querySelector('.trending-insights');
            if (insightsContainer && matches.length > 0) {
                let matchesText = matches.map(m => `${m.trend} (${m.score}% match)`).join(', ');
                const additionalInsight = document.createElement('div');
                additionalInsight.style.marginTop = '12px';
                additionalInsight.style.padding = '12px';
                additionalInsight.style.background = 'rgba(255, 255, 255, 0.15)';
                additionalInsight.style.borderRadius = '8px';
                additionalInsight.innerHTML = `
                    <strong>üéØ Content-Trend Matches:</strong><br>
                    <span class="insight-tag">${matchesText}</span>
                    <span class="insight-tag">Viral potential: High</span>
                    <span class="insight-tag">Best time: Peak engagement hours</span>
                `;
                insightsContainer.appendChild(additionalInsight);
            }
        }

        // Make key functions global for HTML onclick attributes
        window.selectNode = selectNode;
        window.toggleNode = toggleNode;
        window.editNodeTitle = editNodeTitle;

        // Update active step
        function updateActiveStep(stepName) {
            // Remove active class from all steps
            document.querySelectorAll('.step').forEach(step => {
                step.classList.remove('active');
            });
            
            // Add completed class to previous steps and active to current
            const steps = ['knowledge', 'input', 'analysis', 'research', 'trends', 'create', 'optimize', 'video', 'publish'];
            const currentIndex = steps.indexOf(stepName);
            
            steps.forEach((step, index) => {
                const stepElement = document.querySelector(`[data-step="${step}"]`);
                if (index < currentIndex) {
                    stepElement.classList.add('completed');
                } else if (index === currentIndex) {
                    stepElement.classList.add('active');
                }
            });
        }

        // Toggle knowledge base
        function toggleKnowledgeBase() {
            openKnowledgePanel();
        }

        // Trending Analysis Functions
        function showTrendingAnalysis() {
            const trendingSection = document.getElementById('trendingSection');
            
            // Show trending section
            trendingSection.style.display = 'block';
            
            // Update trends step to active
            const trendsStep = document.querySelector('[data-step="trends"]');
            trendsStep.classList.add('active');
            
            // Simulate real-time data update
            setTimeout(() => {
                updateTrendingData();
            }, 1500);
        }

        function updateTrendingData() {
            // Simulate real-time trending data updates
            const trendItems = document.querySelectorAll('.trend-item');
            trendItems.forEach((item, index) => {
                const scoreElement = item.querySelector('.trend-score');
                if (scoreElement) {
                    // Add slight random variation to scores
                    const currentScore = scoreElement.textContent;
                    if (currentScore.includes('%')) {
                        const baseScore = parseInt(currentScore);
                        const variation = Math.floor(Math.random() * 4) - 2; // -2 to +2
                        const newScore = Math.max(0, Math.min(100, baseScore + variation));
                        scoreElement.textContent = newScore + '%';
                    }
                }
            });
        }

        function analyzeTrendsForContent(content) {
            // Analyze content against trending topics
            const trends = [
                'AI Content Marketing',
                'Digital Transformation', 
                'Sydney Tech Hub',
                'Remote Work Tools'
            ];
            
            const matches = [];
            trends.forEach(trend => {
                const trendWords = trend.toLowerCase().split(' ');
                const contentLower = content.toLowerCase();
                let matchScore = 0;
                
                trendWords.forEach(word => {
                    if (contentLower.includes(word)) {
                        matchScore += 25;
                    }
                });
                
                if (matchScore > 0) {
                    matches.push({
                        trend: trend,
                        score: Math.min(100, matchScore + Math.floor(Math.random() * 20))
                    });
                }
            });
            
            return matches;
        }

        // Step click handlers
        document.querySelectorAll('.step').forEach(step => {
            step.addEventListener('click', function() {
                const stepName = this.getAttribute('data-step');
                
                // Special handling for knowledge step
                if (stepName === 'knowledge') {
                    toggleKnowledgeBase();
                }
                
                // Special handling for trends step
                if (stepName === 'trends') {
                    showTrendingAnalysis();
                }
                
                // Special handling for video step
                if (stepName === 'video') {
                    showDigitalHumanVideoGenerator();
                }
                
                updateActiveStep(stepName);
            });
        });

        // Unified DOM initialization
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ DOM loaded, initializing app...');
            console.log('üîç Current URL:', window.location.href);
            console.log('üîç Document title:', document.title);
            
            // üî• ÈáçË¶ÅÔºöÈáçÁΩÆÊâÄÊúâÂÖ®Â±ÄÈîÅÁä∂ÊÄÅ
            window.isProcessingFiles = false;
            window.lastProcessedSignature = null;
            console.log('‚úÖ ÈáçÁΩÆÂÖ®Â±ÄÊñá‰ª∂Â§ÑÁêÜÁä∂ÊÄÅ');
            
            // Ê∑ªÂä†ÊãñÊãΩÊµãËØï
            window.testDrag = function() {
                console.log('üß™ ÊµãËØïÊãñÊãΩÂäüËÉΩ');
                const container = document.querySelector('.multimodal-input-container');
                console.log('ËæìÂÖ•ÂÆπÂô®Â≠òÂú®:', !!container);
                
                if (container) {
                    console.log('ÂÆπÂô®ÂÖÉÁ¥†:', container);
                    console.log('ÂÆπÂô®‰∫ã‰ª∂ÁõëÂê¨Âô®Êï∞Èáè:', getEventListeners ? getEventListeners(container) : 'Êó†Ê≥ïÊ£ÄÊµã');
                }
            };
            
            // Add global click detector for debugging
            document.addEventListener('click', function(e) {
                console.log('üñ±Ô∏è GLOBAL CLICK:', e.target);
                if (e.target.closest('[data-step="knowledge"]')) {
                    console.log('üéØ Click detected on knowledge step!');
                }
            });
            
            // Add global drag detector for debugging
            document.addEventListener('dragenter', function(e) {
                console.log('üåç GLOBAL DRAGENTER:', e.target);
            });
            document.addEventListener('dragover', function(e) {
                console.log('üåç GLOBAL DRAGOVER:', e.target);
            });
            document.addEventListener('drop', function(e) {
                console.log('üåç GLOBAL DROP:', e.target, 'Files:', e.dataTransfer?.files?.length);
            });
            
            // üîÑ ÈáçË¶ÅÔºöÂàùÂßãÂåñÊó∂ÊÅ¢Â§çÁü•ËØÜÊ†ë
            setTimeout(async () => {
                console.log('üîÑ È°µÈù¢ÂàùÂßãÂåñÔºåÊÅ¢Â§çÁü•ËØÜÊ†ë...');
                await regenerateKnowledgeTree();
                
                const existingNodes = document.querySelectorAll('#knowledgeTree .tree-node');
                existingNodes.forEach(node => {
                    updateEventHandlers(node);
                });
            }, 100);
            
            // Make knowledge step clickable with enhanced debugging
            const knowledgeStep = document.querySelector('[data-step="knowledge"]');
            console.log('üîç Looking for knowledge step:', knowledgeStep);
            console.log('üîç Available steps:', document.querySelectorAll('.step'));
            console.log('üîç Available data-step elements:', document.querySelectorAll('[data-step]'));
            
            if (knowledgeStep) {
                console.log('‚úÖ Knowledge step found, adding event listeners...');
                knowledgeStep.style.cursor = 'pointer';
                
                // Add multiple event listeners for better debugging
                knowledgeStep.addEventListener('click', function(e) {
                    console.log('üìö Knowledge step CLICKED via addEventListener!', e.target);
                    console.log('üìö Event details:', {
                        type: e.type,
                        target: e.target,
                        currentTarget: e.currentTarget,
                        bubbles: e.bubbles,
                        cancelable: e.cancelable
                    });
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('üìö Calling openKnowledgePanel...');
                    openKnowledgePanel();
                });
                
                // Also add mousedown for more debugging
                knowledgeStep.addEventListener('mousedown', function(e) {
                    console.log('üñ±Ô∏è Knowledge step MOUSEDOWN detected!', e.target);
                });
                
                knowledgeStep.addEventListener('mouseup', function(e) {
                    console.log('üñ±Ô∏è Knowledge step MOUSEUP detected!', e.target);
                });
                
                console.log('‚úÖ All event listeners added to knowledge step');
            } else {
                console.error('‚ùå Knowledge step not found!');
                // Let's also search for it manually to see what's available
                console.log('üîç Available steps:', document.querySelectorAll('.step'));
                console.log('üîç Available data-step elements:', document.querySelectorAll('[data-step]'));
            }
            
            // Initialize draggable panel
            const panel = document.getElementById('selectedDocsPanel');
            const header = document.getElementById('selectedDocsPanelHeader');
            
            if (header && panel) {
                header.addEventListener('mousedown', function(e) {
                    isDragging = true;
                    const rect = panel.getBoundingClientRect();
                    dragOffset.x = e.clientX - rect.left;
                    dragOffset.y = e.clientY - rect.top;
                    
                    panel.style.transition = 'none';
                    document.body.style.userSelect = 'none';
                });
                
                document.addEventListener('mousemove', function(e) {
                    if (!isDragging) return;
                    
                    const newX = e.clientX - dragOffset.x;
                    const newY = e.clientY - dragOffset.y;
                    
                    const maxX = window.innerWidth - panel.offsetWidth;
                    const maxY = window.innerHeight - panel.offsetHeight;
                    
                    const constrainedX = Math.max(0, Math.min(newX, maxX));
                    const constrainedY = Math.max(0, Math.min(newY, maxY));
                    
                    panel.style.left = constrainedX + 'px';
                    panel.style.top = constrainedY + 'px';
                    panel.style.right = 'auto';
                    panel.style.transform = 'none';
                });
                
                document.addEventListener('mouseup', function() {
                    if (isDragging) {
                        isDragging = false;
                        panel.style.transition = 'right 0.4s ease';
                        document.body.style.userSelect = '';
                    }
                });
            }
            
            // Initialize file input
            const fileInput = document.getElementById('fileInput');
            if (fileInput) {
                fileInput.addEventListener('change', function(e) {
                    if (e.target.files.length > 0) {
                        processUploadedFiles(e.target.files);
                    }
                });
            }
            
            console.log('‚úÖ App initialization complete');
            
            // Initialize UI states
            updateSelectionUI();
            
            // Add test functions to window for debugging
            window.testFunctions = function() {
                console.log('üß™ Testing all functions...');
                
                // Test panel opening
                console.log('üîç Testing knowledge panel...');
                const panel = document.getElementById('knowledgePanel');
                const overlay = document.getElementById('panelOverlay');
                console.log('Panel exists:', !!panel);
                console.log('Overlay exists:', !!overlay);
                
                // Test checkboxes
                console.log('üîç Testing checkboxes...');
                const checkboxes = document.querySelectorAll('.node-checkbox');
                console.log('Total checkboxes found:', checkboxes.length);
                
                // Test export button
                console.log('üîç Testing export button...');
                const exportBtn = document.querySelector('[onclick="exportSelectedKnowledge()"]');
                console.log('Export button exists:', !!exportBtn);
                
                return {
                    panel: !!panel,
                    overlay: !!overlay,
                    checkboxes: checkboxes.length,
                    exportButton: !!exportBtn
                };
            };
            
            // Automatically run test
            setTimeout(() => {
                const testResults = window.testFunctions();
                console.log('üß™ Test results:', testResults);
            }, 1000);
            
            // Add global drag and drop support to the input container
            const inputContainer = document.querySelector('.multimodal-input-container');
            console.log('üîç Input container found:', inputContainer);
            
            if (inputContainer) {
                console.log('üìÅ Adding global drag support to input container');
                
                // Prevent default drag behaviors on window
                window.addEventListener('dragenter', function(e) {
                    e.preventDefault();
                }, false);
                window.addEventListener('dragover', function(e) {
                    e.preventDefault();
                }, false);
                window.addEventListener('drop', function(e) {
                    e.preventDefault();
                }, false);
                
                inputContainer.addEventListener('dragenter', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('üîç DRAG ENTER - adding dragover class and visual feedback!');
                    console.log('üîç Event target:', e.target);
                    console.log('üîç Current target:', e.currentTarget);
                    this.classList.add('dragover');
                    this.style.borderColor = '#667eea !important';
                    this.style.backgroundColor = '#f0f9ff !important';
                    this.style.border = '3px dashed #667eea !important';
                    
                    // Add a temporary visual indicator inside the input container
                    if (!document.getElementById('dragIndicator')) {
                        const indicator = document.createElement('div');
                        indicator.id = 'dragIndicator';
                        indicator.style.cssText = `
                            position: absolute;
                            top: 50%; left: 50%; transform: translate(-50%, -50%);
                            background: rgba(102, 126, 234, 0.95); color: white; padding: 12px 20px;
                            border-radius: 8px; z-index: 1000; font-size: 14px; font-weight: bold;
                            pointer-events: none; white-space: nowrap;
                        `;
                        indicator.textContent = 'üéØ Drop files here!';
                        this.style.position = 'relative';
                        this.appendChild(indicator);
                    }
                });
                
                inputContainer.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.dataTransfer.dropEffect = 'copy';
                    console.log('üîç Drag over');
                    this.classList.add('dragover');
                    this.style.borderColor = '#667eea';
                    this.style.backgroundColor = '#f0f9ff';
                });
                
                inputContainer.addEventListener('dragleave', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    // Only remove if leaving the container entirely
                    if (!inputContainer.contains(e.relatedTarget)) {
                        console.log('üîç DRAG LEAVE - removing dragover class and visual feedback!');
                        this.classList.remove('dragover');
                        this.style.borderColor = '#e2e8f0';
                        this.style.backgroundColor = 'white';
                        this.style.border = '2px solid #e2e8f0';
                        
                        // Remove visual indicator
                        const indicator = document.getElementById('dragIndicator');
                        if (indicator) {
                            indicator.remove();
                        }
                    }
                });
                
                inputContainer.addEventListener('drop', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('üîç INPUT CONTAINER DROP - Ê£ÄÊü•Êñá‰ª∂');
                    
                    // Remove visual feedback
                    this.classList.remove('dragover');
                    this.style.borderColor = '#e2e8f0';
                    this.style.backgroundColor = 'white';
                    this.style.border = '2px solid #e2e8f0';
                    
                    // Remove visual indicator
                    const indicator = document.getElementById('dragIndicator');
                    if (indicator) {
                        indicator.remove();
                    }
                    
                    const files = e.dataTransfer.files;
                    console.log('üìÅ Files dropped on input container:', files.length);
                    console.log('üîç Current processing state:', window.isProcessingFiles);
                    
                    if (files.length > 0) {
                        console.log('‚úÖ Processing dropped files...');
                        
                        // üî• Âº∫Âà∂ÈáçÁΩÆÂ§ÑÁêÜÁä∂ÊÄÅÔºåÁ°Æ‰øùÊãñÊãΩÂèØ‰ª•Â∑•‰Ωú
                        if (window.isProcessingFiles) {
                            console.log('‚ö†Ô∏è Ê£ÄÊµãÂà∞Â§ÑÁêÜ‰∏≠Áä∂ÊÄÅÔºåÂº∫Âà∂ÈáçÁΩÆ');
                            window.isProcessingFiles = false;
                            window.lastProcessedSignature = null;
                        }
                        
                        switchInputMode('file');
                        console.log('üéØ Ë∞ÉÁî® processUploadedFiles...');
                        processUploadedFiles(files);
                    } else {
                        console.log('‚ùå No files in drop event');
                    }
                });
                
                // Also add support to the file drop zone specifically
                const fileDropZone = document.querySelector('.file-drop-zone');
                if (fileDropZone) {
                    console.log('üìÅ Adding drag support to file drop zone');
                    
                    fileDropZone.addEventListener('dragenter', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('üéØ File drop zone - drag enter');
                        this.style.borderColor = '#667eea';
                        this.style.backgroundColor = '#e0e7ff';
                    });
                    
                    fileDropZone.addEventListener('dragover', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.dataTransfer.dropEffect = 'copy';
                    });
                    
                    fileDropZone.addEventListener('dragleave', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        if (!this.contains(e.relatedTarget)) {
                            this.style.borderColor = '#cbd5e1';
                            this.style.backgroundColor = '#f8fafc';
                        }
                    });
                    
                    fileDropZone.addEventListener('drop', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('üéØ File drop zone - drop detected!');
                        this.style.borderColor = '#cbd5e1';
                        this.style.backgroundColor = '#f8fafc';
                        
                        const files = e.dataTransfer.files;
                        console.log('üìÅ Files dropped on zone:', files.length);
                        if (files.length > 0) {
                            switchInputMode('file');
                            processUploadedFiles(files);
                        }
                    });
                }
            } else {
                console.error('‚ùå Input container not found!');
            }
            
            // Also use event delegation for better reliability
            document.addEventListener('click', function(event) {
                // Handle node content clicks for file nodes
                if (event.target.closest('.node-content') && 
                    !event.target.classList.contains('node-action') &&
                    !event.target.closest('.node-actions')) {
                    
                    const nodeContent = event.target.closest('.node-content');
                    const nodeIcon = nodeContent.querySelector('.node-icon');
                    
                    // Only show content for file nodes (not folders)
                    if (nodeIcon && nodeIcon.classList.contains('file')) {
                        console.log('File node clicked via delegation');
                        showNodeContent(event, nodeContent);
                        return;
                    }
                }
                
                if (event.target.classList.contains('node-action')) {
                    const buttonText = event.target.textContent || event.target.innerHTML;
                    console.log('üéØ Node action clicked via delegation:', buttonText, event.target);
                    
                    if (buttonText.includes('‚úèÔ∏è')) {
                        editNode(event, event.target);
                    } else if (buttonText.includes('üóëÔ∏è')) {
                        console.log('üóëÔ∏è Delete detected via delegation, calling deleteNode');
                        deleteNode(event, event.target);
                    } else if (buttonText.includes('‚ûï')) {
                        addChildItem(event, event.target);
                    } else {
                        console.log('ü§î Unknown button text:', buttonText);
                    }
                } else if (event.target.classList.contains('node-select-btn')) {
                    // Handle selection button clicks
                    toggleSelection(event, event.target);
                }
            });
        });
        
        // Node selection function for checkboxes
        window.toggleNodeSelection = function(event, checkboxElement) {
            console.log('üéØ toggleNodeSelection called!', event, checkboxElement);
            event.stopPropagation(); // Prevent triggering node content click
            
            const isSelected = checkboxElement.classList.contains('selected');
            const nodeContent = checkboxElement.closest('.node-content');
            const title = nodeContent.querySelector('.node-title').textContent;
            const treeNode = nodeContent.closest('.tree-node');
            const isFolder = nodeContent.querySelector('.node-icon').classList.contains('folder');
            
            console.log(`üîç Node: ${title}, Selected: ${isSelected}, IsFolder: ${isFolder}`);
            
            if (isSelected) {
                // Deselect this node
                deselectNodeCheckbox(checkboxElement, title);
                
                // If it's a folder, deselect all children
                if (isFolder) {
                    deselectAllChildren(treeNode);
                }
            } else {
                // Select this node
                selectNodeCheckbox(checkboxElement, title, nodeContent);
                
                // If it's a folder, select all children
                if (isFolder) {
                    selectAllChildren(treeNode);
                }
            }
            
            // Update UI to show selected count
            updateSelectionUI();
        }
        
        function selectNodeCheckbox(checkboxElement, title, nodeContent) {
            checkboxElement.classList.add('selected');
            checkboxElement.textContent = '‚úì';
            console.log(`‚úÖ Selected: ${title}`);
            
            // Add to global selectedNodes array
            if (typeof selectedNodes !== 'undefined') {
                if (!selectedNodes.includes(title)) {
                    selectedNodes.push(title);
                    // Also add to selectedNodesData if it exists
                    if (typeof selectedNodesData !== 'undefined') {
                        // üî• Ëé∑ÂèñÁúüÂÆûÊñá‰ª∂ÂÜÖÂÆπÁî®‰∫éÂàÜÊûê
                        let fileContent = nodeContentStore[title] || '';
                        
                        // Â¶ÇÊûúÊòØ‰∏ä‰º†ÁöÑÊñá‰ª∂ÔºåÂ∞ùËØï‰ªéÂ≠òÂÇ®‰∏≠Ëé∑ÂèñtextContent
                        const treeNode = nodeContent.closest('.tree-node');
                        const storageKey = treeNode?.getAttribute('data-file-storage-key');
                        if (storageKey && !fileContent) {
                            try {
                                const fileDataStr = localStorage.getItem(storageKey);
                                if (fileDataStr) {
                                    const fileData = JSON.parse(fileDataStr);
                                    fileContent = fileData.textContent || '';
                                }
                            } catch (error) {
                                console.log('‚ö†Ô∏è Êó†Ê≥ï‰ªéÊñá‰ª∂Â≠òÂÇ®Ëé∑ÂèñÂÜÖÂÆπ:', error);
                            }
                        }
                        
                        selectedNodesData[title] = {
                            content: fileContent || getSampleContent(title) || '',
                            type: nodeContent.querySelector('.node-icon').classList.contains('folder') ? 'folder' : 'file',
                            element: nodeContent
                        };
                    }
                }
            }
        }
        
        function deselectNodeCheckbox(checkboxElement, title) {
            checkboxElement.classList.remove('selected');
            checkboxElement.textContent = '‚úì';
            console.log(`üî≤ Deselected: ${title}`);
            
            // Remove from global selectedNodes array
            if (typeof selectedNodes !== 'undefined') {
                selectedNodes = selectedNodes.filter(name => name !== title);
                // Also remove from selectedNodesData if it exists
                if (typeof selectedNodesData !== 'undefined') {
                    delete selectedNodesData[title];
                }
            }
        }
        
        function selectAllChildren(parentTreeNode) {
            const childrenContainer = parentTreeNode.querySelector('.node-children');
            if (childrenContainer) {
                const childNodes = childrenContainer.querySelectorAll('.tree-node');
                childNodes.forEach(childNode => {
                    const childCheckbox = childNode.querySelector('.node-checkbox');
                    const childNodeContent = childNode.querySelector('.node-content');
                    const childTitle = childNodeContent.querySelector('.node-title').textContent;
                    
                    if (childCheckbox && !childCheckbox.classList.contains('selected')) {
                        selectNodeCheckbox(childCheckbox, childTitle, childNodeContent);
                        
                        // If this child is also a folder, recursively select its children
                        const childIsFolder = childNodeContent.querySelector('.node-icon').classList.contains('folder');
                        if (childIsFolder) {
                            selectAllChildren(childNode);
                        }
                    }
                });
            }
        }
        
        function deselectAllChildren(parentTreeNode) {
            const childrenContainer = parentTreeNode.querySelector('.node-children');
            if (childrenContainer) {
                const childNodes = childrenContainer.querySelectorAll('.tree-node');
                childNodes.forEach(childNode => {
                    const childCheckbox = childNode.querySelector('.node-checkbox');
                    const childNodeContent = childNode.querySelector('.node-content');
                    const childTitle = childNodeContent.querySelector('.node-title').textContent;
                    
                    if (childCheckbox && childCheckbox.classList.contains('selected')) {
                        deselectNodeCheckbox(childCheckbox, childTitle);
                        
                        // If this child is also a folder, recursively deselect its children
                        const childIsFolder = childNodeContent.querySelector('.node-icon').classList.contains('folder');
                        if (childIsFolder) {
                            deselectAllChildren(childNode);
                        }
                    }
                });
            }
        }
        
        function updateSelectionUI() {
            const selectedCount = document.querySelectorAll('.node-checkbox.selected').length;
            console.log(`üìä Total selected nodes: ${selectedCount}`);
            
            // Enable/disable the insight analysis button based on selection
            const insightButton = document.querySelector('button[onclick="startInsightAnalysis()"]');
            if (insightButton) {
                if (selectedCount > 0) {
                    // Enable button
                    insightButton.disabled = false;
                    insightButton.style.opacity = '1';
                    insightButton.style.cursor = 'pointer';
                    insightButton.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
                    console.log('‚úÖ Insight Analysis button enabled');
                } else {
                    // Disable button
                    insightButton.disabled = true;
                    insightButton.style.opacity = '0.5';
                    insightButton.style.cursor = 'not-allowed';
                    insightButton.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
                    console.log('‚ùå Insight Analysis button disabled');
                }
            }
            
            // Update selected nodes display if function exists
            if (typeof updateSelectedDocsDisplay === 'function') {
                updateSelectedDocsDisplay();
            }
            
            // Log the selection
            if (selectedCount > 0) {
                console.log('Selected nodes:', typeof selectedNodes !== 'undefined' ? selectedNodes : []);
            }
        }
        
        // Knowledge Base Panel Functions (integrated) - Global scope
        let isRecording = false;
        let selectedNode = null;

        // Knowledge Graph Visualization
        window.visualizeGraph = function(graphId, graphData) {
            console.log('üï∏Ô∏è Visualizing knowledge graph:', graphId, graphData);
            
            const container = document.getElementById(`graph-${graphId}`);
            if (!container) {
                console.error('Graph container not found');
                return;
            }
            
            // Clear existing content
            container.innerHTML = '';
            
            // Create SVG for graph visualization
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '300');
            svg.style.background = 'white';
            
            // Simple force-directed layout simulation
            const nodes = graphData.nodes || [];
            const edges = graphData.edges || [];
            
            if (nodes.length === 0) {
                container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #6b7280;">No graph data available</div>';
                return;
            }
            
            // Position nodes in a simple layout
            const width = container.offsetWidth || 400;
            const height = 300;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Position nodes in a circle if multiple, or center if single
            nodes.forEach((node, index) => {
                if (nodes.length === 1) {
                    node.x = centerX;
                    node.y = centerY;
                } else {
                    const angle = (2 * Math.PI * index) / nodes.length;
                    const radius = Math.min(width, height) * 0.3;
                    node.x = centerX + radius * Math.cos(angle);
                    node.y = centerY + radius * Math.sin(angle);
                }
            });
            
            // Draw edges
            edges.forEach(edge => {
                const sourceNode = nodes.find(n => n.id === edge.source);
                const targetNode = nodes.find(n => n.id === edge.target);
                
                if (sourceNode && targetNode) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', sourceNode.x);
                    line.setAttribute('y1', sourceNode.y);
                    line.setAttribute('x2', targetNode.x);
                    line.setAttribute('y2', targetNode.y);
                    line.setAttribute('stroke', '#8b5cf6');
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('opacity', '0.6');
                    svg.appendChild(line);
                    
                    // Add edge label
                    if (edge.label) {
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', (sourceNode.x + targetNode.x) / 2);
                        text.setAttribute('y', (sourceNode.y + targetNode.y) / 2);
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('font-size', '10');
                        text.setAttribute('fill', '#6b7280');
                        text.textContent = edge.label;
                        svg.appendChild(text);
                    }
                }
            });
            
            // Draw nodes
            nodes.forEach(node => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', node.x);
                circle.setAttribute('cy', node.y);
                circle.setAttribute('r', node.size || 20);
                circle.setAttribute('fill', node.color || '#8b5cf6');
                circle.setAttribute('stroke', 'white');
                circle.setAttribute('stroke-width', '2');
                circle.style.cursor = 'pointer';
                
                // Add hover effect
                circle.addEventListener('mouseenter', function() {
                    this.setAttribute('r', (node.size || 20) + 5);
                });
                circle.addEventListener('mouseleave', function() {
                    this.setAttribute('r', node.size || 20);
                });
                
                svg.appendChild(circle);
                
                // Add node label
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', node.x);
                text.setAttribute('y', node.y + 5);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', '12');
                text.setAttribute('font-weight', 'bold');
                text.setAttribute('fill', 'white');
                text.textContent = node.label || node.id;
                svg.appendChild(text);
            });
            
            container.appendChild(svg);
            
            // Add graph controls
            const controls = document.createElement('div');
            controls.style.cssText = 'position: absolute; top: 8px; right: 8px; display: flex; gap: 4px;';
            
            const resetBtn = document.createElement('button');
            resetBtn.textContent = 'üîÑ';
            resetBtn.style.cssText = 'width: 24px; height: 24px; border: none; background: rgba(139, 92, 246, 0.8); color: white; border-radius: 4px; cursor: pointer; font-size: 12px;';
            resetBtn.title = 'Reset View';
            resetBtn.onclick = () => visualizeGraph(graphId, graphData);
            
            const fullscreenBtn = document.createElement('button');
            fullscreenBtn.textContent = '‚õ∂';
            fullscreenBtn.style.cssText = 'width: 24px; height: 24px; border: none; background: rgba(139, 92, 246, 0.8); color: white; border-radius: 4px; cursor: pointer; font-size: 12px;';
            fullscreenBtn.title = 'Fullscreen';
            fullscreenBtn.onclick = () => {
                const modal = document.createElement('div');
                modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.8); z-index: 10000; display: flex; align-items: center; justify-content: center;';
                
                const modalContent = document.createElement('div');
                modalContent.style.cssText = 'width: 90vw; height: 90vh; background: white; border-radius: 8px; position: relative;';
                
                const closeBtn = document.createElement('button');
                closeBtn.textContent = '‚úï';
                closeBtn.style.cssText = 'position: absolute; top: 8px; right: 8px; width: 32px; height: 32px; border: none; background: #ef4444; color: white; border-radius: 4px; cursor: pointer;';
                closeBtn.onclick = () => modal.remove();
                
                modalContent.appendChild(closeBtn);
                modalContent.innerHTML += `<div id="fullscreen-graph-${graphId}" style="width: 100%; height: 100%; padding: 40px;"></div>`;
                
                modal.appendChild(modalContent);
                document.body.appendChild(modal);
                
                // Render full-size graph
                setTimeout(() => {
                    const fullContainer = document.getElementById(`fullscreen-graph-${graphId}`);
                    if (fullContainer) {
                        visualizeGraphInContainer(fullContainer, graphData);
                    }
                }, 100);
            };
            
            controls.appendChild(resetBtn);
            controls.appendChild(fullscreenBtn);
            container.appendChild(controls);
        }
        
        function visualizeGraphInContainer(container, graphData) {
            // Similar to visualizeGraph but adapted for different container sizes
            container.innerHTML = '';
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            
            const nodes = graphData.nodes || [];
            const edges = graphData.edges || [];
            
            const width = container.offsetWidth;
            const height = container.offsetHeight;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Position and draw similar to visualizeGraph but with larger dimensions
            nodes.forEach((node, index) => {
                if (nodes.length === 1) {
                    node.x = centerX;
                    node.y = centerY;
                } else {
                    const angle = (2 * Math.PI * index) / nodes.length;
                    const radius = Math.min(width, height) * 0.25;
                    node.x = centerX + radius * Math.cos(angle);
                    node.y = centerY + radius * Math.sin(angle);
                }
            });
            
            // Draw edges and nodes (similar code as above but scaled)
            edges.forEach(edge => {
                const sourceNode = nodes.find(n => n.id === edge.source);
                const targetNode = nodes.find(n => n.id === edge.target);
                
                if (sourceNode && targetNode) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', sourceNode.x);
                    line.setAttribute('y1', sourceNode.y);
                    line.setAttribute('x2', targetNode.x);
                    line.setAttribute('y2', targetNode.y);
                    line.setAttribute('stroke', '#8b5cf6');
                    line.setAttribute('stroke-width', '3');
                    line.setAttribute('opacity', '0.6');
                    svg.appendChild(line);
                }
            });
            
            nodes.forEach(node => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', node.x);
                circle.setAttribute('cy', node.y);
                circle.setAttribute('r', (node.size || 20) * 1.5);
                circle.setAttribute('fill', node.color || '#8b5cf6');
                circle.setAttribute('stroke', 'white');
                circle.setAttribute('stroke-width', '3');
                svg.appendChild(circle);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', node.x);
                text.setAttribute('y', node.y + 8);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', '16');
                text.setAttribute('font-weight', 'bold');
                text.setAttribute('fill', 'white');
                text.textContent = node.label || node.id;
                svg.appendChild(text);
            });
            
            container.appendChild(svg);
        }

        // Áü•ËØÜÂ∫ìÂáΩÊï∞Â∑≤Âú®‰∏äÈù¢ÂÆö‰πâÔºåÈÅøÂÖçÈáçÂ§ç

        // ÊµãËØïÂáΩÊï∞ - Áõ¥Êé•Âº∫Âà∂ÊâìÂºÄÈù¢Êùø
        window.testOpenPanel = function() {
            console.log('üß™ Testing panel opening...');
            const panel = document.getElementById('knowledgePanel');
            if (panel) {
                panel.style.right = '0px';
                panel.style.display = 'flex';
                console.log('üß™ Panel forced to be visible');
            }
            const overlay = document.getElementById('panelOverlay');
            if (overlay) {
                overlay.style.opacity = '1';
                overlay.style.visibility = 'visible';
                console.log('üß™ Overlay forced to be visible');
            }
        }

        window.closeKnowledgePanel = function() {
            const panel = document.getElementById('knowledgePanel');
            const overlay = document.getElementById('panelOverlay');
            console.log('üö™ closeKnowledgePanel called!', {panel, overlay});
            if (panel) panel.classList.remove('open');
            if (overlay) overlay.classList.remove('show');
        }

        window.toggleKnowledgePanel = function() {
            const panel = document.getElementById('knowledgePanel');
            if (panel && panel.classList.contains('open')) {
                closeKnowledgePanel();
            } else {
                openKnowledgePanel();
            }
        }




        function toggleNode(event, element) {
            event.stopPropagation();
            const children = element.closest('.tree-node').querySelector('.node-children');
            const isExpanded = children.classList.contains('expanded');
            
            if (isExpanded) {
                children.classList.remove('expanded');
                element.innerHTML = '‚ñ∂';
            } else {
                children.classList.add('expanded');
                element.innerHTML = '‚ñº';
            }
        }

        function selectNode(element, event = null) {
            const isMultiSelect = event && (event.ctrlKey || event.metaKey);
            const title = element.querySelector('.node-title').textContent;
            
            if (isMultiSelect) {
                // Multi-select mode
                if (element.classList.contains('selected')) {
                    // Deselect
                    element.classList.remove('selected');
                    selectedNodes = selectedNodes.filter(node => node !== title);
                    delete selectedNodesData[title];
                } else {
                    // Add to selection
                    element.classList.add('selected');
                    selectedNodes.push(title);
                    selectedNodesData[title] = {
                        content: nodeContentStore[title] || getSampleContent(title) || '',
                        type: element.querySelector('.node-icon').classList.contains('folder') ? 'folder' : 'file',
                        element: element
                    };
                }
            } else {
                // Single select mode - clear all others first
                document.querySelectorAll('.node-content.selected').forEach(node => {
                    node.classList.remove('selected');
                });
                selectedNodes = [];
                selectedNodesData = {};
                
                // Select current node
                element.classList.add('selected');
                selectedNodes.push(title);
                // üî• Ëé∑ÂèñÁúüÂÆûÊñá‰ª∂ÂÜÖÂÆπÁî®‰∫éÂàÜÊûê
                let fileContent = nodeContentStore[title] || '';
                
                // Â¶ÇÊûúÊòØ‰∏ä‰º†ÁöÑÊñá‰ª∂ÔºåÂ∞ùËØï‰ªéÂ≠òÂÇ®‰∏≠Ëé∑ÂèñtextContent
                const treeNode = element.closest('.tree-node');
                const storageKey = treeNode?.getAttribute('data-file-storage-key');
                if (storageKey && !fileContent) {
                    try {
                        const fileDataStr = localStorage.getItem(storageKey);
                        if (fileDataStr) {
                            const fileData = JSON.parse(fileDataStr);
                            fileContent = fileData.textContent || '';
                            console.log('‚úÖ Ëé∑ÂèñÂà∞Êñá‰ª∂Â≠òÂÇ®ÂÜÖÂÆπÁî®‰∫éÂàÜÊûê:', fileContent.length, 'Â≠óÁ¨¶');
                        }
                    } catch (error) {
                        console.log('‚ö†Ô∏è Êó†Ê≥ï‰ªéÊñá‰ª∂Â≠òÂÇ®Ëé∑ÂèñÂÜÖÂÆπ:', error);
                    }
                }
                
                selectedNodesData[title] = {
                    content: fileContent || getSampleContent(title) || '',
                    type: element.querySelector('.node-icon').classList.contains('folder') ? 'folder' : 'file',
                    element: element
                };
                
                // If this is a folder, also select all its children
                if (selectedNodesData[title].type === 'folder') {
                    const parentNode = element.parentElement;
                    const childrenContainer = parentNode.querySelector('.node-children');
                    if (childrenContainer) {
                        const children = childrenContainer.querySelectorAll('.node-content');
                        children.forEach(child => {
                            const childTitle = child.querySelector('.node-title').textContent;
                            child.classList.add('selected');
                            selectedNodes.push(childTitle);
                            selectedNodesData[childTitle] = {
                                content: nodeContentStore[childTitle] || getSampleContent(childTitle) || '',
                                type: child.querySelector('.node-icon').classList.contains('folder') ? 'folder' : 'file',
                                element: child
                            };
                        });
                    }
                }
            }
            
            // Update analysis button state (function placeholder)
            // updateAnalysisButtonState(); // ‰∏¥Êó∂Á¶ÅÁî®ÔºåÈÅøÂÖçÈîôËØØ
            
            selectedNode = element;
            console.log('Selected nodes for analysis:', selectedNodes);
        }

        // Toggle selected docs floating panel
        window.toggleSelectedDocsPanel = function() {
            const panel = document.getElementById('selectedDocsPanel');
            const toggle = document.getElementById('selectedDocsPanelToggle');
            const isExpanded = panel.style.right === '0px';
            
            if (isExpanded) {
                panel.style.right = '-350px';
                toggle.querySelector('span').textContent = 'üìã';
            } else {
                panel.style.right = '0px';
                toggle.querySelector('span').textContent = '‚úï';
            }
        }

        // Make selected docs panel draggable
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        

        // Update selected documents display
        function updateSelectedDocsDisplay() {
            const selectedPanel = document.getElementById('selectedDocsPanel');
            const cardsContainer = document.getElementById('selectedDocsCards');
            const selectionCount = document.getElementById('selectionCount');
            const emptyMsg = document.getElementById('emptySelectionMsg');
            const toggle = document.getElementById('selectedDocsPanelToggle');
            
            if (selectedNodes.length > 0) {
                // Show floating panel
                selectedPanel.style.right = '0px';
                if (toggle) {
                    toggle.querySelector('span').textContent = '‚úï';
                    // Add notification animation to toggle button
                    toggle.style.background = '#e0e7ff';
                    setTimeout(() => {
                        toggle.style.background = 'white';
                    }, 1000);
                }
                
                // Update selection count
                if (selectionCount) {
                    selectionCount.textContent = selectedNodes.length;
                }
                
                // Hide empty message
                if (emptyMsg) {
                    emptyMsg.style.display = 'none';
                }
                
                // Update cards container
                cardsContainer.innerHTML = selectedNodes.map(nodeName => {
                    const nodeData = selectedNodesData[nodeName];
                    const nodeType = nodeData ? nodeData.type : 'file';
                    const icon = nodeType === 'folder' ? 'üìÅ' : 'üìÑ';
                    
                    return `
                        <div style="
                            display: flex; align-items: center; justify-content: space-between;
                            background: linear-gradient(135deg, #f8fafc, #ffffff); 
                            border: 1px solid #e2e8f0; border-radius: 12px; 
                            padding: 12px 16px; font-size: 14px; 
                            animation: bounceIn 0.5s ease;
                            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                            transition: all 0.3s ease;
                        ">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 16px;">${icon}</span>
                                <span style="color: #374151; font-weight: 500;">${nodeName}</span>
                            </div>
                            <button onclick="removeFromSelection('${nodeName}')" style="
                                background: none; border: none; color: #ef4444; 
                                cursor: pointer; font-size: 16px; padding: 4px; border-radius: 4px;
                                transition: background 0.2s ease;
                            " onmouseover="this.style.background='#fee2e2'" onmouseout="this.style.background='none'">‚úï</button>
                        </div>
                    `;
                }).join('');
                
                // Enable main analysis button in footer
                const mainAnalysisBtn = document.getElementById('mainInsightAnalysisBtn');
                if (mainAnalysisBtn) {
                    mainAnalysisBtn.disabled = false;
                    mainAnalysisBtn.style.opacity = '1';
                    mainAnalysisBtn.style.cursor = 'pointer';
                }
            } else {
                // Hide floating panel
                selectedPanel.style.right = '-350px';
                if (toggle) {
                    toggle.querySelector('span').textContent = 'üìã';
                    toggle.style.background = 'white';
                }
                
                // Reset count and show empty message
                if (selectionCount) {
                    selectionCount.textContent = '0';
                }
                if (emptyMsg) {
                    emptyMsg.style.display = 'block';
                }
                
                // Clear cards container
                cardsContainer.innerHTML = '';
                
                // Disable main analysis button in footer
                const mainAnalysisBtn = document.getElementById('mainInsightAnalysisBtn');
                if (mainAnalysisBtn) {
                    mainAnalysisBtn.disabled = true;
                    mainAnalysisBtn.style.opacity = '0.5';
                    mainAnalysisBtn.style.cursor = 'not-allowed';
                }
            }
        }

        // Remove document from selection
        window.removeFromSelection = function(nodeName) {
            selectedNodes = selectedNodes.filter(name => name !== nodeName);
            delete selectedNodesData[nodeName];
            
            // Remove visual selection from tree - find the select button and update it
            const allNodes = document.querySelectorAll('.node-content');
            allNodes.forEach(node => {
                const title = node.querySelector('.node-title').textContent;
                if (title === nodeName) {
                    const selectBtn = node.querySelector('.node-select-btn');
                    if (selectBtn) {
                        selectBtn.setAttribute('data-selected', 'false');
                    }
                }
            });
            
            updateSelectedDocsDisplay();
        }

        // Start insight analysis for selected nodes
        window.startInsightAnalysis = function() {
            console.log('üîç startInsightAnalysis function called!');
            console.log('üîç Selected nodes:', selectedNodes);
            console.log('üîç Selected nodes count:', selectedNodes.length);
            
            if (selectedNodes.length === 0) {
                showNotification('‚ö†Ô∏è Please select documents to analyze');
                return;
            }
            
            console.log('üîç Starting cross-document insight analysis for:', selectedNodes);
            
            // Test GraphRAG connection before starting
            testGraphRAGConnection().then(isConnected => {
                if (isConnected) {
                    showNotification('üîó GraphRAGÊúçÂä°Â∑≤ËøûÊé•ÔºåÂºÄÂßãÊ∑±Â∫¶ÂàÜÊûê...');
                } else {
                    showNotification('‚ö†Ô∏è GraphRAGÊúçÂä°Á¶ªÁ∫øÔºåÂ∞Ü‰ΩøÁî®Âü∫Á°ÄÂàÜÊûêÊ®°Âºè');
                }
                
                // Show loading modal for cross-document analysis
                showCrossDocumentAnalysisModal(isConnected);
                
                // Start analysis process
                setTimeout(() => {
                    performCrossDocumentAnalysis();
                }, 3000);
            });
        }

        // Test GraphRAG service connection
        async function testGraphRAGConnection() {
            try {
                const response = await fetch('http://127.0.0.1:8000/api/graphrag/health', {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });
                return response.ok;
            } catch (error) {
                console.log('GraphRAGËøûÊé•ÊµãËØïÂ§±Ë¥•:', error);
                return false;
            }
        }

        // Show cross-document analysis loading modal
        function showCrossDocumentAnalysisModal(isGraphRAGConnected = false) {
            const modal = document.createElement('div');
            modal.id = 'crossDocAnalysisModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.8); z-index: 6000; display: flex; 
                align-items: center; justify-content: center;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white; padding: 50px; border-radius: 20px; 
                    max-width: 600px; text-align: center; box-shadow: 0 25px 80px rgba(0,0,0,0.4);
                    position: relative;
                ">
                    <button onclick="document.getElementById('crossDocAnalysisModal').remove()" style="
                        position: absolute; top: 16px; right: 16px; 
                        background: #f3f4f6; border: none; width: 32px; height: 32px; 
                        border-radius: 50%; cursor: pointer; color: #6b7280; font-size: 18px;
                        display: flex; align-items: center; justify-content: center;
                        transition: all 0.2s ease;
                    " onmouseover="this.style.background='#e5e7eb'; this.style.color='#374151'" 
                       onmouseout="this.style.background='#f3f4f6'; this.style.color='#6b7280'">‚úï</button>
                    
                    <div style="margin-bottom: 30px;">
                        <div style="
                            width: 80px; height: 80px; border: 5px solid #e5e7eb; 
                            border-top: 5px solid #667eea; border-radius: 50%; 
                            animation: spin 1.2s linear infinite; margin: 0 auto 20px;
                        "></div>
                        <h2 style="margin: 0; color: #1f2937; font-size: 24px;">üîç Deep Insight Analysis</h2>
                    </div>
                    
                    <div style="margin-bottom: 30px;">
                        <p style="color: #6b7280; margin: 0; font-size: 16px; line-height: 1.5;">
                            Analyzing <strong>${selectedNodes.length}</strong> documents<br>
                            Discovering internal relationships and hidden connections...
                        </p>
                    </div>
                    
                    <div style="
                        background: #f8fafc; border-radius: 12px; padding: 20px; 
                        text-align: left; font-size: 14px; color: #4b5563;
                    ">
                        <div id="analysisProgressSteps">
                            ‚úì Loading selected documents (${selectedNodes.length} files)<br>
                            ‚è≥ Building unified knowledge graph...<br>
                            ‚è≥ Identifying cross-document entity relationships...<br>
                            ‚è≥ Discovering hidden patterns and trends...<br>
                            ‚è≥ Generating insight report...<br>
                        </div>
                    </div>
                    
                    <div style="margin-top: 20px; font-size: 12px; color: #9ca3af;">
                        ${isGraphRAGConnected ? 
                            '‚úÖ Powered by Real GraphRAG Technology ‚Ä¢ Advanced Entity & Relationship Mining' : 
                            '‚ö†Ô∏è Using Fallback Analysis Mode ‚Ä¢ GraphRAG Service Unavailable'
                        }
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Progressive loading simulation
            setTimeout(() => updateAnalysisProgress(
                `‚úì Loading selected documents (${selectedNodes.length} files)<br>‚úì Building unified knowledge graph...<br>‚è≥ Identifying cross-document entity relationships...<br>‚è≥ Discovering hidden patterns and trends...<br>‚è≥ Generating insight report...<br>`
            ), 1000);
            
            setTimeout(() => updateAnalysisProgress(
                `‚úì Loading selected documents (${selectedNodes.length} files)<br>‚úì Building unified knowledge graph...<br>‚úì Identifying cross-document entity relationships...<br>‚è≥ Discovering hidden patterns and trends...<br>‚è≥ Generating insight report...<br>`
            ), 2000);
            
            setTimeout(() => updateAnalysisProgress(
                `‚úì Loading selected documents (${selectedNodes.length} files)<br>‚úì Building unified knowledge graph...<br>‚úì Identifying cross-document entity relationships...<br>‚úì Discovering hidden patterns and trends...<br>‚è≥ Generating insight report...<br>`
            ), 2800);
        }

        function updateAnalysisProgress(html) {
            const progressElement = document.getElementById('analysisProgressSteps');
            if (progressElement) {
                progressElement.innerHTML = html;
            }
        }

        // Perform cross-document analysis
        async function performCrossDocumentAnalysis() {
            // Remove loading modal
            const loadingModal = document.getElementById('crossDocAnalysisModal');
            if (loadingModal) {
                document.body.removeChild(loadingModal);
            }
            
            try {
                // Generate cross-document analysis results (now async)
                const analysisResults = await generateCrossDocumentInsights();
                
                // Debug log
                console.log('Generated analysis results:', analysisResults);
                
                // Update workflow to Analysis step
                updateActiveStep('analysis');
                
                // Show comprehensive results
                showCrossDocumentResults(analysisResults);
                
                console.log('Called showCrossDocumentResults');
            } catch (error) {
                console.error('ÂàÜÊûêËøáÁ®ãÂá∫Èîô:', error);
                showNotification('‚ùå ÂàÜÊûêËøáÁ®ã‰∏≠Âá∫Áé∞ÈîôËØØÔºåËØ∑ÈáçËØï');
            }
        }

        // Generate cross-document insights using real GraphRAG API
        async function generateCrossDocumentInsights() {
            const documentTitles = selectedNodes.join(', ');
            const documentCount = selectedNodes.length;
            
            try {
                // Êî∂ÈõÜÊâÄÊúâÈÄâ‰∏≠ÊñáÊ°£ÁöÑÂÜÖÂÆπ
                const documentContents = await collectSelectedDocumentContents();
                
                // Ë∞ÉÁî®ÁúüÂÆûÁöÑGraphRAG API
                const graphragResults = await callGraphRAGAPI(documentContents);
                
                // Â§ÑÁêÜAPIÂìçÂ∫î
                return processGraphRAGResults(graphragResults, documentCount, selectedNodes);
                
            } catch (error) {
                console.error('GraphRAG APIË∞ÉÁî®Â§±Ë¥•:', error);
                // ÈôçÁ∫ßÂà∞Ê®°ÊãüÊï∞ÊçÆ
                return generateFallbackInsights(documentCount, selectedNodes);
            }
        }

        // Êî∂ÈõÜÈÄâ‰∏≠ÊñáÊ°£ÁöÑÂÆûÈôÖÂÜÖÂÆπ
        async function collectSelectedDocumentContents() {
            const contents = [];
            
            for (const docTitle of selectedNodes) {
                try {
                    // ‰ªélocalStorageÊàñÂÖ∂‰ªñÂ≠òÂÇ®Ëé∑ÂèñÊñáÊ°£ÂÜÖÂÆπ
                    const content = localStorage.getItem(`document_content_${docTitle}`) || 
                                  await fetchDocumentContent(docTitle);
                    
                    if (content) {
                        contents.push({
                            title: docTitle,
                            content: content,
                            type: 'text'
                        });
                    }
                } catch (error) {
                    console.warn(`Êó†Ê≥ïËé∑ÂèñÊñáÊ°£ÂÜÖÂÆπ: ${docTitle}`, error);
                }
            }
            
            return contents;
        }

        // Ë∞ÉÁî®GraphRAG API
        async function callGraphRAGAPI(documentContents) {
            const combinedText = documentContents.map(doc => 
                `=== ${doc.title} ===\n${doc.content}`
            ).join('\n\n');

            console.log('Ë∞ÉÁî®GraphRAG APIÔºåÊñáÊú¨ÈïøÂ∫¶:', combinedText.length);

            // ÂàõÂª∫‰∏Ä‰∏™FileÂØπË±°Êù•ÂèëÈÄÅÊñáÊú¨ÂÜÖÂÆπ
            const textBlob = new Blob([combinedText], { type: 'text/plain' });
            const formData = new FormData();
            formData.append('file', textBlob, `combined_docs_${Date.now()}.txt`);

            const response = await fetch('http://127.0.0.1:8000/api/graphrag/analyze', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                throw new Error(`GraphRAG APIÈîôËØØ: ${response.status}`);
            }

            return await response.json();
        }

        // Â§ÑÁêÜGraphRAG APIÁªìÊûú
        function processGraphRAGResults(apiResponse, documentCount, selectedDocs) {
            console.log('üîç Â§ÑÁêÜGraphRAG APIÂìçÂ∫î:', apiResponse);
            
            // Â§ÑÁêÜÁúüÂÆûGraphRAG APIÂìçÂ∫îÊ†ºÂºè
            const analysis = apiResponse.analysis || {};
            const entities = analysis.entities || [];
            const concepts = analysis.concepts || [];
            const relationships = analysis.relationships || [];
            
            // ÁîüÊàêÊõ¥ÊòìËØªÁöÑÊ¶ÇËßà
            const entityCount = entities.length || 0;
            const relationshipCount = relationships.length || 0;
            let overviewText;
            
            if (entityCount > 20 && relationshipCount > 50) {
                overviewText = `üéØ Ê∑±Â∫¶ÂàÜÊûêÂÆåÊàêÔºÅÂú®ÊÇ®ÁöÑ ${documentCount} ‰ªΩÊñáÊ°£‰∏≠ÔºåÊàë‰ª¨ËØÜÂà´Âá∫ ${entityCount} ‰∏™ÂÖ≥ÈîÆÊ¶ÇÂøµÂÆû‰ΩìÂíå ${relationshipCount} ÁßçÂÖ≥Á≥ªËøûÊé•„ÄÇËøôË°®ÊòéÊÇ®ÁöÑÂÜÖÂÆπ‰ΩìÁ≥ªÁªìÊûÑ‰∏∞ÂØåÔºå‰∏ªÈ¢òË¶ÜÁõñÂπøÊ≥õÔºåÂÖ∑ÊúâÂæàÂ•ΩÁöÑÁü•ËØÜÊ∑±Â∫¶„ÄÇ`;
            } else if (entityCount > 10 && relationshipCount > 20) {
                overviewText = `üìä ÂàÜÊûêÁªìÊûúÂ±ïÁé∞‰∫ÜËâØÂ•ΩÁöÑÂÜÖÂÆπÁªìÊûÑ„ÄÇ‰ªé ${documentCount} ‰ªΩÊñáÊ°£‰∏≠ÊèêÂèñÂá∫ ${entityCount} ‰∏™Ê†∏ÂøÉÊ¶ÇÂøµÂíå ${relationshipCount} ‰∏™ÂÖ≥ËÅîÂÖ≥Á≥ªÔºåÊòæÁ§∫ÊÇ®ÁöÑÂÜÖÂÆπÂú®ÁâπÂÆöÈ¢ÜÂüüÊúâËæÉÂ•ΩÁöÑÈõÜ‰∏≠Â∫¶ÂíåÁõ∏ÂÖ≥ÊÄß„ÄÇ`;
            } else if (entityCount > 0) {
                overviewText = `üîç ÂàùÊ≠•ÂàÜÊûêÂÆåÊàê„ÄÇÂú® ${documentCount} ‰ªΩÊñáÊ°£‰∏≠ÂèëÁé∞ ${entityCount} ‰∏™Ê¶ÇÂøµÂÆû‰ΩìÂíå ${relationshipCount} ‰∏™ÂÖ≥Á≥ªËøûÊé•„ÄÇËôΩÁÑ∂ËßÑÊ®°‰∏çÂ§ßÔºå‰ΩÜ‰∏∫ÂêéÁª≠ÂÜÖÂÆπÊâ©Â±ïÊèê‰æõ‰∫ÜÊ∏ÖÊô∞ÁöÑÊñπÂêë„ÄÇ`;
            } else {
                overviewText = `üìã ÂàÜÊûê‰∫Ü ${documentCount} ‰ªΩÊñáÊ°£Ôºå‰ΩÜÊèêÂèñÁöÑÂÆû‰ΩìÂíåÂÖ≥Á≥ªÊï∞ÈáèÊúâÈôê„ÄÇÂª∫ËÆÆÂ¢ûÂä†Êõ¥Â§öÂÜÖÂÆπ‰∏∞ÂØåÁöÑÊñáÊ°£ÔºåÊàñÊ£ÄÊü•ÊñáÊ°£ÂÜÖÂÆπÁöÑÂÆåÊï¥ÊÄß„ÄÇ`;
            }
            
            return {
                summary: {
                    documentCount: documentCount,
                    documents: selectedDocs,
                    overview: overviewText,
                    keyConnections: [
                        `‚úÖ ÊàêÂäüÂàÜÊûê${documentCount}‰∏™ÊñáÊ°£`,
                        `üéØ ÊèêÂèñ${entityCount}‰∏™ÂÖ≥ÈîÆÂÆû‰Ωì`,
                        `ü§ñ AIÂàÜÊûêÁΩÆ‰ø°Â∫¶: ${Math.round((analysis.confidence || 0.85) * 100)}%`,
                        `üìä ÂÜÖÂÆπÂàÜÊûê: ${analysis.content ? 'ÂÆåÊàê' : 'ÂæÖÂ§ÑÁêÜ'}`
                    ],
                    isReal: true // Ê†áËÆ∞ËøôÊòØÁúüÂÆûÂàÜÊûê
                },
                hiddenPatterns: [
                    {
                        pattern: 'ÂÆû‰ΩìÂàÜÊûê',
                        description: `‰ªéÊñáÊ°£‰∏≠ÊèêÂèñ‰∫Ü${entityCount}‰∏™ÂÖ≥ÈîÆÂÆû‰Ωì`,
                        strength: Math.min(entityCount / 20, 1.0),
                        documents: selectedDocs.slice(0, 2),
                        insight: `AIÂàÜÊûêËØÜÂà´Âá∫${entityCount}‰∏™‰∏ì‰∏öÊ¶ÇÂøµÂíåÂÆû‰Ωì`
                    }
                ],
                crossDocumentRelations: entities.map((entity, i) => ({
                    source: entity,
                    target: entities[(i + 1) % entities.length] || entity,
                    type: 'related',
                    strength: 0.7
                })).slice(0, 5),
                unseenOpportunities: [
                    {
                        opportunity: 'AIÂàÜÊûêÂÆåÊàê',
                        description: `ÊàêÂäüÂàÜÊûê${documentCount}‰∏™ÊñáÊ°£ÔºåÊèêÂèñ${entityCount}‰∏™ÂÆû‰Ωì`,
                        impact: 'high',
                        confidence: analysis.confidence || 0.85,
                        actionable: 'ÁªßÁª≠Ê∑ªÂä†Êõ¥Â§öÊñáÊ°£‰ª•Êâ©Â±ïÁü•ËØÜÂõæË∞±'
                    }
                ],
                networkAnalysis: {
                    totalNodes: entityCount,
                    totalEdges: relationshipCount,
                    avgClustering: 0.5,
                    networkDensity: relationshipCount > 0 ? relationshipCount / (entityCount * (entityCount - 1) / 2) : 0,
                    centralNodes: entities.slice(0, 3),
                    communityCount: Math.ceil(entityCount / 5)
                },
                recommendations: [
                    'üéâ GraphRAGÂàÜÊûêÂ∑≤ÂÆåÊàê',
                    'üìà ÂÆû‰ΩìÊèêÂèñÊàêÂäü',
                    'üîç ÁªßÁª≠Ê∑ªÂä†ÊñáÊ°£‰ª•Êâ©Â±ïÂàÜÊûê',
                    'üìä Êü•ÁúãÁü•ËØÜÂõæË∞±ÂèØËßÜÂåñÁªìÊûú'
                ],
                // ‰∏∫Áü•ËØÜÂõæË∞±ÁîüÊàêÊï∞ÊçÆ
                entities: entities,
                concepts: concepts,
                relationships: relationships, // Ê∑ªÂä†ÂÖ≥Á≥ªÊï∞ÊçÆ
                graphData: {
                    nodes: entities.map((entity, i) => ({
                        id: entity,
                        name: entity,
                        type: 'entity',
                        group: 2
                    })).concat(concepts.map((concept, i) => ({
                        id: concept,
                        name: concept,
                        type: 'concept',
                        group: 1
                    }))),
                    links: relationships.map((rel, i) => ({
                        source: rel.source,
                        target: rel.target,
                        type: rel.type || 'related',
                        description: rel.description || '',
                        value: 0.8
                    }))
                }
            };
        }

        // ÈôçÁ∫ßÂà∞Ê®°ÊãüÊï∞ÊçÆÁöÑÂáΩÊï∞
        function generateFallbackInsights(documentCount, selectedDocs) {
            console.warn('‰ΩøÁî®Ê®°ÊãüÊï∞ÊçÆ‰Ωú‰∏∫GraphRAGÈôçÁ∫ßÊñπÊ°à');
            
            // ÁîüÊàê‰∏∞ÂØåÁöÑÊ®°ÊãüÂÆû‰ΩìÂíåÂÖ≥Á≥ªÊï∞ÊçÆ
            const mockEntities = [
                'GraphRAGÁ≥ªÁªü', 'Áü•ËØÜÂõæË∞±', 'RAGÊäÄÊúØ', 'LLMÊ®°Âûã', 'ÂêëÈáèÊêúÁ¥¢',
                'ÂÆû‰ΩìÊèêÂèñ', 'ÂÖ≥Á≥ªËØÜÂà´', 'Êï∞ÊçÆÂàÜÊûê', 'ÂÜÖÂÆπÁêÜËß£', 'Êô∫ËÉΩÈóÆÁ≠î',
                'ÊñáÊ°£Â§ÑÁêÜ', 'ËØ≠‰πâÂàÜÊûê', '‰ø°ÊÅØÊ£ÄÁ¥¢', 'Ê∑±Â∫¶Â≠¶‰π†', 'Ëá™ÁÑ∂ËØ≠Ë®ÄÂ§ÑÁêÜ'
            ];
            
            const mockRelations = [
                { source: 'GraphRAGÁ≥ªÁªü', target: 'Áü•ËØÜÂõæË∞±', type: 'uses', strength: 0.9 },
                { source: 'RAGÊäÄÊúØ', target: 'LLMÊ®°Âûã', type: 'combines', strength: 0.8 },
                { source: 'ÂÆû‰ΩìÊèêÂèñ', target: 'ÂÖ≥Á≥ªËØÜÂà´', type: 'enables', strength: 0.7 },
                { source: 'ÊñáÊ°£Â§ÑÁêÜ', target: 'ËØ≠‰πâÂàÜÊûê', type: 'includes', strength: 0.6 },
                { source: 'Áü•ËØÜÂõæË∞±', target: 'Êô∫ËÉΩÈóÆÁ≠î', type: 'supports', strength: 0.8 }
            ];
            
            return {
                summary: {
                    documentCount: documentCount,
                    documents: selectedDocs,
                    overview: `‚ö†Ô∏è GraphRAGÊúçÂä°‰∏çÂèØÁî®Ôºå‰ΩøÁî®Âü∫Á°ÄÂàÜÊûêÊ®°Âºè„ÄÇÂèëÁé∞ ${mockEntities.length} ‰∏™Ê¶ÇÂøµÂÆû‰ΩìÂíå ${mockRelations.length} ‰∏™ÊΩúÂú®ÂÖ≥ËÅî„ÄÇ`,
                    keyConnections: [
                        'ÊñáÊ°£Èó¥Â≠òÂú®‰∏ªÈ¢òÈáçÂè†ÂíåÊ¶ÇÂøµÂÖ≥ËÅî',
                        'Âü∫‰∫éÂÖ≥ÈîÆËØçÂàÜÊûêÂèëÁé∞ÂÜÖÂÆπÁõ∏ÂÖ≥ÊÄß', 
                        'Âª∫ËÆÆÂêØÁî®GraphRAGÊúçÂä°Ëé∑ÂæóÊ∑±Â∫¶Ê¥ûÂØü',
                        'ÂΩìÂâçÂàÜÊûê‰∏∫ÁÆÄÂåñÁâàÊú¨ÔºåÂäüËÉΩÂèóÈôê'
                    ],
                    isReal: false // Ê†áËÆ∞ËøôÊòØÈôçÁ∫ßÂàÜÊûê
                },
                hiddenPatterns: [
                    {
                        pattern: 'GraphRAGÊäÄÊúØÊ†à',
                        description: 'Ê∂âÂèäÂõæÊï∞ÊçÆÂ∫ì„ÄÅÂêëÈáèÊêúÁ¥¢„ÄÅËØ≠Ë®ÄÊ®°ÂûãÁ≠âÊ†∏ÂøÉÊäÄÊúØÁªÑ‰ª∂„ÄÇ',
                        strength: 0.8,
                        documents: selectedDocs.slice(0, 2),
                        insight: 'ÊäÄÊúØÊñáÊ°£ÊòæÁ§∫‰∫ÜÂÆåÊï¥ÁöÑRAGÁ≥ªÁªüÊû∂ÊûÑËÆæËÆ°„ÄÇ'
                    },
                    {
                        pattern: 'Áü•ËØÜÂõæË∞±ÊûÑÂª∫',
                        description: 'ÂåÖÂê´ÂÆû‰ΩìÊèêÂèñ„ÄÅÂÖ≥Á≥ªËØÜÂà´„ÄÅÂõæË∞±Â≠òÂÇ®Á≠âÂÖ≥ÈîÆÁéØËäÇ„ÄÇ',
                        strength: 0.7,
                        documents: selectedDocs.slice(1, 3),
                        insight: 'Â±ïÁé∞‰∫ÜÁ≥ªÁªüÂåñÁöÑÁü•ËØÜÂõæË∞±ÊûÑÂª∫ÊµÅÁ®ã„ÄÇ'
                    }
                ],
                crossDocumentRelations: mockRelations,
                mockEntities: mockEntities, // Ê∑ªÂä†ÂÆû‰ΩìÊï∞ÊçÆ
                unseenOpportunities: [
                    {
                        opportunity: 'ÂçáÁ∫ßÂàÜÊûêÁ≥ªÁªü',
                        description: 'ÂêØÁî®GraphRAGÊúçÂä°‰ª•Ëé∑ÂæóÁúüÊ≠£ÁöÑÂÆû‰ΩìÂÖ≥Á≥ªÂàÜÊûêÂíåÁü•ËØÜÂõæË∞±ÊûÑÂª∫',
                        impact: 'high',
                        confidence: 1.0,
                        actionable: 'Ê£ÄÊü•GraphRAGÊúçÂä°Áä∂ÊÄÅÂπ∂ÈáçÊñ∞ÈÖçÁΩÆAPIËøûÊé•'
                    }
                ],
                networkAnalysis: {
                    totalNodes: mockEntities.length,
                    totalEdges: mockRelations.length,
                    avgClustering: 0.6,
                    networkDensity: mockRelations.length / (mockEntities.length * (mockEntities.length - 1) / 2),
                    centralNodes: ['GraphRAGÁ≥ªÁªü', 'Áü•ËØÜÂõæË∞±', 'RAGÊäÄÊúØ'],
                    communityCount: 3
                },
                recommendations: [
                    'üîß Ê£ÄÊü•Âπ∂ÂêØÂä®GraphRAGÊúçÂä° (http://localhost:8000)',
                    'üîó Á°Æ‰øùAPIËøûÊé•Ê≠£Â∏∏Â∑•‰Ωú',
                    '‚ö° ÈáçÊñ∞ËøêË°åÂàÜÊûê‰ª•Ëé∑ÂæóÂÆåÊï¥ÂäüËÉΩ',
                    'üìä ÂçáÁ∫ßÂà∞ÁúüÂÆûÁöÑÁü•ËØÜÂõæË∞±ÂàÜÊûê'
                ]
            };
        }

        // ËæÖÂä©ÂáΩÊï∞ÔºöÊèêÂèñÂÖ≥ÈîÆËøûÊé•
        function extractKeyConnections(graphData, graphAnalysis) {
            if (!graphData || !graphData.links) return ['GraphRAGÂàÜÊûêÊ≠£Âú®Â§ÑÁêÜ‰∏≠...'];
            
            const connections = [];
            const strongLinks = graphData.links.filter(link => link.weight > 0.7);
            
            strongLinks.slice(0, 4).forEach(link => {
                const sourceNode = graphData.nodes.find(n => n.id === link.source);
                const targetNode = graphData.nodes.find(n => n.id === link.target);
                
                if (sourceNode && targetNode) {
                    connections.push(`Âº∫ÂÖ≥ËÅî: ${sourceNode.name} ${link.type || 'ÂÖ≥ËÅî'} ${targetNode.name} (ÁΩÆ‰ø°Â∫¶: ${Math.round(link.weight * 100)}%)`);
                }
            });
            
            return connections.length > 0 ? connections : ['Â∑≤ËØÜÂà´ÂÆû‰ΩìÈó¥ÂÖ≥Á≥ªÔºåÊ≠£Âú®Ê∑±Â∫¶ÂàÜÊûê‰∏≠...'];
        }

        // ËæÖÂä©ÂáΩÊï∞ÔºöÊèêÂèñÂÖ≥ÈîÆÊ¥ûÂØüÔºàÊîπËøõÂèØËØªÊÄßÔºâ
        function extractHiddenPatterns(graphData, graphAnalysis) {
            const patterns = [];
            
            // 1. ËØ≠‰πâÁ§æÂå∫ÂàÜÊûêÔºàÊñ∞ÁöÑGraphRAGÂäüËÉΩÔºâ
            if (graphAnalysis?.communities && graphAnalysis.communities.length > 0) {
                graphAnalysis.communities.forEach((community, index) => {
                    if (community.size >= 2 && community.semanticScore > 0.5) {
                        patterns.push({
                            pattern: `ËØ≠‰πâÁ§æÂå∫: ${community.theme}`,
                            description: `ÂèëÁé∞‰∫Ü‰∏Ä‰∏™ËØ≠‰πâ‰∏ÄËá¥ÊÄß‰∏∫ ${(community.semanticScore * 100).toFixed(1)}% ÁöÑ‰∏ì‰∏öÊ¶ÇÂøµÈõÜÁæ§ÔºåÂåÖÂê´ ${community.size} ‰∏™È´òÂ∫¶Áõ∏ÂÖ≥ÂÆû‰Ωì„ÄÇËØ•Á§æÂå∫Âõ¥Áªï"${community.centralNode?.name || 'Ê†∏ÂøÉÊ¶ÇÂøµ'}"ÊûÑÂª∫„ÄÇ`,
                            insight: `üéØ Ê∑±Â∫¶Ê¥ûÂØüÔºöËøô‰∏™ËØ≠‰πâÁ§æÂå∫Ë°®ÊòéÊÇ®Âú®"${community.theme}"ÊñπÈù¢ÊúâÁ≥ªÁªüÊÄßÁöÑÁü•ËØÜÁßØÁ¥Ø„ÄÇÂª∫ËÆÆ‰ª•"${community.centralNode?.name}"‰∏∫Ê†∏ÂøÉÔºåÂàõÂª∫‰∏ìÈ¢òÂÜÖÂÆπÁ≥ªÂàóÔºåÂÖÖÂàÜÂèëÊå•ÊÇ®Âú®ËØ•È¢ÜÂüüÁöÑ‰∏ì‰∏ö‰ºòÂäø„ÄÇ`,
                            confidence: community.semanticScore,
                            actionable: `ÂàõÂª∫${community.theme}‰∏ìÈ¢òÁ≥ªÂàóÔºåÊ∑±ÂåñÊ†∏ÂøÉÊ¶ÇÂøµ"${community.centralNode?.name}"ÁöÑÂÜÖÂÆπ‰ª∑ÂÄº`
                        });
                    }
                });
            }
            
            // 2. Ê¶ÇÂøµÊé®ÁêÜË∑ØÂæÑÂàÜÊûêÔºàGraphRAGÊ†∏ÂøÉÂäüËÉΩÔºâ
            if (graphAnalysis?.pathAnalysis && graphAnalysis.pathAnalysis.length > 0) {
                const topPaths = graphAnalysis.pathAnalysis.slice(0, 3);
                topPaths.forEach((pathData, index) => {
                    patterns.push({
                        pattern: `Ê¶ÇÂøµÊé®ÁêÜÈìæ: ${pathData.start} ‚Üí ${pathData.end}`,
                        description: `GraphRAGÂàÜÊûêÂèëÁé∞‰∫Ü‰∏ÄÊù°ÁΩÆ‰ø°Â∫¶‰∏∫ ${(pathData.confidence * 100).toFixed(1)}% ÁöÑÊ¶ÇÂøµÊé®ÁêÜË∑ØÂæÑÔºö${pathData.path.join(' ‚Üí ')}„ÄÇ${pathData.insight}`,
                        insight: `üîó Êé®ÁêÜÊ¥ûÂØüÔºöËøôÊù°Ë∑ØÂæÑÊè≠Á§∫‰∫ÜÊÇ®ÂÜÖÂÆπ‰∏≠ÁöÑÈöêÊÄßÈÄªËæëËøûÊé•„ÄÇÈÄöËøáËøôÁßçÊ¶ÇÂøµÈìæÂºèÊÄùËÄÉÔºåÂèØ‰ª•ÂàõÂª∫Êõ¥ÂÖ∑ËØ¥ÊúçÂäõÂíåÈÄªËæëÊÄßÁöÑÂÜÖÂÆπÊ°ÜÊû∂„ÄÇ`,
                        confidence: pathData.confidence,
                        actionable: `Âü∫‰∫éÊ≠§Êé®ÁêÜË∑ØÂæÑÂàõÂª∫ÈÄªËæëÊÄßÂÜÖÂÆπÔºåÂºïÂØºËØªËÄÖ‰ªé"${pathData.start}"ÁêÜËß£Âà∞"${pathData.end}"`
                    });
                });
            }
            
            // 3. Áü•ËØÜÁº∫Âè£ÂèëÁé∞ÔºàGraphRAGÁã¨ÁâπÂäüËÉΩÔºâ
            if (graphAnalysis?.knowledgeGaps && graphAnalysis.knowledgeGaps.length > 0) {
                const criticalGaps = graphAnalysis.knowledgeGaps.filter(gap => gap.priority === 'high').slice(0, 2);
                criticalGaps.forEach((gap, index) => {
                    patterns.push({
                        pattern: `Áü•ËØÜÁº∫Âè£: ${gap.concept || gap.concept1}`,
                        description: gap.description,
                        insight: `‚ö° Êú∫‰ºöÊ¥ûÂØüÔºö${gap.suggestion}„ÄÇËøôÁßçÁü•ËØÜÁº∫Âè£ÂæÄÂæÄÊòØÂÜÖÂÆπÂàõ‰ΩúÁöÑÈªÑÈáëÊú∫‰ºöÔºåÂ°´Ë°•Ëøô‰∫õÁ©∫ÁôΩÂèØ‰ª•ÊòæËëóÊèêÂçáÊÇ®ÂÜÖÂÆπ‰ΩìÁ≥ªÁöÑÂÆåÊï¥ÊÄß„ÄÇ`,
                        confidence: 0.8,
                        actionable: gap.suggestion
                    });
                });
            }
            
            // 4. ‰º†ÁªüÈõÜÁæ§ÂàÜÊûêÔºàÂêëÂêéÂÖºÂÆπÔºâ
            if (graphAnalysis?.clusters && graphAnalysis.clusters.length > 0) {
                graphAnalysis.clusters.forEach((cluster, index) => {
                    if (cluster.length > 2) {
                        const clusterName = cluster[0]?.name || 'Ê¶ÇÂøµÈõÜÁæ§';
                        const clusterSize = cluster.length;
                        
                        // Ê†πÊçÆÈõÜÁæ§Â§ßÂ∞èÁîüÊàêÊõ¥ÊúâÊÑè‰πâÁöÑÊèèËø∞
                        let description, insight;
                        
                        if (clusterSize >= 10) {
                            description = `ËøôÊòØ‰∏Ä‰∏™ÂåÖÂê´ ${clusterSize} ‰∏™Ê¶ÇÂøµÁöÑÂ§ßÂûã‰∏ªÈ¢òÈõÜÁæ§ÔºåË°®ÊòéËØ•È¢ÜÂüüÂú®ÊÇ®ÁöÑÊñáÊ°£‰∏≠Êúâ‰∏∞ÂØåÁöÑÂÜÖÂÆπË¶ÜÁõñ„ÄÇ`;
                            insight = `üí° Âª∫ËÆÆÔºöËøô‰∏™‰∏ªÈ¢òÈõÜÁæ§ÂèØ‰ª•‰Ωú‰∏∫ÊÇ®ÂÜÖÂÆπÁ≠ñÁï•ÁöÑÊ†∏ÂøÉÊîØÊü±ÔºåÂÄºÂæóÊ∑±ÂÖ•ÊåñÊéòÂíåÁ≥ªÁªüÂåñÊï¥ÁêÜ„ÄÇÂèØ‰ª•ËÄÉËôëÂà∂‰Ωú‰∏ìÈ¢òÁ≥ªÂàóÂÜÖÂÆπ„ÄÇ`;
                        } else if (clusterSize >= 5) {
                            description = `ÂèëÁé∞‰∫Ü‰∏Ä‰∏™‰∏≠Á≠âËßÑÊ®°ÁöÑÊ¶ÇÂøµÈõÜÁæ§ÔºåÂåÖÂê´ ${clusterSize} ‰∏™Áõ∏ÂÖ≥Ê¶ÇÂøµÔºåÊòæÁ§∫Âá∫ËâØÂ•ΩÁöÑ‰∏ªÈ¢òËøûË¥ØÊÄß„ÄÇ`;
                            insight = `üí° Âª∫ËÆÆÔºöËøô‰∏™‰∏ªÈ¢òÊúâË∂≥Â§üÁöÑÂÜÖÂÆπÊ∑±Â∫¶ÔºåÂèØ‰ª•ËÄÉËôëÂàõÂª∫‰∏ìÈó®ÁöÑÂÜÖÂÆπÂàÜÁ±ªÊàñÊ†áÁ≠æÔºå‰æø‰∫éËØªËÄÖÁ≥ªÁªüÊÄßÂ≠¶‰π†„ÄÇ`;
                        } else {
                            description = `ËØÜÂà´Âá∫‰∏Ä‰∏™Á¥ßÂØÜÁöÑÂ∞èÂûãÊ¶ÇÂøµÈõÜÁæ§ÔºåÂåÖÂê´ ${clusterSize} ‰∏™È´òÂ∫¶Áõ∏ÂÖ≥ÁöÑÊ¶ÇÂøµ„ÄÇ`;
                            insight = `üí° Âª∫ËÆÆÔºöËøô‰∫õÊ¶ÇÂøµËÅîÁ≥ªÁ¥ßÂØÜÔºåÂèØ‰ª•Âú®ÂçïÁØáÊñáÁ´†‰∏≠ÁªºÂêàËÆ®ËÆ∫ÔºåÊàñ‰Ωú‰∏∫ÂÖ∂‰ªñÂÜÖÂÆπÁöÑË°•ÂÖÖËØ¥Êòé„ÄÇ`;
                        }
                        
                        patterns.push({
                            pattern: `${clusterName.includes('ÈõÜÁæ§') ? clusterName : clusterName + '‰∏ªÈ¢òÈõÜÁæ§'}`,
                            description: description,
                            strength: Math.min(0.95, 0.6 + clusterSize * 0.05),
                            documents: cluster.slice(0, 3).map(node => node.name || 'Áõ∏ÂÖ≥ÊñáÊ°£'),
                            insight: insight
                        });
                    }
                });
            }
            
            // Â¶ÇÊûúÊ≤°ÊúâÊâæÂà∞ËÅöÁ±ªÔºåÁîüÊàêÂü∫‰∫éËøûÊé•Â∫¶ÁöÑÊ®°Âºè
            if (patterns.length === 0 && graphData?.nodes) {
                const highDegreeNodes = graphData.nodes
                    .map(node => ({
                        ...node,
                        degree: graphData.links.filter(link => 
                            link.source === node.id || link.target === node.id
                        ).length
                    }))
                    .filter(node => node.degree > 2)
                    .sort((a, b) => b.degree - a.degree);

                if (highDegreeNodes.length > 0) {
                    patterns.push({
                        pattern: 'Ê†∏ÂøÉÊ¶ÇÂøµÊû¢Á∫ΩÊïàÂ∫î',
                        description: `ÂèëÁé∞ "${highDegreeNodes[0].name}" ‰Ωú‰∏∫Ê†∏ÂøÉÊ¶ÇÂøµÔºåËøûÊé•‰∫Ü ${highDegreeNodes[0].degree} ‰∏™Áõ∏ÂÖ≥ÂÆû‰Ωì„ÄÇ`,
                        strength: Math.min(0.9, 0.5 + highDegreeNodes[0].degree * 0.1),
                        documents: ['Ë∑®ÊñáÊ°£ÂàÜÊûê'],
                        insight: 'Ê†∏ÂøÉÊ¶ÇÂøµÂèØ‰Ωú‰∏∫ÂÜÖÂÆπÊû∂ÊûÑÁöÑ‰∏≠ÂøÉËäÇÁÇπÔºåÊåáÂØºÁõ∏ÂÖ≥ÂÜÖÂÆπÁöÑÁªÑÁªáÂíåÊâ©Â±ï„ÄÇ'
                    });
                }
            }
            
            return patterns.length > 0 ? patterns : [
                {
                    pattern: 'Âü∫Á°ÄÊñáÊ°£ÂÖ≥ËÅî',
                    description: 'ÈÄöËøáGraphRAGÂàÜÊûêÂèëÁé∞‰∫ÜÊñáÊ°£Èó¥ÁöÑÂü∫Á°ÄËØ≠‰πâÂÖ≥ËÅî„ÄÇ',
                    strength: 0.6,
                    documents: ['ÂàÜÊûêÊñáÊ°£'],
                    insight: 'Âª∫ËÆÆÂ¢ûÂä†Êõ¥Â§öÁõ∏ÂÖ≥ÊñáÊ°£‰ª•ÂèëÁé∞Êõ¥Ê∑±Â±ÇÁöÑÂÖ≥Á≥ªÊ®°Âºè„ÄÇ'
                }
            ];
        }

        // ËæÖÂä©ÂáΩÊï∞ÔºöÊèêÂèñË∑®ÊñáÊ°£ÂÖ≥Á≥ª
        function extractCrossDocumentRelations(graphData) {
            if (!graphData || !graphData.links) return [];
            
            return graphData.links.slice(0, 5).map(link => {
                const sourceNode = graphData.nodes?.find(n => n.id === link.source);
                const targetNode = graphData.nodes?.find(n => n.id === link.target);
                
                return {
                    source: sourceNode?.name || 'Unknown Entity',
                    target: targetNode?.name || 'Unknown Entity',
                    relation: link.type || 'related_to',
                    strength: link.weight || 0.5,
                    description: `ÈÄöËøáGraphRAGÂàÜÊûêÂèëÁé∞ÁöÑ${link.type || 'ÂÖ≥ËÅî'}ÂÖ≥Á≥ª`
                };
            });
        }

        // ËæÖÂä©ÂáΩÊï∞ÔºöÁîüÊàêÊú∫‰ºöÁÇπÔºàÂ¢ûÂº∫GraphRAGÂäüËÉΩÔºâ
        function generateOpportunities(graphAnalysis) {
            const opportunities = [];
            
            // 1. Âü∫‰∫éËØ≠‰πâÁ§æÂå∫ÁöÑÊú∫‰ºö
            if (graphAnalysis?.communities && graphAnalysis.communities.length > 0) {
                const topCommunity = graphAnalysis.communities[0];
                opportunities.push({
                    opportunity: `ËØ≠‰πâÁ§æÂå∫Ê∑±Âåñ: ${topCommunity.theme}`,
                    description: `ÊúÄÈ´òË¥®ÈáèÁöÑËØ≠‰πâÁ§æÂå∫Ôºà‰∏ÄËá¥ÊÄß: ${(topCommunity.semanticScore * 100).toFixed(1)}%ÔºâÂèØ‰Ωú‰∏∫ÂÜÖÂÆπÁ≠ñÁï•ÁöÑÈáçÁÇπÁ™ÅÁ†¥Âè£„ÄÇËØ•Á§æÂå∫Âõ¥Áªï"${topCommunity.centralNode?.name}"ÊûÑÂª∫ÔºåÂÖ∑Êúâ${topCommunity.size}‰∏™Áõ∏ÂÖ≥ÂÆû‰Ωì„ÄÇ`,
                    impact: 'high',
                    confidence: topCommunity.semanticScore,
                    actionable: `‰ª•"${topCommunity.centralNode?.name}"‰∏∫Ê†∏ÂøÉÔºåÂàõÂª∫${topCommunity.theme}‰∏ìÈ¢òÂÜÖÂÆπÁ≥ªÂàóÔºåÂÖÖÂàÜÊåñÊéòËØ•È¢ÜÂüüÁöÑÂÜÖÂÆπ‰ª∑ÂÄº`
                });
            }
            
            // 2. Âü∫‰∫éÁü•ËØÜÁº∫Âè£ÁöÑÊú∫‰ºö
            if (graphAnalysis?.knowledgeGaps && graphAnalysis.knowledgeGaps.length > 0) {
                const highPriorityGaps = graphAnalysis.knowledgeGaps.filter(gap => gap.priority === 'high');
                if (highPriorityGaps.length > 0) {
                    const topGap = highPriorityGaps[0];
                    opportunities.push({
                        opportunity: `Áü•ËØÜÁº∫Âè£Â°´Ë°•: ${topGap.concept || topGap.concept1}`,
                        description: `GraphRAGÂàÜÊûêÂèëÁé∞È´ò‰ºòÂÖàÁ∫ßÁü•ËØÜÁº∫Âè£Ôºö${topGap.description}„ÄÇËøôÁßçÁº∫Âè£ÂæÄÂæÄÊòØÂÜÖÂÆπÂàõ‰ΩúÁöÑÈªÑÈáëÊú∫‰ºö„ÄÇ`,
                        impact: 'high',
                        confidence: 0.9,
                        actionable: topGap.suggestion
                    });
                }
            }
            
            // 3. Âü∫‰∫éÊ¶ÇÂøµË∑ØÂæÑÁöÑÊú∫‰ºö
            if (graphAnalysis?.pathAnalysis && graphAnalysis.pathAnalysis.length > 0) {
                const bestPath = graphAnalysis.pathAnalysis[0];
                opportunities.push({
                    opportunity: `Ê¶ÇÂøµÊé®ÁêÜÈìæÂà©Áî®: ${bestPath.start} ‚áí ${bestPath.end}`,
                    description: `ÂèëÁé∞‰∫ÜÈ´òÁΩÆ‰ø°Â∫¶Ôºà${(bestPath.confidence * 100).toFixed(1)}%ÔºâÁöÑÊ¶ÇÂøµÊé®ÁêÜË∑ØÂæÑ„ÄÇËøôÁßçÈÄªËæëËøûÊé•ÂèØ‰ª•Áî®‰∫éÂàõÂª∫Êõ¥ÂÖ∑ËØ¥ÊúçÂäõÁöÑÂÜÖÂÆπÊ°ÜÊû∂„ÄÇ`,
                    impact: 'medium',
                    confidence: bestPath.confidence,
                    actionable: `Âü∫‰∫éÊ≠§Êé®ÁêÜË∑ØÂæÑÂàõÂª∫ÈÄªËæëÊÄßÂÜÖÂÆπÔºåÂºïÂØºËØªËÄÖ‰ªé"${bestPath.start}"ÁêÜËß£Âà∞"${bestPath.end}"`
                });
            }
            
            // 4. Âü∫‰∫é‰∏≠ÂøÉÊÄßÂàÜÊûêÁöÑÊú∫‰ºöÔºà‰º†ÁªüÂäüËÉΩÔºâ
            if (graphAnalysis?.centrality?.topNodes) {
                const topNode = graphAnalysis.centrality.topNodes[0];
                if (topNode) {
                    opportunities.push({
                        opportunity: `Ê†∏ÂøÉÊ¶ÇÂøµÈ©±Âä®: ${topNode[1].name}`,
                        description: `"${topNode[1].name}"Âú®ÊÇ®ÁöÑÁü•ËØÜÁΩëÁªú‰∏≠ÂÖ∑ÊúâÊúÄÈ´òÁöÑ‰∏≠ÂøÉÊÄßÔºàÂ∫¶Êï∞: ${topNode[1].degree}ÔºâÔºåÂèØ‰Ωú‰∏∫ÂÜÖÂÆπÊâ©Â±ïÁöÑÊ†∏ÂøÉÊîØÁÇπ„ÄÇ`,
                        impact: 'high',
                        confidence: 0.8,
                        actionable: `Âõ¥Áªï"${topNode[1].name}"ÊûÑÂª∫ÂÜÖÂÆπÁü©ÈòµÔºåÂΩ¢Êàê‰∏ªÈ¢òËÅöÁ±ªÊïàÂ∫î`
                    });
                }
            }
            
            // 5. Âü∫‰∫éÁΩëÁªúÂØÜÂ∫¶ÁöÑÊú∫‰ºö
            if (graphAnalysis?.insights) {
                const sparseInsight = graphAnalysis.insights.find(i => i.type === 'sparse_connections');
                if (sparseInsight) {
                    opportunities.push({
                        opportunity: 'Áü•ËØÜÁΩëÁªúÂØÜÂåñ',
                        description: sparseInsight.description + '„ÄÇËøôÊÑèÂë≥ÁùÄÂ≠òÂú®Â§ßÈáèÁöÑËøûÊé•Êú∫‰ºö„ÄÇ',
                        impact: 'medium',
                        confidence: 0.7,
                        actionable: sparseInsight.actionable
                    });
                }
            }
            
            return opportunities.length > 0 ? opportunities : [
                {
                    opportunity: 'Âü∫Á°ÄGraphRAGÂàÜÊûê',
                    description: 'ÂΩìÂâçÂàÜÊûê‰∏∫Âü∫Á°ÄÁªìÊûúÔºåÂèØÈÄöËøáÂ¢ûÂä†Êõ¥Â§öÁõ∏ÂÖ≥ÊñáÊ°£Êù•ÊøÄÊ¥ªÊõ¥Â§öÈ´òÁ∫ßGraphRAGÂäüËÉΩ',
                    impact: 'medium',
                    confidence: 0.6,
                    actionable: 'Êî∂ÈõÜÊõ¥Â§öÁõ∏ÂÖ≥ÊñáÊ°£Ôºå‰ΩøÁ≥ªÁªüËÉΩÂ§üËØÜÂà´Êõ¥Â§çÊùÇÁöÑËØ≠‰πâÁ§æÂå∫„ÄÅÊé®ÁêÜË∑ØÂæÑÂíåÁü•ËØÜÁº∫Âè£'
                }
            ];
        }

        // ËæÖÂä©ÂáΩÊï∞ÔºöËÆ°ÁÆóÁΩëÁªúÂØÜÂ∫¶
        function calculateNetworkDensity(graphData) {
            if (!graphData || !graphData.nodes || !graphData.links) return 0;
            
            const nodeCount = graphData.nodes.length;
            const linkCount = graphData.links.length;
            const maxPossibleLinks = nodeCount * (nodeCount - 1) / 2;
            
            return maxPossibleLinks > 0 ? linkCount / maxPossibleLinks : 0;
        }

        // ËæÖÂä©ÂáΩÊï∞ÔºöÊèêÂèñ‰∏≠ÂøÉËäÇÁÇπ
        function extractCentralNodes(graphAnalysis) {
            if (graphAnalysis?.centrality?.topNodes) {
                return graphAnalysis.centrality.topNodes
                    .slice(0, 5)
                    .map(([nodeId, nodeData]) => nodeData.name);
            }
            return [];
        }

        // ËæÖÂä©ÂáΩÊï∞ÔºöÁîüÊàêÂèØÊìç‰ΩúÁöÑÊé®ËçêÂª∫ËÆÆ
        function generateRecommendations(graphAnalysis, insightCard) {
            const recommendations = [];
            
            // Âü∫‰∫éÂõæË∞±Ê†∏ÂøÉËäÇÁÇπÁöÑÂª∫ËÆÆ
            if (graphAnalysis?.centrality?.topNodes?.length > 0) {
                const topNode = graphAnalysis.centrality.topNodes[0][1];
                const nodeName = topNode.name;
                const degree = topNode.degree || 0;
                
                recommendations.push(
                    `üéØ Ê∑±ÂåñÊ†∏ÂøÉ‰∏ªÈ¢òÔºö${nodeName}ÊòØÊÇ®ÂÜÖÂÆπ‰ΩìÁ≥ªÁöÑÂÖ≥ÈîÆÊû¢Á∫ΩÔºå‰∏é${degree}‰∏™Ê¶ÇÂøµÁõ∏ÂÖ≥ËÅî„ÄÇÂª∫ËÆÆÂõ¥ÁªïÊ≠§‰∏ªÈ¢òÂàõÂª∫Á≥ªÂàóÂÜÖÂÆπÊàñ‰∏ìÈ¢ò`
                );
            }
            
            // Âü∫‰∫éÈõÜÁæ§ÂàÜÊûêÁöÑÂª∫ËÆÆ
            if (graphAnalysis?.clusters?.length > 0) {
                const clusterCount = graphAnalysis.clusters.length;
                const avgClusterSize = Math.round(
                    graphAnalysis.clusters.reduce((sum, cluster) => sum + cluster.length, 0) / clusterCount
                );
                
                if (clusterCount >= 3) {
                    recommendations.push(
                        `üìö ÂÜÖÂÆπÂàÜÁ±ª‰ºòÂåñÔºöÂèëÁé∞${clusterCount}‰∏™‰∏ªÈ¢òÈõÜÁæ§ÔºåÊØè‰∏™ÈõÜÁæ§Âπ≥ÂùáÂåÖÂê´${avgClusterSize}‰∏™Ê¶ÇÂøµ„ÄÇÂª∫ËÆÆ‰∏∫ÊØè‰∏™ÈõÜÁæ§ÂàõÂª∫‰∏ìÈó®ÁöÑÂÜÖÂÆπÂàÜÁ±ª`
                    );
                } else {
                    recommendations.push(
                        `üîó ‰∏ªÈ¢òÂÖ≥ËÅîÂä†Âº∫ÔºöÁõÆÂâçÂè™Êúâ${clusterCount}‰∏™‰∏ªÈ¢òÈõÜÁæ§ÔºåÂª∫ËÆÆÂ¢ûÂä†‰∏çÂêå‰∏ªÈ¢òÈó¥ÁöÑÂÖ≥ËÅîÂÜÖÂÆπÔºåÊèêÈ´òÂÜÖÂÆπ‰ΩìÁ≥ªÁöÑËøûË¥ØÊÄß`
                    );
                }
            }
            
            // Âü∫‰∫éÁΩëÁªúÂØÜÂ∫¶ÁöÑÂª∫ËÆÆ
            const networkStats = calculateNetworkDensity({ 
                nodes: graphAnalysis?.nodes || [], 
                links: graphAnalysis?.links || [] 
            });
            
            if (networkStats && !isNaN(networkStats) && networkStats > 0.6) {
                recommendations.push(
                    `üíé ÂÜÖÂÆπ‰ΩìÁ≥ªÊàêÁÜüÔºöÊÇ®ÁöÑÁü•ËØÜÁΩëÁªúÂØÜÂ∫¶ÂæàÈ´ò(${Math.round(networkStats * 100)}%)ÔºåÈÄÇÂêàÂºÄÂèëÈ´òÁ∫ßÂÜÖÂÆπÂ¶ÇÊ°à‰æãÁ†îÁ©∂„ÄÅÊ∑±Â∫¶ÂàÜÊûêÁ≠â`
                );
            } else if (networkStats && !isNaN(networkStats) && networkStats < 0.3) {
                recommendations.push(
                    `üå± Â°´Ë°•Áü•ËØÜÁ©∫ÁôΩÔºöÁΩëÁªúÂØÜÂ∫¶ËæÉ‰Ωé(${Math.round(networkStats * 100)}%)ÔºåÂª∫ËÆÆËØÜÂà´Áº∫Â§±ÁöÑËøûÊé•ÁÇπÔºåÂàõÂª∫Ê°•Êé•ÂÜÖÂÆπ`
                );
            }
            
            // Âü∫‰∫éAIÊ¥ûÂØüÂç°ÁâáÁöÑÂª∫ËÆÆ
            if (insightCard?.viralPrediction) {
                const { targetAudience, bestChannel, viralScore } = insightCard.viralPrediction;
                
                if (targetAudience) {
                    recommendations.push(
                        `üë• Á≤æÂáÜÂÆö‰ΩçÂèó‰ºóÔºöÂÜÖÂÆπÊúÄÈÄÇÂêà${targetAudience}Áæ§‰ΩìÔºåÂª∫ËÆÆÊ∑±ÂÖ•Á†îÁ©∂ËØ•Áæ§‰ΩìÁöÑÂÖ∑‰ΩìÈúÄÊ±ÇÂíåÁóõÁÇπ`
                    );
                }
                
                if (bestChannel) {
                    recommendations.push(
                        `üì± ‰ºòÂåñÂèëÂ∏ÉÁ≠ñÁï•Ôºö${bestChannel}ÊòØÊúÄ‰Ω≥ÂèëÂ∏ÉÊ∏†ÈÅìÔºåÂª∫ËÆÆÊ†πÊçÆÂπ≥Âè∞ÁâπÁÇπË∞ÉÊï¥ÂÜÖÂÆπÊ†ºÂºèÂíåÂèëÂ∏ÉÊó∂Êú∫`
                    );
                }
                
                if (viralScore && !isNaN(viralScore) && viralScore >= 7) {
                    recommendations.push(
                        `üöÄ ‰º†Êí≠ÊΩúÂäõËæÉÈ´òÔºöÂÜÖÂÆπ‰º†Êí≠ËØÑÂàÜ${viralScore}/10ÔºåÂª∫ËÆÆÊäïÂÖ•Êõ¥Â§öÊé®ÂπøËµÑÊ∫êÔºåÂà∂‰ΩúÈÖçÂ•óÁöÑ‰º†Êí≠Á¥†Êùê`
                    );
                } else if (viralScore && !isNaN(viralScore) && viralScore < 5) {
                    recommendations.push(
                        `‚ö° ÊèêÂçá‰º†Êí≠ÂäõÔºö‰º†Êí≠ËØÑÂàÜ${viralScore}/10ÔºåÂª∫ËÆÆ‰ºòÂåñÊ†áÈ¢òÂê∏ÂºïÂäõ„ÄÅÂ¢ûÂä†ËßÜËßâÂÖÉÁ¥†„ÄÅÂº∫ÂåñÊÉÖÊÑüÂÖ±È∏£ÁÇπ`
                    );
                }
            }
            
            // Âü∫‰∫éÂÜÖÂÆπ‰ºòÂåñÂª∫ËÆÆ
            if (insightCard?.optimizationSuggestions?.length > 0) {
                const topSuggestion = insightCard.optimizationSuggestions[0];
                recommendations.push(`üí° ÂÜÖÂÆπ‰ºòÂåñÈáçÁÇπÔºö${topSuggestion}`);
            }
            
            // Á°Æ‰øùËá≥Â∞ëÊúâÂü∫Á°ÄÂª∫ËÆÆ
            if (recommendations.length < 3) {
                recommendations.push(
                    'üìà ÊåÅÁª≠Êâ©Â±ïÔºöÂÆöÊúüÊ∑ªÂä†Êñ∞ÊñáÊ°£Âà∞Áü•ËØÜÂ∫ìÔºåËÆ©GraphRAGÂàÜÊûêÁªìÊûúÊõ¥Âä†ÂáÜÁ°ÆÂíåÂÖ®Èù¢',
                    'üîç Ê∑±Â∫¶ÊåñÊéòÔºöÂÖ≥Ê≥®ÂõæË∞±‰∏≠ËøûÊé•ËæÉÂ∞ëÁöÑËäÇÁÇπÔºåËøô‰∫õÂæÄÂæÄÊòØÊñ∞ÂÜÖÂÆπÂàõ‰ΩúÁöÑÊú∫‰ºöÁÇπ',
                    'üéØ Á≠ñÁï•Ëø≠‰ª£ÔºöÂü∫‰∫éÂàÜÊûêÁªìÊûúË∞ÉÊï¥ÂÜÖÂÆπÁ≠ñÁï•ÔºåÊØèÊúàÈáçÊñ∞ËøêË°åÂàÜÊûêËøΩË∏™ÊîπËøõÊïàÊûú'
                );
            }
            
            return recommendations.slice(0, 5); // ÈôêÂà∂‰∏∫ÊúÄÂ§ö5‰∏™Âª∫ËÆÆ
        }

        // ËæÖÂä©ÂáΩÊï∞ÔºöÂÆâÂÖ®Ê†ºÂºèÂåñÁôæÂàÜÊØîÔºåÈò≤Ê≠¢NaNÊòæÁ§∫
        function safePercent(value, defaultValue = 0) {
            const num = Number(value);
            return isNaN(num) ? defaultValue : Math.round(num * 100);
        }

        // ËæÖÂä©ÂáΩÊï∞ÔºöËé∑ÂèñÊñáÊ°£ÂÜÖÂÆπ
        async function fetchDocumentContent(docTitle) {
            // ËøôÈáåÂèØ‰ª•Ê∑ªÂä†‰ªéÊúçÂä°Âô®Ëé∑ÂèñÊñáÊ°£ÂÜÖÂÆπÁöÑÈÄªËæë
            // ÁõÆÂâçËøîÂõûÁ§∫‰æãÂÜÖÂÆπ
            return `${docTitle} ÁöÑÁ§∫‰æãÂÜÖÂÆπÁî®‰∫éGraphRAGÂàÜÊûê...`;
        }

        // Show cross-document analysis results
        function showCrossDocumentResults(results) {
            console.log('showCrossDocumentResults called with:', results);
            console.log('Creating results panel...');
            
            // Close knowledge panel and return to main page
            const knowledgePanel = document.getElementById('knowledgePanel');
            const overlay = document.getElementById('panelOverlay');
            if (knowledgePanel) knowledgePanel.classList.remove('open');
            if (overlay) overlay.classList.remove('show');
            
            // Add blinking animation to analysis step
            const analysisStep = document.querySelector('[data-step="analysis"]');
            if (analysisStep) {
                analysisStep.style.animation = 'pulse 1.5s ease-in-out infinite';
            }
            
            // Create comprehensive results panel
            const resultsPanel = document.createElement('div');
            resultsPanel.id = 'crossDocumentResultsPanel';
            resultsPanel.style.cssText = `
                position: fixed; top: 0; right: 0; width: 100vw; height: 100vh; 
                background: white; z-index: 5000; overflow-y: auto;
                animation: slideInFromRight 0.6s ease-out;
            `;
            
            resultsPanel.innerHTML = `
                <div style="min-height: 100vh;">
                    <!-- Compact Header -->
                    <div style="
                        background: linear-gradient(135deg, #2d1b69, #11047a); 
                        color: white; padding: 20px 30px; position: relative;
                    ">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <h1 style="margin: 0; font-size: 24px; font-weight: 700;">
                                    üîç Cross-Document Insight Analysis
                                </h1>
                                <p style="margin: 8px 0 0; opacity: 0.85; font-size: 14px;">
                                    Deep Analysis of ${results.summary.documentCount} Documents ‚Ä¢ ${results.summary.isReal ? 'Real GraphRAG' : 'Basic Analysis'}
                                </p>
                            </div>
                            <button onclick="closeCrossDocumentResults()" style="
                                background: rgba(255,255,255,0.2); color: white; border: none;
                                width: 40px; height: 40px; border-radius: 50%; cursor: pointer; font-size: 18px;
                                transition: all 0.2s ease;
                            " onmouseover="this.style.background='rgba(255,255,255,0.3)'"
                               onmouseout="this.style.background='rgba(255,255,255,0.2)'">‚úï</button>
                        </div>
                    </div>
                    
                    <!-- Content Section -->
                    <div style="padding: 50px;">
                        <!-- Analysis Status Indicator -->
                        <div style="margin-bottom: 30px;">
                            ${results.summary.isReal ? 
                                `<div style="
                                    background: linear-gradient(135deg, #10b981, #059669); 
                                    color: white; padding: 16px 24px; border-radius: 12px; 
                                    display: flex; align-items: center; gap: 12px; font-weight: 600;
                                ">
                                    <span style="font-size: 20px;">‚úÖ</span>
                                    <div>
                                        <div style="font-size: 16px;">Real GraphRAG Analysis Active</div>
                                        <div style="font-size: 13px; opacity: 0.9;">Using advanced entity extraction and relationship mapping</div>
                                    </div>
                                </div>` : 
                                `<div style="
                                    background: linear-gradient(135deg, #f59e0b, #d97706); 
                                    color: white; padding: 16px 24px; border-radius: 12px; 
                                    display: flex; align-items: center; gap: 12px; font-weight: 600;
                                ">
                                    <span style="font-size: 20px;">‚ö†Ô∏è</span>
                                    <div>
                                        <div style="font-size: 16px;">Fallback Mode - GraphRAG Service Unavailable</div>
                                        <div style="font-size: 13px; opacity: 0.9;">Using basic analysis due to API connection issues</div>
                                    </div>
                                </div>`
                            }
                        </div>

                        <!-- Executive Summary -->
                        <section style="margin-bottom: 40px;">
                            <h2 style="color: #1a202c; margin-bottom: 20px; font-size: 24px; font-weight: 700;">
                                üìä Analysis Overview
                            </h2>
                            <div style="
                                background: linear-gradient(135deg, #667eea, #764ba2); 
                                color: white; padding: 32px; border-radius: 16px; margin-bottom: 24px;
                            ">
                                <p style="margin: 0; font-size: 18px; line-height: 1.6;">
                                    ${results.summary.overview}
                                </p>
                            </div>
                            
                            <!-- Key Connections -->
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 16px;">
                                ${results.summary.keyConnections.map(connection => `
                                    <div style="
                                        background: #f8fafc; border-left: 5px solid #667eea; 
                                        padding: 20px; border-radius: 0 12px 12px 0;
                                    ">
                                        <div style="color: #2d3748; font-size: 15px; line-height: 1.5;">
                                            üîó ${connection}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </section>

                        <!-- Network Stats -->
                        <section style="margin-bottom: 40px;">
                            <h2 style="color: #1a202c; margin-bottom: 20px; font-size: 24px; font-weight: 700;">
                                üï∏Ô∏è Network Analysis
                            </h2>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                                <div style="background: #667eea; color: white; padding: 24px; border-radius: 12px; text-align: center;">
                                    <div style="font-size: 32px; font-weight: bold; margin-bottom: 8px;">${results.networkAnalysis.totalNodes}</div>
                                    <div style="font-size: 14px; opacity: 0.9;">Entity Nodes</div>
                                </div>
                                <div style="background: #764ba2; color: white; padding: 24px; border-radius: 12px; text-align: center;">
                                    <div style="font-size: 32px; font-weight: bold; margin-bottom: 8px;">${results.networkAnalysis.totalEdges}</div>
                                    <div style="font-size: 14px; opacity: 0.9;">Relationships</div>
                                </div>
                                <div style="background: #f093fb; color: white; padding: 24px; border-radius: 12px; text-align: center;">
                                    <div style="font-size: 32px; font-weight: bold; margin-bottom: 8px;">${results.networkAnalysis.communityCount}</div>
                                    <div style="font-size: 14px; opacity: 0.9;">Communities</div>
                                </div>
                                <div style="background: #4facfe; color: white; padding: 24px; border-radius: 12px; text-align: center;">
                                    <div style="font-size: 32px; font-weight: bold; margin-bottom: 8px;">${Math.round((results.networkAnalysis.networkDensity || 0) * 100)}%</div>
                                    <div style="font-size: 14px; opacity: 0.9;">Network Density</div>
                                </div>
                            </div>
                        </section>

                        <!-- Knowledge Graph Visualization -->
                        <section style="margin-bottom: 40px;">
                            <h2 style="color: #1a202c; margin-bottom: 20px; font-size: 24px; font-weight: 700;">
                                üß† Interactive Knowledge Graph
                            </h2>
                            <div style="
                                background: #f8fafc; border: 2px solid #e2e8f0; 
                                border-radius: 16px; padding: 24px; min-height: 500px; position: relative;
                            ">
                                <div id="knowledgeGraphContainer" style="width: 100%; height: 450px; position: relative;">
                                    <!-- D3.js Knowledge Graph will be rendered here -->
                                </div>
                                <div style="
                                    position: absolute; bottom: 16px; right: 16px; 
                                    background: rgba(255,255,255,0.9); padding: 12px; border-radius: 8px;
                                    font-size: 12px; color: #6b7280; display: flex; align-items: center; gap: 16px;
                                ">
                                    <div><span style="display: inline-block; width: 12px; height: 12px; background: #667eea; border-radius: 50%; margin-right: 6px;"></span>Documents</div>
                                    <div><span style="display: inline-block; width: 12px; height: 12px; background: #f093fb; border-radius: 50%; margin-right: 6px;"></span>Concepts</div>
                                    <div><span style="display: inline-block; width: 12px; height: 12px; background: #4facfe; border-radius: 50%; margin-right: 6px;"></span>Relationships</div>
                                </div>
                            </div>
                        </section>

                        <!-- Hidden Patterns Discovery -->
                        <section style="margin-bottom: 40px;">
                            <h2 style="color: #1a202c; margin-bottom: 20px; font-size: 24px; font-weight: 700;">
                                üîÆ Hidden Patterns Discovery
                            </h2>
                            ${results.hiddenPatterns.map(pattern => `
                                <div style="
                                    background: white; border: 2px solid #e2e8f0; 
                                    padding: 28px; border-radius: 16px; margin-bottom: 20px;
                                    box-shadow: 0 4px 12px rgba(0,0,0,0.05);
                                ">
                                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 16px;">
                                        <h3 style="margin: 0; color: #2d3748; font-size: 18px; font-weight: 600;">
                                            üß© ${pattern.pattern}
                                        </h3>
                                        <span style="
                                            background: #667eea; color: white; padding: 6px 16px; 
                                            border-radius: 20px; font-size: 12px; font-weight: 600; margin-left: auto;
                                        ">
                                            Strength: ${Math.round((pattern.strength || 0) * 100)}%
                                        </span>
                                    </div>
                                    <p style="color: #4a5568; line-height: 1.7; margin-bottom: 16px; font-size: 15px;">
                                        ${pattern.description}
                                    </p>
                                    <div style="
                                        background: #e8f4fd; border-left: 4px solid #3b82f6; 
                                        padding: 16px 20px; border-radius: 0 8px 8px 0; margin-bottom: 12px;
                                    ">
                                        <strong style="color: #1d4ed8;">üí° Key Insight:</strong>
                                        <span style="color: #1e40af; margin-left: 8px;">
                                            ${pattern.insight}
                                        </span>
                                    </div>
                                    <div style="font-size: 13px; color: #6b7280;">
                                        <strong>Confidence:</strong> ${pattern.confidence && !isNaN(pattern.confidence) ? (pattern.confidence * 100).toFixed(1) + '%' : 'N/A'}
                                        ${pattern.actionable ? ` | <strong>Action:</strong> ${pattern.actionable}` : ''}
                                    </div>
                                </div>
                            `).join('')}
                        </section>

                        <!-- Strategic Recommendations -->
                        <section style="margin-bottom: 40px;">
                            <h2 style="color: #1a202c; margin-bottom: 20px; font-size: 24px; font-weight: 700;">
                                üéØ Strategic Recommendations
                            </h2>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 20px;">
                                ${results.recommendations.map((rec, index) => `
                                    <div style="
                                        background: linear-gradient(135deg, #667eea, #764ba2); 
                                        color: white; padding: 24px; border-radius: 16px;
                                        position: relative; overflow: hidden;
                                    ">
                                        <div style="
                                            position: absolute; top: 16px; right: 16px;
                                            width: 32px; height: 32px; background: rgba(255,255,255,0.2);
                                            border-radius: 50%; display: flex; align-items: center; 
                                            justify-content: center; font-weight: bold; font-size: 14px;
                                        ">
                                            ${index + 1}
                                        </div>
                                        <div style="font-size: 16px; line-height: 1.6; padding-right: 40px;">
                                            ${rec}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </section>
                    </div>
                    
                    <!-- Action Buttons -->
                    <section style="text-align: center; padding: 40px;">
                        <button onclick="proceedToResearch()" style="
                            background: linear-gradient(135deg, #2d1b69, #11047a); 
                            color: white; border: none; padding: 16px 32px; 
                            border-radius: 12px; font-size: 16px; font-weight: 700; 
                            cursor: pointer; margin-right: 16px; 
                            box-shadow: 0 8px 25px rgba(45, 27, 105, 0.3);
                        ">
                            üöÄ Proceed to Research Phase
                        </button>
                        <button onclick="saveInsightResults()" style="
                            background: white; color: #2d1b69; border: 2px solid #2d1b69; 
                            padding: 16px 32px; border-radius: 12px; font-size: 16px; 
                            font-weight: 700; cursor: pointer; margin-right: 16px;
                        ">
                            üíæ Save Results
                        </button>
                        <button onclick="exportDetailedReport()" style="
                            background: #f59e0b; color: white; border: none; 
                            padding: 16px 32px; border-radius: 12px; font-size: 16px; 
                            font-weight: 700; cursor: pointer;
                        ">
                            üìä Export Report
                        </button>
                    </section>
                </div>
            `;
            
            console.log('Appending results panel to body...');
            document.body.appendChild(resultsPanel);
            console.log('Results panel appended successfully!');
            
            // Initialize knowledge graph after panel is added
            setTimeout(() => {
                console.log('Attempting to render knowledge graph...');
                renderKnowledgeGraph(results);
            }, 500);
        }

        // Render knowledge graph using D3.js
        function renderKnowledgeGraph(results) {
            console.log('renderKnowledgeGraph called with results:', results);
            
            // Check if D3.js is loaded
            if (typeof d3 === 'undefined') {
                console.error('D3.js is not loaded! Adding fallback...');
                // Create a simple fallback visualization
                renderFallbackGraph(results);
                return;
            }
            
            const container = document.getElementById('knowledgeGraphContainer');
            console.log('Container found:', container);
            if (!container) {
                console.error('knowledgeGraphContainer not found!');
                return;
            }

            // Clear previous content
            d3.select('#knowledgeGraphContainer').selectAll('*').remove();
            console.log('Cleared previous content');

            const width = container.offsetWidth;
            const height = container.offsetHeight;

            // Create SVG
            const svg = d3.select('#knowledgeGraphContainer')
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            // Generate graph data based on analysis results
            const graphData = generateGraphData(results);

            // Create force simulation
            const simulation = d3.forceSimulation(graphData.nodes)
                .force('link', d3.forceLink(graphData.links).id(d => d.id).distance(80))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(25));

            // Create links
            const link = svg.append('g')
                .attr('stroke', '#999')
                .attr('stroke-opacity', 0.6)
                .selectAll('line')
                .data(graphData.links)
                .enter().append('line')
                .attr('stroke-width', d => Math.sqrt(d.value) * 2);

            // Create nodes
            const node = svg.append('g')
                .attr('stroke', '#fff')
                .attr('stroke-width', 1.5)
                .selectAll('circle')
                .data(graphData.nodes)
                .enter().append('circle')
                .attr('r', d => d.type === 'document' ? 12 : 8)
                .attr('fill', d => {
                    if (d.type === 'document') return '#667eea';
                    if (d.type === 'concept') return '#f093fb';
                    return '#4facfe';
                })
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            // Add labels
            const label = svg.append('g')
                .selectAll('text')
                .data(graphData.nodes)
                .enter().append('text')
                .attr('text-anchor', 'middle')
                .attr('dy', '.35em')
                .attr('font-size', '10px')
                .attr('fill', '#333')
                .text(d => {
                    const displayText = d.name || d.id;
                    return displayText.length > 12 ? displayText.substring(0, 12) + '...' : displayText;
                });

            // Update positions on tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y - 18);
            });

            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }

            // Add zoom behavior
            svg.call(d3.zoom()
                .extent([[0, 0], [width, height]])
                .scaleExtent([0.3, 3])
                .on('zoom', (event) => {
                    svg.selectAll('g').attr('transform', event.transform);
                }));
        }

        // Generate graph data from analysis results
        function generateGraphData(results) {
            console.log('üîç generateGraphData called with results:', results);
            
            // Â¶ÇÊûúÊúâÁúüÂÆûÁöÑGraphRAGÊï∞ÊçÆÔºåÁõ¥Êé•‰ΩøÁî®
            if (results.graphData && results.graphData.nodes && results.graphData.links) {
                console.log('‚úÖ ‰ΩøÁî®ÁúüÂÆûGraphRAGÊï∞ÊçÆÁîüÊàêÂõæË∞±');
                return {
                    nodes: results.graphData.nodes.map(node => ({
                        id: node.id,
                        name: node.name,
                        type: node.type || 'entity',
                        category: node.category || 'general',
                        group: getGroupByType(node.type || 'entity'),
                        weight: node.weight || 1
                    })),
                    links: results.graphData.links.map(link => ({
                        source: link.source,
                        target: link.target,
                        type: link.type || 'related',
                        value: link.weight || 0.5,
                        label: link.type || 'related'
                    }))
                };
            }
            
            // ÈôçÁ∫ßÂà∞Âü∫‰∫éÂàÜÊûêÁªìÊûúÁöÑÊ®°ÊãüÂõæË∞±
            console.log('üîÑ ‰ΩøÁî®Ê®°ÊãüÊï∞ÊçÆÁîüÊàêÂõæË∞±');
            const nodes = [];
            const links = [];
            
            // Add document nodes
            if (results.summary && results.summary.documents) {
                results.summary.documents.forEach((doc, index) => {
                    nodes.push({
                        id: `doc_${index}`,
                        name: doc.length > 50 ? doc.substring(0, 50) + '...' : doc,
                        type: 'document',
                        group: 1,
                        fullName: doc
                    });
                });
            }
            
            // Add entity nodes from mockEntities if available
            if (results.mockEntities) {
                results.mockEntities.forEach((entity, index) => {
                    nodes.push({
                        id: `entity_${index}`,
                        name: entity,
                        type: 'entity',
                        group: 2,
                        fullName: entity
                    });
                });
            }
            
            // Add concept nodes from hidden patterns
            if (results.hiddenPatterns) {
                results.hiddenPatterns.forEach((pattern, index) => {
                    const conceptId = `concept_${index}`;
                    nodes.push({
                        id: conceptId,
                        name: pattern.pattern,
                        type: 'concept',
                        group: 3,
                        fullName: pattern.pattern
                    });
                    
                    // Link concepts to related documents
                    if (pattern.documents) {
                        pattern.documents.forEach((doc, docIndex) => {
                            links.push({
                                source: `doc_${docIndex}`,
                                target: conceptId,
                                value: pattern.strength || 0.5,
                                type: 'contains',
                                label: 'contains'
                            });
                        });
                    }
                });
            }
            
            // Add cross-document relations
            if (results.crossDocumentRelations) {
                results.crossDocumentRelations.forEach((relation, index) => {
                    // Find or create source and target nodes
                    let sourceNode = nodes.find(n => n.name === relation.source || n.fullName === relation.source);
                    let targetNode = nodes.find(n => n.name === relation.target || n.fullName === relation.target);
                    
                    if (!sourceNode) {
                        sourceNode = {
                            id: `rel_source_${index}`,
                            name: relation.source,
                            type: 'entity',
                            group: 4,
                            fullName: relation.source
                        };
                        nodes.push(sourceNode);
                    }
                    
                    if (!targetNode) {
                        targetNode = {
                            id: `rel_target_${index}`,
                            name: relation.target,
                            type: 'entity',
                            group: 4,
                            fullName: relation.target
                        };
                        nodes.push(targetNode);
                    }
                    
                    links.push({
                        source: sourceNode.id,
                        target: targetNode.id,
                        value: relation.strength || 0.7,
                        type: relation.type || 'related',
                        label: relation.type || 'related'
                    });
                });
            }
            
            console.log(`üìä Generated graph data: ${nodes.length} nodes, ${links.length} links`);
            
            return {
                nodes: nodes,
                links: links
            };
        }

        // Ê†πÊçÆÂÆû‰ΩìÁ±ªÂûãÂàÜÈÖçÁªÑÂà´ÔºàÁî®‰∫éÈ¢úËâ≤ÂàÜÁªÑÔºâ
        function getGroupByType(type) {
            const typeGroups = {
                'document': 1,
                'concept': 2,
                'entity': 3,
                'person': 4,
                'organization': 5,
                'product': 6
            };
            return typeGroups[type] || 3;
        }

        // Fallback graph rendering if D3.js fails to load
        function renderFallbackGraph(results) {
            console.log('Rendering fallback graph...');
            const container = document.getElementById('knowledgeGraphContainer');
            if (!container) return;
            
            container.innerHTML = `
                <div style="
                    display: flex; flex-direction: column; align-items: center; 
                    justify-content: center; height: 100%; text-align: center; padding: 20px;
                ">
                    <div style="
                        display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); 
                        gap: 20px; width: 100%; max-width: 600px;
                    ">
                        ${results.summary.documents.map((doc, index) => `
                            <div style="
                                background: #667eea; color: white; padding: 12px; 
                                border-radius: 8px; font-size: 12px; text-align: center;
                                animation: bounceIn 0.5s ease ${index * 0.1}s both;
                            ">
                                üìÑ ${doc.length > 15 ? doc.substring(0, 15) + '...' : doc}
                            </div>
                        `).join('')}
                        
                        ${results.hiddenPatterns.map((pattern, index) => `
                            <div style="
                                background: #f093fb; color: white; padding: 12px; 
                                border-radius: 8px; font-size: 12px; text-align: center;
                                animation: bounceIn 0.5s ease ${(results.summary.documents.length + index) * 0.1}s both;
                            ">
                                üß© ${pattern.pattern.length > 15 ? pattern.pattern.substring(0, 15) + '...' : pattern.pattern}
                            </div>
                        `).join('')}
                    </div>
                    
                    <div style="margin-top: 20px; color: #6b7280; font-size: 14px;">
                        Knowledge Graph: ${results.networkAnalysis.totalNodes} nodes, ${results.networkAnalysis.totalEdges} relationships
                    </div>
                </div>
            `;
        }

        // Support functions for cross-document results
        window.closeCrossDocumentResults = function() {
            const panel = document.getElementById('crossDocumentResultsPanel');
            if (panel) {
                panel.style.animation = 'slideOutToRight 0.4s ease-in forwards';
                setTimeout(() => {
                    document.body.removeChild(panel);
                }, 400);
            }
            
            // Stop analysis step blinking animation
            const analysisStep = document.querySelector('[data-step="analysis"]');
            if (analysisStep) {
                analysisStep.style.animation = '';
            }
        }

        window.proceedToResearch = function() {
            updateActiveStep('research');
            closeCrossDocumentResults();
            showNotification('üîç Proceeding to Market Research Phase');
        }

        window.saveInsightResults = function() {
            // Save results to knowledge base
            const timestamp = new Date().toLocaleString();
            const resultTitle = `Cross-Document_Insight_Analysis_${selectedNodes.length}docs_${timestamp}`;
            
            showNotification('üíæ Insight analysis results saved to knowledge base');
        }

        window.exportDetailedReport = function() {
            showNotification('üìä Detailed report export feature in development...');
        }

        // Add new folder
        function addNewFolder() {
            const folderName = prompt('Enter folder name:');
            if (!folderName) return;
            
            const newFolder = createTreeNode(folderName, 'folder', true);
            const tree = document.getElementById('knowledgeTree');
            tree.appendChild(newFolder);
            
            // Ensure event handlers are properly attached
            updateEventHandlers(newFolder);
            
            showNotification(`Folder "${folderName}" added! üìÅ`);
        }

        // Add new item 
        function addNewItem() {
            const itemName = prompt('Enter item name:');
            if (!itemName) return;
            
            let parentNode = document.getElementById('knowledgeTree');
            
            // If a folder is selected, add to that folder
            if (selectedNode) {
                const selectedTreeNode = selectedNode.closest('.tree-node');
                const isFolder = selectedTreeNode.querySelector('.node-icon.folder');
                if (isFolder) {
                    let childrenContainer = selectedTreeNode.querySelector('.node-children');
                    if (!childrenContainer) {
                        childrenContainer = document.createElement('div');
                        childrenContainer.className = 'node-children expanded';
                        selectedTreeNode.appendChild(childrenContainer);
                        // Update expand icon
                        const expandIcon = selectedTreeNode.querySelector('.node-expand');
                        expandIcon.innerHTML = '‚ñº';
                        expandIcon.setAttribute('onclick', 'toggleNode(event, this)');
                    }
                    parentNode = childrenContainer;
                    childrenContainer.classList.add('expanded');
                }
            }
            
            const newItem = createTreeNode(itemName, 'file', false);
            parentNode.appendChild(newItem);
            
            // Ensure event handlers are properly attached
            updateEventHandlers(newItem);
            
            showNotification(`Item "${itemName}" added! üìÑ`);
        }

        // Create tree node element
        function createTreeNode(name, type, hasChildren) {
            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'tree-node';
            
            const isFolder = type === 'folder';
            const icon = isFolder ? 'üìÅ' : 'üìÑ';
            const iconClass = isFolder ? 'folder' : 'file';
            const expandHtml = hasChildren ? '<div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>' : '<div class="node-expand"></div>';
            
            // All nodes get selection buttons, folders also get + button
            const actionsHtml = isFolder ? 
                `<div class="node-actions">
                    <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                    <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                    <button class="node-select-btn" onclick="toggleSelection(event, this)" data-selected="false">‚úì</button>
                    <button class="node-action" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                </div>` :
                `<div class="node-actions">
                    <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                    <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                    <button class="node-select-btn" onclick="toggleSelection(event, this)" data-selected="false">‚úì</button>
                    <button class="node-action" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                </div>`;
            
            const onclickHandler = isFolder ? 'selectNode(this)' : 'showNodeContent(event, this)';
            
            nodeDiv.innerHTML = `
                <div class="node-content" onclick="${onclickHandler}" draggable="true" 
                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                    <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                    <div class="node-icon ${iconClass}">${icon}</div>
                    <div class="node-title" ondblclick="editNodeTitle(event, this)">${name}</div>
                    <div class="node-actions">
                        <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                        <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                        <button class="node-action" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                    </div>
                </div>
                <div class="node-children"></div>
            `;
            
            // Á°Æ‰øù‰∫ã‰ª∂Â§ÑÁêÜÂô®Ê≠£Á°ÆÁªëÂÆö
            updateEventHandlers(nodeDiv);
            
            return nodeDiv;
        }

        // Show node content when clicking on file nodes
        window.showNodeContent = function(event, nodeContent) {
            console.log('üéØ showNodeContent called - ÊòæÁ§∫ÂÜÖÂÆπÂà∞Âè≥‰æßÈ¢ÑËßàÂå∫');
            
            // Don't trigger if clicking on action buttons
            if (event.target.classList.contains('node-action') || 
                event.target.closest('.node-actions')) {
                console.log('Click was on action button, returning');
                return;
            }
            
            event.stopPropagation();
            const title = nodeContent.querySelector('.node-title').textContent;
            console.log('üìñ ÊòæÁ§∫Êñá‰ª∂ÂÜÖÂÆπÂà∞È¢ÑËßàÂå∫:', title);
            
            // Ëé∑ÂèñÈ¢ÑËßàÂå∫ÂüüÂÖÉÁ¥†
            const contentPreview = document.getElementById('contentPreview');
            const closePreviewBtn = document.getElementById('closePreview');
            
            if (!contentPreview) {
                console.error('Êú™ÊâæÂà∞ÂÜÖÂÆπÈ¢ÑËßàÂå∫Âüü');
                return;
            }
            
            // Ëé∑ÂèñÊñá‰ª∂ÂÜÖÂÆπ
            const nodeElement = nodeContent.closest('.tree-node');
            let displayContent = '';
            let fileAnalysis = null;
            
            // üî• ‰ºòÂÖà‰ªéDOMÂÖÉÁ¥†ÁöÑdataÂ±ûÊÄßËé∑ÂèñÂÜÖÂÆπ
            if (nodeElement && nodeElement.hasAttribute('data-file-content')) {
                displayContent = nodeElement.getAttribute('data-file-content');
                console.log('‚úÖ Found content from DOM element, length:', displayContent.length);
            }
            
            if (!displayContent) {
                // üî• ‰ªéÊñá‰ª∂Â≠òÂÇ®‰∏≠Ëé∑ÂèñtextContent
                const storageKey = nodeElement?.getAttribute('data-file-storage-key');
                if (storageKey) {
                    try {
                        const fileDataStr = localStorage.getItem(storageKey);
                        if (fileDataStr) {
                            const fileData = JSON.parse(fileDataStr);
                            if (fileData.textContent) {
                                displayContent = fileData.textContent;
                                console.log('‚úÖ Found textContent from file storage:', displayContent.length, 'Â≠óÁ¨¶');
                            }
                        }
                    } catch (error) {
                        console.log('‚ö†Ô∏è Êó†Ê≥ï‰ªéÊñá‰ª∂Â≠òÂÇ®Ëé∑ÂèñÂÜÖÂÆπ:', error);
                    }
                }
            }
            
            if (!displayContent) {
                // Â§áÁî®Ôºö‰ªélocalStorageÁü•ËØÜÂ∫ì‰∏≠Ëé∑Âèñ
                displayContent = getContentFromKnowledgeBase(title);
                console.log('üìã Content from knowledge base:', displayContent ? 'Found' : 'Not found');
            }
            
            if (!displayContent) {
                // Â§áÁî®Ôºö‰ªéÂÜÖÂ≠òÂ≠òÂÇ®‰∏≠Ëé∑Âèñ
                displayContent = nodeContentStore[title];
                console.log('üìã Content from memory store:', displayContent ? 'Found' : 'Not found');
            }
            
            // üß† Ê£ÄÊü•ÊòØÂê¶ÊúâGraphRAGÂàÜÊûêÊï∞ÊçÆ
            const analysisDB = JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}');
            console.log('üîç Êü•ÊâæGraphRAGÊï∞ÊçÆÔºåÊñá‰ª∂Âêç:', title);
            
            const sortedKeys = Object.keys(analysisDB).sort((a, b) => {
                const timestampA = a.split('_').pop() || '0';
                const timestampB = b.split('_').pop() || '0';
                return parseInt(timestampB) - parseInt(timestampA);
            });
            
            for (const key of sortedKeys) {
                if (key.startsWith(title + '_') || key === title) {
                    fileAnalysis = analysisDB[key];
                    console.log('‚úÖ ÊâæÂà∞GraphRAGÂàÜÊûêÊï∞ÊçÆ:', key);
                    break;
                }
            }
            
            if (!displayContent) {
                // ÊúÄÂêéÊâç‰ΩøÁî®Âç†‰ΩçÁ¨¶ÂÜÖÂÆπ
                console.log('üìã Using placeholder content for:', title);
                displayContent = getSampleContent(title);
            } else {
                console.log('üìã Found real content, length:', displayContent.length);
                // Convert plain text to HTML for display
                displayContent = displayContent.replace(/\n/g, '<br>').replace(/‚Ä¢/g, '&bull;');
            }
            
            // ÊòæÁ§∫ÂÖ≥Èó≠ÊåâÈíÆ
            closePreviewBtn.style.display = 'block';
            
            // Ê†πÊçÆÊòØÂê¶ÊúâGraphRAGÂàÜÊûêÊï∞ÊçÆÂÜ≥ÂÆöÊòæÁ§∫ÂÜÖÂÆπ
            if (fileAnalysis && fileAnalysis.extractedContent) {
                console.log('üé® ÊòæÁ§∫GraphRAGÂàÜÊûêÁïåÈù¢');
                contentPreview.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <h2 style="margin: 0 0 16px 0; color: #1f2937; display: flex; align-items: center; gap: 12px; font-size: 20px;">
                            üìÑ ${title}
                        </h2>
                    </div>
                    
                    <!-- AIÂàÜÊûêÊëòË¶Å -->
                    <div style="
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                        color: white; padding: 20px; border-radius: 12px; margin-bottom: 20px;
                        max-height: 250px; overflow-y: auto;
                    ">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 16px;">
                            <div style="
                                background: rgba(255,255,255,0.2); width: 32px; height: 32px; 
                                border-radius: 50%; display: flex; align-items: center; justify-content: center;
                                font-size: 16px;
                            ">üß†</div>
                            <h3 style="margin: 0; font-size: 16px; font-weight: 600;">AIÊ∑±Â∫¶ÂàÜÊûêÊëòË¶Å</h3>
                        </div>
                        
                        <div style="background: rgba(255,255,255,0.1); border-radius: 10px; padding: 18px; margin-bottom: 15px;">
                            <h4 style="color: white; margin: 0 0 10px 0; font-size: 16px;">üìä Core Insights:</h4>
                            <div style="color: rgba(255,255,255,0.9); font-size: 14px; line-height: 1.7;">
                                ${fileAnalysis.extractedContent}
                            </div>
                        </div>
                        
                        <div style="background: rgba(255,255,255,0.1); border-radius: 10px; padding: 18px;">
                            <h4 style="color: white; margin: 0 0 15px 0; font-size: 16px;">üß† GraphRAGÊô∫ËÉΩÂàÜÊûêÁªìÊûúÔºö</h4>
                            <div style="color: rgba(255,255,255,0.9); font-size: 14px; line-height: 1.6;">
                                <div style="margin-bottom: 12px;">
                                    <strong style="color: white;">üè∑Ô∏è ËØÜÂà´ÁöÑÊ¶ÇÂøµÔºö</strong><br>
                                    ${fileAnalysis.concepts?.join(' ‚Ä¢ ') || 'No concept information available'}
                                </div>
                                <div style="margin-bottom: 12px;">
                                    <strong style="color: white;">üë• ËØÜÂà´ÁöÑÂÆû‰ΩìÔºö</strong><br>
                                    ${fileAnalysis.entities?.join(' ‚Ä¢ ') || 'No entity information available'}
                                </div>
                                <div style="margin-bottom: 12px;">
                                    <strong style="color: white;">üìç Âª∫ËÆÆÂàÜÁ±ªË∑ØÂæÑÔºö</strong><br>
                                    ${fileAnalysis.positionSuggestion?.primarySuggestion?.path || 'No path suggestion available'}
                                </div>
                                <div>
                                    <strong style="color: white;">üéØ ÂàÜÊûêÁΩÆ‰ø°Â∫¶Ôºö</strong><br>
                                    ${Math.round((fileAnalysis.confidence || 0) * 100)}%
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- ÊñáÊ°£ÁªìÊûÑ‰∏éÂÜÖÂÆπ -->
                    <div style="display: grid; grid-template-columns: 350px 1fr; gap: 16px; height: 400px;">
                        <!-- Â∑¶‰æßÊñáÊ°£ÁªìÊûÑ -->
                        <div style="
                            background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 16px; 
                            overflow: hidden; display: flex; flex-direction: column;
                        ">
                            <div style="
                                background: #e2e8f0; padding: 16px 20px; 
                                border-bottom: 1px solid #d1d5db;
                            ">
                                <h4 style="margin: 0; color: #1f2937; font-size: 16px; font-weight: 600;">üìã Document Outline</h4>
                            </div>
                            <div style="flex: 1; padding: 16px; overflow-y: auto; max-height: 350px;">
                                <div style="margin-bottom: 16px;">
                                    <div style="
                                        background: #e0f2fe; color: #0c4a6e; padding: 12px; 
                                        border-radius: 8px; font-size: 13px; text-align: center;
                                    ">
                                        üìä AIÂàÜÊûêÂÜÖÂÆπ ‚Ä¢ ${fileAnalysis.extractedContent.split(' ').length} ËØç
                                    </div>
                                </div>
                                <div onclick="showSectionInPreview('full', '${title}')" style="
                                    padding: 12px; margin-bottom: 8px; border-radius: 8px; 
                                    background: white; border: 1px solid #e2e8f0; cursor: pointer;
                                    transition: all 0.2s ease;
                                " onmouseover="this.style.backgroundColor='#f0f9ff'; this.style.borderColor='#3b82f6'" 
                                   onmouseout="this.style.backgroundColor='white'; this.style.borderColor='#e2e8f0'">
                                    <div style="
                                        display: flex; justify-content: space-between; align-items: flex-start; 
                                        margin-bottom: 6px;
                                    ">
                                        <span style="
                                            font-weight: 600; color: #1f2937; font-size: 13px;
                                        ">Full Analysis Content</span>
                                        <span style="
                                            font-size: 11px; color: #6b7280;
                                        ">${fileAnalysis.extractedContent.length} characters</span>
                                    </div>
                                    <div style="
                                        color: #4b5563; font-size: 12px; line-height: 1.4;
                                    ">${fileAnalysis.extractedContent.substring(0, 60)}...</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Âè≥‰æßÂÜÖÂÆπÈ¢ÑËßà -->
                        <div style="
                            background: white; border: 1px solid #e2e8f0; border-radius: 16px;
                            overflow: hidden; display: flex; flex-direction: column;
                        ">
                            <div style="
                                background: #f8fafc; padding: 16px 20px; 
                                border-bottom: 1px solid #e2e8f0;
                            ">
                                <h4 style="margin: 0; color: #1f2937; font-size: 16px; font-weight: 600;">üëÅÔ∏è Content Preview</h4>
                            </div>
                            <div id="documentPreviewContent_${title}" style="
                                flex: 1; padding: 20px; overflow-y: auto; max-height: 350px;
                                line-height: 1.8; color: #374151; font-size: 16px;
                            ">
                                <div style="text-align: center; padding: 40px 20px; color: #9ca3af;">
                                    <div style="font-size: 48px; margin-bottom: 16px;">üìñ</div>
                                    <h3 style="margin: 0 0 12px 0; color: #6b7280;">ÁÇπÂáªÂ∑¶‰æßÊü•ÁúãÂÜÖÂÆπ</h3>
                                    <p style="margin: 0; font-size: 14px;">
                                        ÁÇπÂáªÂ∑¶‰æß"ÂÆåÊï¥ÂàÜÊûêÂÜÖÂÆπ"Êü•ÁúãAIÊ∑±Â∫¶ÂàÜÊûê
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                console.log('üìã ÊòæÁ§∫ÁÆÄÂçïÊñáÊú¨ÂÜÖÂÆπ');
                contentPreview.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <h2 style="margin: 0 0 16px 0; color: #1f2937; display: flex; align-items: center; gap: 12px; font-size: 20px;">
                            üìÑ ${title}
                        </h2>
                    </div>
                    <div style="
                        background: white; border-radius: 12px; padding: 24px; 
                        line-height: 1.6; font-size: 15px; color: #374151; border: 1px solid #e5e7eb;
                    ">
                        ${displayContent}
                    </div>
                    <div style="margin-top: 20px; display: flex; gap: 12px;">
                        <button onclick="editNodeFromPreview('${title}')" style="
                            padding: 10px 20px; border: 2px solid #8b5cf6; 
                            background: white; color: #8b5cf6; border-radius: 8px; cursor: pointer; font-weight: 500;
                        ">‚úèÔ∏è Edit Content</button>
                    </div>
                `;
            }
        }

        // Clear content preview
        window.clearContentPreview = function() {
            const contentPreview = document.getElementById('contentPreview');
            const closePreviewBtn = document.getElementById('closePreview');
            
            if (contentPreview) {
                contentPreview.innerHTML = `
                    <div class="empty-preview" style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: #6b7280; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 16px;">üìÑ</div>
                        <h3 style="margin: 0 0 8px 0; font-size: 18px; color: #374151;">Select a document to preview</h3>
                        <p style="margin: 0; font-size: 14px;">Click on any document in the knowledge tree to view its content here</p>
                    </div>
                `;
            }
            
            if (closePreviewBtn) {
                closePreviewBtn.style.display = 'none';
            }
        }

        // Edit node from preview area
        window.editNodeFromPreview = function(title) {
            // Find the node with this title and trigger edit
            const allNodes = document.querySelectorAll('.node-title');
            for (const nodeTitle of allNodes) {
                if (nodeTitle.textContent === title) {
                    const nodeContent = nodeTitle.closest('.node-content');
                    if (nodeContent) {
                        window.editNode(new Event('click'), nodeContent);
                        break;
                    }
                }
            }
        }

        // Show section content in preview (for GraphRAG analysis)
        window.showSectionInPreview = function(sectionType, title) {
            const previewContent = document.getElementById(`documentPreviewContent_${title}`);
            if (!previewContent) return;
            
            // Get the analysis data
            const analysisDB = JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}');
            let fileAnalysis = null;
            
            const sortedKeys = Object.keys(analysisDB).sort((a, b) => {
                const timestampA = a.split('_').pop() || '0';
                const timestampB = b.split('_').pop() || '0';
                return parseInt(timestampB) - parseInt(timestampA);
            });
            
            for (const key of sortedKeys) {
                if (key.startsWith(title + '_') || key === title) {
                    fileAnalysis = analysisDB[key];
                    break;
                }
            }
            
            if (fileAnalysis && sectionType === 'full') {
                previewContent.innerHTML = `
                    <div style="line-height: 1.8; color: #374151; font-size: 15px;">
                        ${fileAnalysis.extractedContent.replace(/\n/g, '<br>')}
                    </div>
                `;
            }
        }

        // Get sample content for different knowledge items
        function getSampleContent(title) {
            const contentMap = {
                'Êæ≥Ê¥≤Â∏ÇÂú∫Áî®Êà∑ÁîªÂÉèÂàÜÊûê': `
                    <h3>üéØ ÁõÆÊ†áÁî®Êà∑ÁîªÂÉè</h3>
                    <p><strong>‰∏ªË¶ÅÁî®Êà∑Áæ§‰ΩìÔºö</strong></p>
                    <ul>
                        <li><strong>ÁßëÊäÄÂàõ‰∏öËÄÖ</strong> - 25-40Â≤ÅÔºåÈõÜ‰∏≠Âú®ÊÇâÂ∞º„ÄÅÂ¢®Â∞îÊú¨</li>
                        <li><strong>Êï∞Â≠óËê•ÈîÄÁªèÁêÜ</strong> - 30-45Â≤ÅÔºå‰∏≠Â§ßÂûã‰ºÅ‰∏ö</li>
                        <li><strong>ÂÜÖÂÆπÂàõ‰ΩúËÄÖ</strong> - 20-35Â≤ÅÔºåËá™Â™í‰ΩìÂíåKOL</li>
                    </ul>
                    
                    <h3>üìä Â∏ÇÂú∫ÁâπÂæÅ</h3>
                    <p><strong>Ê∂àË¥πË°å‰∏∫Ôºö</strong></p>
                    <ul>
                        <li>È´òÂ∫¶ÈáçËßÜ‰∫ßÂìÅË¥®ÈáèÂíåÁî®Êà∑‰ΩìÈ™å</li>
                        <li>ÂÅèÂ•ΩÊú¨ÂúüÂåñÊúçÂä°ÂíåÊú¨Âú∞Ê°à‰æã</li>
                        <li>LinkedInÂíåemailËê•ÈîÄÊïàÊûúÊúÄ‰Ω≥</li>
                        <li>Âπ≥ÂùáÂÜ≥Á≠ñÂë®ÊúüÔºöB2B 3-6‰∏™ÊúàÔºåB2C 1-2Âë®</li>
                    </ul>

                    <h3>üí° ÂÖ≥ÈîÆÊ¥ûÂØü</h3>
                    <p>Êæ≥Ê¥≤Áî®Êà∑ÂØπAIÂ∑•ÂÖ∑ÊåÅÂºÄÊîæÊÄÅÂ∫¶Ôºå‰ΩÜÊõ¥Ê≥®ÈáçÂÆûÈôÖROIÂíåÂêàËßÑÊÄß„ÄÇÂª∫ËÆÆÈáçÁÇπÁ™ÅÂá∫ÊïàÁéáÊèêÂçáÂíåÊàêÊú¨ËäÇÁ∫¶„ÄÇ</p>
                `,
                'ÊÇâÂ∞ºÁßëÊäÄÂúàÁ´ûÂìÅÂàÜÊûê': `
                    <h3>üè¢ ‰∏ªË¶ÅÁ´û‰∫âÂØπÊâã</h3>
                    <p><strong>Áõ¥Êé•Á´û‰∫âËÄÖÔºö</strong></p>
                    <ul>
                        <li><strong>Canva</strong> - ËÆæËÆ°Â∑•ÂÖ∑ÔºåÊÇâÂ∞ºÊú¨ÂúüÁã¨ËßíÂÖΩ</li>
                        <li><strong>Atlassian</strong> - Âçè‰ΩúÂ∑•ÂÖ∑ÔºåÂº∫Â§ßÁöÑÊú¨Âú∞ÂΩ±ÂìçÂäõ</li>
                        <li><strong>Campaign Monitor</strong> - ÈÇÆ‰ª∂Ëê•ÈîÄÔºåÊæ≥Ê¥≤ËÄÅÁâå</li>
                    </ul>
                    
                    <h3>üìà Â∏ÇÂú∫Êú∫‰ºö</h3>
                    <p><strong>Â∑ÆÂºÇÂåñ‰ºòÂäøÔºö</strong></p>
                    <ul>
                        <li>AIÈ©±Âä®ÁöÑÊô∫ËÉΩÂÜÖÂÆπÁîüÊàê</li>
                        <li>Â§öÂπ≥Âè∞Êï¥ÂêàËê•ÈîÄËá™Âä®Âåñ</li>
                        <li>Êú¨Âú∞ÂåñÁöÑÂÆ¢Êà∑ÊîØÊåÅÊúçÂä°</li>
                        <li>Á¨¶ÂêàGDPRÂíåÊæ≥Ê¥≤ÈöêÁßÅÊ≥ïËßÑ</li>
                    </ul>

                    <h3>üí∞ ÂÆö‰ª∑Á≠ñÁï•Âª∫ËÆÆ</h3>
                    <p>Âª∫ËÆÆÈááÁî®ËÆ¢ÈòÖÂà∂ÔºåËµ∑Ê≠•‰ª∑$49/ÊúàÔºåÂØπÊ†áCanva Pro„ÄÇÊèê‰æõ14Â§©ÂÖçË¥πËØïÁî®Êúü„ÄÇ</p>
                `,
                'AIËê•ÈîÄÁ≠ñÁï•Ê°à‰æãÂ∫ì': `
                    <h3>üéØ ÊàêÂäüÊ°à‰æãÈõÜ</h3>
                    
                    <h4>Ê°à‰æã1: ÊÇâÂ∞ºÂíñÂï°ËøûÈîÅÂ∫ó</h4>
                    <p><strong>Á≠ñÁï•Ôºö</strong>‰ΩøÁî®AIÁîüÊàêÊú¨Âú∞ÂåñÁ§æ‰∫§Â™í‰ΩìÂÜÖÂÆπ</p>
                    <p><strong>ÁªìÊûúÔºö</strong>InstagramÂèÇ‰∏éÂ∫¶ÊèêÂçá340%ÔºåÊñ∞ÂÆ¢Êà∑Â¢ûÈïø180%</p>
                    
                    <h4>Ê°à‰æã2: Â¢®Â∞îÊú¨SaaSÂÖ¨Âè∏</h4>
                    <p><strong>Á≠ñÁï•Ôºö</strong>AIÈ©±Âä®ÁöÑLinkedInÂÜÖÂÆπËê•ÈîÄ</p>
                    <p><strong>ÁªìÊûúÔºö</strong>ÊΩúÂú®ÂÆ¢Êà∑Â¢ûÈïø250%ÔºåËΩ¨ÂåñÁéáÊèêÂçá45%</p>
                    
                    <h4>Ê°à‰æã3: Â∏ÉÈáåÊñØÁè≠ÁîµÂïÜÂπ≥Âè∞</h4>
                    <p><strong>Á≠ñÁï•Ôºö</strong>‰∏™ÊÄßÂåñÈÇÆ‰ª∂Ëê•ÈîÄËá™Âä®Âåñ</p>
                    <p><strong>ÁªìÊûúÔºö</strong>ÈÇÆ‰ª∂ÊâìÂºÄÁéá60%ÔºåÁÇπÂáªÁéáÊèêÂçá120%</p>

                    <h3>üìù ÊúÄ‰Ω≥ÂÆûË∑µ</h3>
                    <ul>
                        <li>ÁªìÂêàÊú¨Âú∞ÊñáÂåñÂÖÉÁ¥†ÂíåÊµÅË°åËØ≠</li>
                        <li>ÈáçÁÇπÁ™ÅÂá∫ROIÂíåÊïàÁéáÊèêÂçá</li>
                        <li>‰ΩøÁî®ÂÆ¢Êà∑ÊàêÂäüÊïÖ‰∫ãÂª∫Á´ã‰ø°‰ªª</li>
                    </ul>
                `,
                'ÁàÜÊ¨æÊñáÊ°àÂÜô‰ΩúÊ®°Êùø': `
                    <h3>üìù AIDAÁàÜÊ¨æÂÖ¨Âºè</h3>
                    <p><strong>A - Attention (Âê∏ÂºïÊ≥®ÊÑè)</strong></p>
                    <ul>
                        <li>"ÊÇâÂ∞ºÂàõ‰∏öËÄÖÈÉΩÂú®Áî®ÁöÑAIÁ•ûÂô®"</li>
                        <li>"5ÂàÜÈíüÁîüÊàê‰∏ÄÂë®Á§æÂ™íÂÜÖÂÆπ"</li>
                        <li>"ËÆ©‰Ω†ÁöÑËê•ÈîÄÊïàÊûúÊèêÂçá3ÂÄçÁöÑÁßòÂØÜ"</li>
                    </ul>
                    
                    <p><strong>I - Interest (ÊøÄÂèëÂÖ¥Ë∂£)</strong></p>
                    <ul>
                        <li>ÂÖ∑‰ΩìÊï∞ÊçÆÔºöËäÇÁúÅ80%Êó∂Èó¥</li>
                        <li>ÂêåË°åÊ°à‰æãÔºöXXÂÖ¨Âè∏ÊúàÂ¢ûÈïø200%</li>
                        <li>Áã¨Áâπ‰ºòÂäøÔºöÊæ≥Ê¥≤Êú¨ÂúüÂåñAIÊ®°Âûã</li>
                    </ul>

                    <p><strong>D - Desire (ÂàõÈÄ†Ê∏¥Êúõ)</strong></p>
                    <ul>
                        <li>ÊÉ≥Ë±°ÊàêÂäüÂú∫ÊôØÔºö"ÊÉ≥Ë±°ÊØèÂ§©Âè™ÈúÄ30ÂàÜÈíüÂ∞±ËÉΩÂÆåÊàêÊâÄÊúâËê•ÈîÄÂ∑•‰Ωú"</li>
                        <li>ÊÅêÊÉßÈîôÂ§±Ôºö"Á´û‰∫âÂØπÊâãÂ∑≤ÁªèÂºÄÂßã‰ΩøÁî®Ôºå‰Ω†ËøòÂú®Á≠â‰ªÄ‰πàÔºü"</li>
                    </ul>

                    <p><strong>A - Action (Ë°åÂä®Âè¨Âî§)</strong></p>
                    <ul>
                        <li>"Á´ãÂç≥ÂºÄÂßã14Â§©ÂÖçË¥πËØïÁî®"</li>
                        <li>"Âä†ÂÖ•3000+Êæ≥Ê¥≤‰ºÅ‰∏öÁöÑÊàêÂäüË°åÂàó"</li>
                    </ul>
                `,
                'AIÂÜô‰ΩúÊèêÁ§∫ËØçÂ∫ì': `
                    <h3>ü§ñ È´òÊïàÊèêÁ§∫ËØçÊ®°Êùø</h3>
                    
                    <h4>üì± Á§æ‰∫§Â™í‰ΩìÂÜÖÂÆπ</h4>
                    <p><code>‰∏∫[Ë°å‰∏ö]ÂÖ¨Âè∏ÂÜô‰∏ÄÊù°LinkedInÂ∏ñÂ≠êÔºå‰ªãÁªç[‰∫ßÂìÅ/ÊúçÂä°]ÔºåÁõÆÊ†áÂèó‰ºóÊòØ[Êæ≥Ê¥≤/ÊÇâÂ∞º][ÂÖ∑‰Ωì‰∫∫Áæ§]ÔºåËØ≠Ë∞ÉË¶Å[‰∏ì‰∏ö/ËΩªÊùæ]ÔºåÂåÖÂê´Áõ∏ÂÖ≥ËØùÈ¢òÊ†áÁ≠æ„ÄÇ</code></p>
                    
                    <h4>üìß ÈÇÆ‰ª∂Ëê•ÈîÄ</h4>
                    <p><code>ÂÜô‰∏ÄÂ∞Å[Ê¨¢Ëøé/Êé®Âπø/Áª≠Ë¥π]ÈÇÆ‰ª∂ÔºåÂèëÈÄÅÁªô[ÁõÆÊ†áÂÆ¢Êà∑]ÔºåÁ™ÅÂá∫[Ê†∏ÂøÉ‰ª∑ÂÄº]ÔºåÂåÖÂê´ÊòéÁ°ÆÁöÑË°åÂä®Âè¨Âî§ÔºåÁ¨¶ÂêàÊæ≥Ê¥≤ÈÇÆ‰ª∂Ëê•ÈîÄÊúÄ‰Ω≥ÂÆûË∑µ„ÄÇ</code></p>
                    
                    <h4>üìù ÂçöÂÆ¢ÊñáÁ´†</h4>
                    <p><code>ÂÜô‰∏ÄÁØáÂÖ≥‰∫é[ËØùÈ¢ò]ÁöÑÂçöÂÆ¢ÊñáÁ´†ÔºåÈíàÂØπÊæ≥Ê¥≤[ÁõÆÊ†áÂèó‰ºó]ÔºåÂåÖÂê´SEOÂÖ≥ÈîÆËØçÔºåÊñáÁ´†ÁªìÊûÑÊ∏ÖÊô∞ÔºåÊèê‰æõÂÆûÁî®‰ª∑ÂÄº„ÄÇ</code></p>

                    <h3>üí° ‰ºòÂåñÊäÄÂ∑ß</h3>
                    <ul>
                        <li>ÂÖ∑‰ΩìÂåñÔºöÁî®ÂÖ∑‰ΩìË°å‰∏ö„ÄÅÂú∞Âå∫„ÄÅÊï∞ÊçÆ</li>
                        <li>Êú¨ÂúüÂåñÔºöÂä†ÂÖ•Êæ≥Ê¥≤ÊñáÂåñÂÖÉÁ¥†</li>
                        <li>ËßíËâ≤ËÆæÂÆöÔºöÊòéÁ°ÆAIÊâÆÊºîÁöÑËßíËâ≤</li>
                        <li>Ê†ºÂºèË¶ÅÊ±ÇÔºöÊåáÂÆöËæìÂá∫Ê†ºÂºèÂíåÈïøÂ∫¶</li>
                    </ul>
                `
            };

            // ‰∏∫ÂÖ∂‰ªñÊ≤°ÊúâÂÖ∑‰ΩìÂÜÖÂÆπÁöÑËäÇÁÇπÊèê‰æõÈÄöÁî®Ê®°Êùø
            if (contentMap[title]) {
                return contentMap[title];
            } else {
                return `
                    <h3>üìÑ ${title}</h3>
                    <p>ËøôÈáåÊòØ<strong>${title}</strong>ÁöÑËØ¶ÁªÜÂÜÖÂÆπ„ÄÇ</p>
                    <p>ÊÇ®ÂèØ‰ª•ÁÇπÂáª‰∏ãÊñπÁöÑ"‚úèÔ∏è Edit Content"ÊåâÈíÆÊù•ÁºñËæëÂíåÊ∑ªÂä†ÊÇ®Ëá™Â∑±ÁöÑÂÜÖÂÆπ„ÄÇ</p>
                    
                    <div style="background: #eff6ff; border-left: 4px solid #3b82f6; padding: 16px; margin: 16px 0;">
                        <p><strong>üí° ÊèêÁ§∫Ôºö</strong>ËøôÊòØ‰∏Ä‰∏™ÂÜÖÂÆπÂç†‰ΩçÁ¨¶„ÄÇÊÇ®ÂèØ‰ª•Âú®ËøôÈáåÊ∑ªÂä†Ôºö</p>
                        <ul>
                            <li>Áõ∏ÂÖ≥ÁöÑÁ†îÁ©∂ËµÑÊñôÂíåÊï∞ÊçÆ</li>
                            <li>ÊúÄ‰Ω≥ÂÆûË∑µÂíåÊ°à‰æãÁ†îÁ©∂</li>
                            <li>Ê®°ÊùøÂíåÂ∑•ÂÖ∑ÈìæÊé•</li>
                            <li>Ë°åÂä®Ê∏ÖÂçïÂíåÊ£ÄÊü•ÂàóË°®</li>
                        </ul>
                    </div>
                `;
            }
        }

        // Drag and Drop functionality
        let draggedElement = null;

        function handleDragStart(event) {
            draggedElement = event.target.closest('.tree-node');
            const nodeContent = event.target.closest('.node-content');
            nodeContent.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/html', draggedElement.outerHTML);
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            
            const dropTarget = event.target.closest('.node-content');
            if (dropTarget && dropTarget !== draggedElement?.querySelector('.node-content')) {
                // Remove previous drag-over styles
                document.querySelectorAll('.node-content.drag-over').forEach(node => {
                    node.classList.remove('drag-over');
                });
                
                // Add drag-over style to current target
                dropTarget.classList.add('drag-over');
            }
        }

        function handleDrop(event) {
            event.preventDefault();
            
            const dropTarget = event.target.closest('.node-content');
            if (!dropTarget || !draggedElement) return;
            
            const targetTreeNode = dropTarget.closest('.tree-node');
            const targetIsFolder = targetTreeNode.querySelector('.node-icon.folder');
            
            if (targetIsFolder && targetTreeNode !== draggedElement) {
                // Drop into folder
                let childrenContainer = targetTreeNode.querySelector('.node-children');
                if (!childrenContainer) {
                    childrenContainer = document.createElement('div');
                    childrenContainer.className = 'node-children expanded';
                    targetTreeNode.appendChild(childrenContainer);
                    
                    // Update expand icon
                    const expandIcon = targetTreeNode.querySelector('.node-expand');
                    expandIcon.innerHTML = '‚ñº';
                    expandIcon.setAttribute('onclick', 'toggleNode(event, this)');
                }
                
                childrenContainer.classList.add('expanded');
                
                // Clone the dragged element and update its event handlers
                const clonedElement = draggedElement.cloneNode(true);
                updateEventHandlers(clonedElement);
                
                childrenContainer.appendChild(clonedElement);
                draggedElement.remove();
                
                showNotification('Item moved successfully! üì¶');
            }
            
            // Clean up
            cleanupDragStyles();
        }

        function handleDragEnd(event) {
            cleanupDragStyles();
            draggedElement = null;
        }

        function cleanupDragStyles() {
            // Remove all drag-related styles
            document.querySelectorAll('.node-content').forEach(node => {
                node.classList.remove('dragging', 'drag-over');
            });
        }

        // Edit node title (double-click)
        function editNodeTitle(event, titleElement) {
            event.stopPropagation();
            const currentTitle = titleElement.textContent;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentTitle;
            input.style.width = '100%';
            input.style.border = '1px solid #8b5cf6';
            input.style.borderRadius = '4px';
            input.style.padding = '2px 6px';
            input.style.fontSize = '14px';
            
            titleElement.innerHTML = '';
            titleElement.appendChild(input);
            input.focus();
            input.select();
            
            function saveTitle() {
                const newTitle = input.value.trim();
                if (newTitle && newTitle !== currentTitle) {
                    titleElement.textContent = newTitle;
                    showNotification(`Renamed to "${newTitle}" ‚úèÔ∏è`);
                } else {
                    titleElement.textContent = currentTitle;
                }
            }
            
            input.addEventListener('blur', saveTitle);
            input.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    input.blur();
                }
                if (e.key === 'Escape') {
                    titleElement.textContent = currentTitle;
                }
            });
        }

        // Add child item to any node (folder or file) - make global
        window.addChildItem = function(event, buttonElement) {
            event.stopPropagation();
            const itemName = prompt('Enter item name:');
            if (!itemName) return;
            
            const treeNode = buttonElement.closest('.tree-node');
            let childrenContainer = treeNode.querySelector('.node-children');
            
            if (!childrenContainer) {
                childrenContainer = document.createElement('div');
                childrenContainer.className = 'node-children expanded';
                treeNode.appendChild(childrenContainer);
            }
            
            childrenContainer.classList.add('expanded');
            
            // Update expand icon (create one if it doesn't exist)
            let expandIcon = treeNode.querySelector('.node-expand');
            if (!expandIcon.innerHTML || expandIcon.innerHTML === '') {
                expandIcon.innerHTML = '‚ñº';
                expandIcon.setAttribute('onclick', 'toggleNode(event, this)');
            } else if (expandIcon.innerHTML === '‚ñ∂') {
                expandIcon.innerHTML = '‚ñº';
            }
            
            const newItem = createTreeNode(itemName, 'file', false);
            childrenContainer.appendChild(newItem);
            
            // Ensure event handlers are properly attached
            updateEventHandlers(newItem);
            
            const parentName = treeNode.querySelector('.node-title').textContent;
            showNotification(`Item "${itemName}" added to "${parentName}"! üìÑ`);
        }

        // Update event handlers for dynamically created elements
        function updateEventHandlers(element) {
            const nodeContent = element.querySelector('.node-content');
            if (nodeContent) {
                // Check if it's a file or folder to set correct onclick handler
                const nodeIcon = nodeContent.querySelector('.node-icon');
                const isFolder = nodeIcon && nodeIcon.classList.contains('folder');
                
                // Check if it's an uploaded file (has storage key attributes)
                const parentNode = nodeContent.closest('.tree-node');
                const hasStorageKey = parentNode && parentNode.hasAttribute('data-file-storage-key');
                
                // Update main node onclick
                if (isFolder) {
                    nodeContent.setAttribute('onclick', 'selectNode(this)');
                } else if (hasStorageKey) {
                    // Don't override uploaded files - they should keep openFileWithLocalTool
                    // Only update if it doesn't already have the correct handler
                    const currentOnclick = nodeContent.getAttribute('onclick');
                    if (!currentOnclick || !currentOnclick.includes('openFileWithLocalTool')) {
                        nodeContent.setAttribute('onclick', 'openFileWithLocalTool(event, this)');
                    }
                } else {
                    nodeContent.setAttribute('onclick', 'showNodeContent(event, this)');
                }
                
                nodeContent.setAttribute('draggable', 'true');
                nodeContent.setAttribute('ondragstart', 'handleDragStart(event)');
                nodeContent.setAttribute('ondragover', 'handleDragOver(event)');
                nodeContent.setAttribute('ondrop', 'handleDrop(event)');
                nodeContent.setAttribute('ondragend', 'handleDragEnd(event)');
                
                // Update title double-click
                const nodeTitle = nodeContent.querySelector('.node-title');
                if (nodeTitle) {
                    nodeTitle.setAttribute('ondblclick', 'editNodeTitle(event, this)');
                }
                
                // Update expand button
                const expandBtn = nodeContent.querySelector('.node-expand');
                if (expandBtn && (expandBtn.innerHTML === '‚ñ∂' || expandBtn.innerHTML === '‚ñº')) {
                    expandBtn.setAttribute('onclick', 'toggleNode(event, this)');
                }
                
                // Update action buttons
                const actionButtons = nodeContent.querySelectorAll('.node-action');
                actionButtons.forEach(button => {
                    const buttonText = button.textContent || button.innerHTML;
                    if (buttonText.includes('‚ûï')) {
                        button.setAttribute('onclick', 'addChildItem(event, this)');
                    } else if (buttonText.includes('‚úèÔ∏è')) {
                        button.setAttribute('onclick', 'editNode(event, this)');
                    } else if (buttonText.includes('üóëÔ∏è')) {
                        button.setAttribute('onclick', 'deleteNode(event, this)');
                    }
                });
            }
            
            // Recursively update child nodes
            const childNodes = element.querySelectorAll('.tree-node');
            childNodes.forEach(child => {
                if (child !== element) { // Avoid infinite recursion
                    updateEventHandlers(child);
                }
            });
        }

        // Edit node (content) - make it global for easier access
        // Simple content storage
        const nodeContentStore = {};

        // Selected nodes for analysis
        let selectedNodes = [];
        let selectedNodesData = {};

        // Toggle document selection
        window.toggleSelection = function(event, button) {
            event.stopPropagation();
            
            const nodeContent = button.closest('.node-content');
            const title = nodeContent.querySelector('.node-title').textContent;
            const isSelected = button.getAttribute('data-selected') === 'true';
            
            if (isSelected) {
                // Deselect
                button.setAttribute('data-selected', 'false');
                selectedNodes = selectedNodes.filter(node => node !== title);
                delete selectedNodesData[title];
            } else {
                // Select
                button.setAttribute('data-selected', 'true');
                selectedNodes.push(title);
                selectedNodesData[title] = {
                    content: nodeContentStore[title] || getSampleContent(title) || '',
                    type: nodeContent.querySelector('.node-icon').classList.contains('folder') ? 'folder' : 'file',
                    element: nodeContent
                };
            }
            
            // Update selected docs display
            updateSelectedDocsDisplay();
        }

        window.editNode = function(event, buttonElement) {
            event.stopPropagation();
            console.log('editNode called!', event, buttonElement);
            const nodeContent = buttonElement.closest('.node-content');
            const title = nodeContent.querySelector('.node-title').textContent;
            
            // Get existing content or sample content
            let existingContent = nodeContentStore[title];
            if (!existingContent) {
                // Try to get from sample content and convert HTML to plain text
                const sampleContent = getSampleContent(title);
                if (sampleContent) {
                    // Convert HTML to plain text for editing
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = sampleContent;
                    existingContent = tempDiv.textContent || tempDiv.innerText || '';
                } else {
                    existingContent = `ËØ∑Âú®Ê≠§ÁºñËæë "${title}" ÁöÑÂÜÖÂÆπ...

ÊÇ®ÂèØ‰ª•Ê∑ªÂä†Ôºö
‚Ä¢ ËØ¶ÁªÜÊèèËø∞
‚Ä¢ Áõ∏ÂÖ≥ÈìæÊé•
‚Ä¢ Êìç‰ΩúÊ≠•È™§
‚Ä¢ ÈáçË¶ÅÊ≥®ÊÑè‰∫ãÈ°π`;
                }
            }
            
            // Create a simple content editor modal
            const modal = document.createElement('div');
            modal.className = 'edit-modal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.6); z-index: 5000; display: flex; 
                align-items: center; justify-content: center;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white; padding: 24px; border-radius: 12px; 
                width: 500px; max-width: 90vw; max-height: 70vh; overflow-y: auto;
                box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            `;
            
            modalContent.innerHTML = `
                <h3 style="margin: 0 0 16px 0; color: #1f2937;">‚úèÔ∏è Edit Content: ${title}</h3>
                <textarea id="nodeContentEditor" style="
                    width: 100%; height: 250px; border: 2px solid #e5e7eb; 
                    border-radius: 8px; padding: 12px; font-size: 14px; 
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                    resize: vertical; outline: none;
                " placeholder="Enter your content here...">${existingContent}</textarea>
                <div style="margin-top: 20px; text-align: right;">
                    <button id="cancelBtn" style="
                        margin-right: 12px; padding: 10px 20px; border: 2px solid #e5e7eb; 
                        background: white; border-radius: 6px; cursor: pointer; font-weight: 500;
                    ">Cancel</button>
                    <button id="saveBtn" style="
                        padding: 10px 20px; background: linear-gradient(135deg, #8b5cf6, #6366f1); 
                        color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;
                    ">üíæ Save Content</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Add event listeners
            const cancelBtn = modalContent.querySelector('#cancelBtn');
            const saveBtn = modalContent.querySelector('#saveBtn');
            const textarea = modalContent.querySelector('#nodeContentEditor');
            
            cancelBtn.addEventListener('click', () => {
                document.body.removeChild(modal);
            });
            
            saveBtn.addEventListener('click', () => {
                const content = textarea.value;
                // Store the content
                nodeContentStore[title] = content;
                console.log(`Saved content for "${title}":`, content);
                
                // Update the display content as well
                updateNodeDisplayContent(title, content);
                
                showNotification(`Content saved for "${title}" ‚úÖ`);
                document.body.removeChild(modal);
            });
            
            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
            
            // Focus on textarea
            setTimeout(() => textarea.focus(), 100);
        }
        
        // Update node display content after editing
        function updateNodeDisplayContent(title, content) {
            // This will be used by showNodeContent to display updated content
            // The content is already stored in nodeContentStore
        }

        // GraphRAG Analysis Function
        window.analyzeWithGraphRAG = function(event, buttonElement) {
            event.stopPropagation();
            console.log('GraphRAG Analysis triggered!', event, buttonElement);
            
            const nodeContent = buttonElement.closest('.node-content');
            const title = nodeContent.querySelector('.node-title').textContent;
            
            // Get content for analysis
            let analysisContent = nodeContentStore[title] || getSampleContent(title) || 'ÊöÇÊó†ÂÜÖÂÆπÂèØÂàÜÊûê';
            
            // Show loading modal
            showAnalysisLoadingModal(title);
            
            // Simulate GraphRAG analysis process
            setTimeout(() => {
                performGraphRAGAnalysis(title, analysisContent);
            }, 2000);
        }

        // Show loading modal for GraphRAG analysis
        function showAnalysisLoadingModal(title) {
            const modal = document.createElement('div');
            modal.id = 'graphragLoadingModal';
            modal.className = 'analysis-loading-modal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.8); z-index: 6000; display: flex; 
                align-items: center; justify-content: center;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white; padding: 40px; border-radius: 16px; 
                    max-width: 500px; text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.4);
                    position: relative;
                ">
                    <button onclick="document.getElementById('graphragLoadingModal').remove()" style="
                        position: absolute; top: 16px; right: 16px; 
                        background: #f3f4f6; border: none; width: 32px; height: 32px; 
                        border-radius: 50%; cursor: pointer; color: #6b7280; font-size: 18px;
                        display: flex; align-items: center; justify-content: center;
                        transition: all 0.2s ease;
                    " onmouseover="this.style.background='#e5e7eb'; this.style.color='#374151'" 
                       onmouseout="this.style.background='#f3f4f6'; this.style.color='#6b7280'">‚úï</button>
                    <div style="margin-bottom: 24px;">
                        <div style="
                            width: 60px; height: 60px; border: 4px solid #e5e7eb; 
                            border-top: 4px solid #8b5cf6; border-radius: 50%; 
                            animation: spin 1s linear infinite; margin: 0 auto 16px;
                        "></div>
                        <h3 style="margin: 0; color: #1f2937; font-size: 20px;">üß† GraphRAG Ê∑±Â∫¶ÂàÜÊûê‰∏≠...</h3>
                    </div>
                    <p style="color: #6b7280; margin: 16px 0; font-size: 14px;">
                        Ê≠£Âú®ÂàÜÊûê "${title}"<br>
                        ÊûÑÂª∫Áü•ËØÜÂõæË∞± ‚Ä¢ ÊèêÂèñÂÆû‰ΩìÂÖ≥Á≥ª ‚Ä¢ ÁîüÊàêÊ¥ûÂØü
                    </p>
                    <div style="
                        background: #f3f4f6; border-radius: 8px; padding: 12px; 
                        text-align: left; font-size: 12px; color: #4b5563;
                    ">
                        <div id="analysisProgress">
                            ‚úì Âä†ËΩΩÊñáÊ°£ÂÜÖÂÆπ...<br>
                            ‚è≥ ÊûÑÂª∫Áü•ËØÜÂõæË∞±...<br>
                            ‚è≥ ÂÆû‰ΩìÂÖ≥Á≥ªÊèêÂèñ...<br>
                            ‚è≥ ÁîüÊàêÊ∑±Â∫¶Ê¥ûÂØü...<br>
                        </div>
                    </div>
                </div>
                <style>
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                </style>
            `;
            
            document.body.appendChild(modal);
            
            // Simulate progress updates
            setTimeout(() => updateProgress('‚úì Âä†ËΩΩÊñáÊ°£ÂÜÖÂÆπ...<br>‚úì ÊûÑÂª∫Áü•ËØÜÂõæË∞±...<br>‚è≥ ÂÆû‰ΩìÂÖ≥Á≥ªÊèêÂèñ...<br>‚è≥ ÁîüÊàêÊ∑±Â∫¶Ê¥ûÂØü...<br>'), 800);
            setTimeout(() => updateProgress('‚úì Âä†ËΩΩÊñáÊ°£ÂÜÖÂÆπ...<br>‚úì ÊûÑÂª∫Áü•ËØÜÂõæË∞±...<br>‚úì ÂÆû‰ΩìÂÖ≥Á≥ªÊèêÂèñ...<br>‚è≥ ÁîüÊàêÊ∑±Â∫¶Ê¥ûÂØü...<br>'), 1500);
        }
        
        function updateProgress(html) {
            const progressElement = document.getElementById('analysisProgress');
            if (progressElement) {
                progressElement.innerHTML = html;
            }
        }

        // Perform GraphRAG Analysis and show results
        function performGraphRAGAnalysis(title, content) {
            // Remove loading modal
            const loadingModal = document.getElementById('graphragLoadingModal');
            if (loadingModal) {
                document.body.removeChild(loadingModal);
            }
            
            // Generate analysis results (simulate GraphRAG processing)
            const analysisResults = generateGraphRAGResults(title, content);
            
            // Update workflow to Analysis step
            updateActiveStep('analysis');
            
            // Show results and trigger transition to next step
            showGraphRAGResults(analysisResults);
        }

        // Generate simulated GraphRAG analysis results
        function generateGraphRAGResults(title, content) {
            const results = {
                title: title,
                summary: generateAnalysisSummary(title),
                entities: generateExtractedEntities(title),
                relationships: generateEntityRelationships(title),
                insights: generateKeyInsights(title),
                recommendations: [], // Will be populated by dynamic analysis
                knowledgeGraph: generateKnowledgeGraphData(title),
                nextSteps: generateNextSteps(title)
            };
            
            return results;
        }

        function generateAnalysisSummary(title) {
            const summaries = {
                'Êæ≥Ê¥≤Â∏ÇÂú∫Áî®Êà∑ÁîªÂÉèÂàÜÊûê': {
                    overview: 'Âü∫‰∫éGraphRAGÊ∑±Â∫¶ÂàÜÊûêÔºåÊæ≥Ê¥≤Â∏ÇÂú∫ÂëàÁé∞Âá∫È´òÂ∫¶Êï∞Â≠óÂåñÁöÑB2BÁîüÊÄÅÁ≥ªÁªüÔºå‰∏ªË¶ÅÈõÜ‰∏≠Âú®ÊÇâÂ∞ºÂíåÂ¢®Â∞îÊú¨‰∏§Â§ßÂïÜ‰∏ö‰∏≠ÂøÉ„ÄÇ',
                    keyFindings: [
                        'ÁßëÊäÄÂàõ‰∏öËÄÖ(25-40Â≤Å)Âç†‰∏ªÂØºÂú∞‰ΩçÔºåÂç†ÊØî45%',
                        'Êï∞Â≠óËê•ÈîÄÈ¢ÑÁÆóÂπ¥Â¢ûÈïøÁéáËææ23%',
                        'LinkedInÊòØÊúÄ‰∏ªË¶ÅÁöÑB2BËé∑ÂÆ¢Ê∏†ÈÅì(67%‰ΩøÁî®Áéá)',
                        'Êú¨Âú∞ÂåñÂÜÖÂÆπÁöÑËΩ¨ÂåñÁéáÊØîÈÄöÁî®ÂÜÖÂÆπÈ´ò3.2ÂÄç'
                    ]
                },
                default: {
                    overview: `ÈÄöËøáGraphRAGÂàÜÊûê${title}ÔºåÂèëÁé∞‰∫ÜÂ§ö‰∏™ÂÖ≥ÈîÆÂÆû‰ΩìÂíåÊ∑±Â±ÇÂÖ≥Á≥ªÊ®°Âºè„ÄÇ`,
                    keyFindings: [
                        'ËØÜÂà´Âá∫Ê†∏ÂøÉÊ¶ÇÂøµÂíåÂÖ≥ÈîÆË¶ÅÁ¥†',
                        'ÂèëÁé∞ÊΩúÂú®ÁöÑÂÖ≥ËÅîÂÖ≥Á≥ªÂíåÂΩ±ÂìçÂõ†Â≠ê',
                        'ÊèêÂèñÂá∫ÂèØÊìç‰ΩúÁöÑÊ¥ûÂØüÂíåÂª∫ËÆÆ',
                        'ÊûÑÂª∫‰∫ÜÂÆåÊï¥ÁöÑÁü•ËØÜÂõæË∞±ÁªìÊûÑ'
                    ]
                }
            };
            
            return summaries[title] || summaries.default;
        }

        function generateExtractedEntities(title) {
            const entities = {
                'Êæ≥Ê¥≤Â∏ÇÂú∫Áî®Êà∑ÁîªÂÉèÂàÜÊûê': [
                    { name: 'ÁßëÊäÄÂàõ‰∏öËÄÖ', type: 'Áî®Êà∑Áæ§‰Ωì', confidence: 0.95 },
                    { name: 'ÊÇâÂ∞º', type: 'Âú∞ÁêÜ‰ΩçÁΩÆ', confidence: 0.92 },
                    { name: 'LinkedIn', type: 'Âπ≥Âè∞Ê∏†ÈÅì', confidence: 0.89 },
                    { name: 'B2BËê•ÈîÄ', type: '‰∏öÂä°Á±ªÂûã', confidence: 0.87 },
                    { name: 'Êï∞Â≠óËê•ÈîÄÁªèÁêÜ', type: 'Áî®Êà∑ËßíËâ≤', confidence: 0.85 }
                ],
                default: [
                    { name: 'Ê†∏ÂøÉÊ¶ÇÂøµ', type: 'Ê¶ÇÂøµ', confidence: 0.9 },
                    { name: 'ÂÖ≥ÈîÆË¶ÅÁ¥†', type: 'Ë¶ÅÁ¥†', confidence: 0.85 },
                    { name: 'ÂΩ±ÂìçÂõ†Â≠ê', type: 'Âõ†Â≠ê', confidence: 0.8 }
                ]
            };
            
            return entities[title] || entities.default;
        }

        function generateEntityRelationships(title) {
            return [
                { source: 'ÁßëÊäÄÂàõ‰∏öËÄÖ', target: 'ÊÇâÂ∞º', relation: '‰∏ªË¶ÅÂàÜÂ∏É‰∫é', strength: 0.85 },
                { source: 'Êï∞Â≠óËê•ÈîÄÁªèÁêÜ', target: 'LinkedIn', relation: 'È¢ëÁπÅ‰ΩøÁî®', strength: 0.78 },
                { source: 'B2BËê•ÈîÄ', target: 'Êú¨Âú∞ÂåñÁ≠ñÁï•', relation: '‰æùËµñ‰∫é', strength: 0.82 }
            ];
        }

        function generateKeyInsights(title) {
            const insights = {
                'Êæ≥Ê¥≤Â∏ÇÂú∫Áî®Êà∑ÁîªÂÉèÂàÜÊûê': [
                    {
                        insight: 'Âú∞ÁêÜÈõÜ‰∏≠ÊïàÂ∫î',
                        description: 'Êæ≥Ê¥≤B2BÂ∏ÇÂú∫È´òÂ∫¶ÈõÜ‰∏≠Âú®ÊÇâÂ∞º-Â¢®Â∞îÊú¨ËΩ¥Á∫øÔºåÂΩ¢Êàê‰∫ÜÁã¨ÁâπÁöÑÂïÜ‰∏öÁîüÊÄÅÂúà',
                        impact: 'high',
                        actionable: 'Âª∫ËÆÆÂú®Ëøô‰∏§‰∏™ÂüéÂ∏ÇÂª∫Á´ãÊú¨Âú∞ÂåñÂõ¢ÈòüÂíåÂêà‰Ωú‰ºô‰º¥ÂÖ≥Á≥ª'
                    },
                    {
                        insight: 'Êï∞Â≠óÂéüÁîüÁâπÂæÅ',
                        description: 'ÁõÆÊ†áÁî®Êà∑Áæ§‰ΩìÂÖ∑ÊúâÂº∫ÁÉàÁöÑÊï∞Â≠óÂåñÂÅèÂ•ΩÔºåÊõ¥ÂÄæÂêë‰∫éÈÄöËøáÊï∞Â≠óÊ∏†ÈÅìËé∑Âèñ‰ø°ÊÅØ',
                        impact: 'high', 
                        actionable: '‰ºòÂÖàÊäïËµÑÊï∞Â≠óËê•ÈîÄÊ∏†ÈÅìÔºåÁâπÂà´ÊòØLinkedInÂíå‰∏ì‰∏öÁ§æ‰∫§Âπ≥Âè∞'
                    },
                    {
                        insight: 'Êú¨Âú∞ÂåñÊïèÊÑüÂ∫¶',
                        description: 'Êæ≥Ê¥≤Áî®Êà∑ÂØπÊú¨Âú∞ÂåñÂÜÖÂÆπÂíåÊ°à‰æãË°®Áé∞Âá∫ÊòæËëóÂÅèÂ•Ω',
                        impact: 'medium',
                        actionable: 'ÂºÄÂèëÊæ≥Ê¥≤Êú¨Âú∞ÂåñÁöÑÊ°à‰æãÁ†îÁ©∂ÂíåÊàêÂäüÊïÖ‰∫ã'
                    }
                ],
                default: [
                    {
                        insight: 'Ê†∏ÂøÉÊ®°ÂºèËØÜÂà´',
                        description: 'ÈÄöËøáÂõæË∞±ÂàÜÊûêÂèëÁé∞‰∫ÜÂÖ≥ÈîÆÁöÑÊ®°ÂºèÂíåËßÑÂæã',
                        impact: 'high',
                        actionable: 'Âü∫‰∫éÂèëÁé∞ÁöÑÊ®°ÂºèÂà∂ÂÆöÁõ∏Â∫îÁ≠ñÁï•'
                    }
                ]
            };
            
            return insights[title] || insights.default;
        }

        // Removed hardcoded generateRecommendations function
        // Recommendations are now dynamically generated based on actual analysis

        function generateKnowledgeGraphData(title) {
            // This would normally come from the actual GraphRAG processing
            return {
                nodes: 12,
                edges: 18,
                communities: 3,
                centralityScore: 0.76
            };
        }

        function generateNextSteps(title) {
            return [
                { step: 'Â∏ÇÂú∫Ë∞ÉÁ†îÈ™åËØÅ', description: 'È™åËØÅÂàÜÊûêÁªìÊûúÁöÑÂáÜÁ°ÆÊÄß', priority: 'high' },
                { step: 'Á≠ñÁï•Âà∂ÂÆö', description: 'Âü∫‰∫éÊ¥ûÂØüÂà∂ÂÆöÂÖ∑‰ΩìËê•ÈîÄÁ≠ñÁï•', priority: 'high' },
                { step: 'ÂÜÖÂÆπÂàõ‰Ωú', description: 'Âàõ‰ΩúÁ¨¶ÂêàÊæ≥Ê¥≤Â∏ÇÂú∫ÁöÑÊú¨Âú∞ÂåñÂÜÖÂÆπ', priority: 'medium' },
                { step: 'Ê∏†ÈÅì‰ºòÂåñ', description: '‰ºòÂåñLinkedInÁ≠âÂÖ≥ÈîÆÊ∏†ÈÅìÁöÑÊäïÊîæ', priority: 'medium' }
            ];
        }

        // Show GraphRAG Analysis Results
        function showGraphRAGResults(results) {
            // Close knowledge panel first
            toggleKnowledgePanel();
            
            // Create results display modal/panel
            const resultsPanel = document.createElement('div');
            resultsPanel.id = 'graphragResultsPanel';
            resultsPanel.className = 'graphrag-results-panel';
            resultsPanel.style.cssText = `
                position: fixed; top: 0; right: 0; width: 100vw; height: 100vh; 
                background: white; z-index: 5000; overflow-y: auto;
                animation: slideInFromRight 0.5s ease-out;
            `;
            
            resultsPanel.innerHTML = `
                <div style="min-height: 100vh;">
                    <!-- Header -->
                    <div style="
                        background: linear-gradient(135deg, #667eea, #764ba2); 
                        color: white; padding: 30px; position: sticky; top: 0; z-index: 100;
                    ">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <h1 style="margin: 0; font-size: 28px; font-weight: 700;">
                                    üß† GraphRAG Ê∑±Â∫¶Ê¥ûÂØü
                                </h1>
                                <p style="margin: 8px 0 0; opacity: 0.9; font-size: 16px;">
                                    ${results.title} - Êô∫ËÉΩÂàÜÊûêÊä•Âëä
                                </p>
                            </div>
                            <div style="display: flex; gap: 12px; align-items: center;">
                                <button onclick="exportAnalysisResults()" style="
                                    background: rgba(255,255,255,0.2); color: white; border: none;
                                    padding: 10px 16px; border-radius: 8px; cursor: pointer; font-size: 14px;
                                ">üìä ÂØºÂá∫Êä•Âëä</button>
                                <button onclick="closeGraphRAGResults()" style="
                                    background: rgba(255,255,255,0.2); color: white; border: none;
                                    width: 40px; height: 40px; border-radius: 50%; cursor: pointer; font-size: 18px;
                                ">‚úï</button>
                            </div>
                        </div>
                        
                        <!-- Progress Indicator -->
                        <div style="margin-top: 20px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 12px; opacity: 0.8;">ÂàÜÊûêËøõÂ∫¶</span>
                                <span style="font-size: 12px; opacity: 0.8;">100%</span>
                            </div>
                            <div style="background: rgba(255,255,255,0.3); height: 6px; border-radius: 3px; overflow: hidden;">
                                <div style="background: white; height: 100%; width: 100%; border-radius: 3px;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Content -->
                    <div style="padding: 40px;">
                        <!-- Executive Summary -->
                        <section style="margin-bottom: 50px;">
                            <h2 style="color: #1a202c; margin-bottom: 20px; font-size: 22px; font-weight: 600;">
                                üìã ÊâßË°åÊëòË¶Å
                            </h2>
                            <div style="
                                background: #f7fafc; border-left: 4px solid #667eea; 
                                padding: 24px; border-radius: 0 12px 12px 0; margin-bottom: 24px;
                            ">
                                <p style="margin: 0; color: #2d3748; line-height: 1.6; font-size: 16px;">
                                    ${results.summary.overview}
                                </p>
                            </div>
                            
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 16px;">
                                ${results.summary.keyFindings.map(finding => `
                                    <div style="
                                        background: white; border: 1px solid #e2e8f0; 
                                        padding: 16px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                                    ">
                                        <div style="color: #4a5568; font-size: 14px; line-height: 1.5;">
                                            ‚úì ${finding}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </section>

                        <!-- Knowledge Graph Stats -->
                        <section style="margin-bottom: 50px;">
                            <h2 style="color: #1a202c; margin-bottom: 20px; font-size: 22px; font-weight: 600;">
                                üìä Áü•ËØÜÂõæË∞±ÁªüËÆ°
                            </h2>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                                <div style="background: #667eea; color: white; padding: 20px; border-radius: 12px; text-align: center;">
                                    <div style="font-size: 32px; font-weight: bold; margin-bottom: 8px;">${results.knowledgeGraph.nodes}</div>
                                    <div style="font-size: 14px; opacity: 0.9;">ÂÆû‰ΩìËäÇÁÇπ</div>
                                </div>
                                <div style="background: #764ba2; color: white; padding: 20px; border-radius: 12px; text-align: center;">
                                    <div style="font-size: 32px; font-weight: bold; margin-bottom: 8px;">${results.knowledgeGraph.edges}</div>
                                    <div style="font-size: 14px; opacity: 0.9;">ÂÖ≥Á≥ªËøûÊé•</div>
                                </div>
                                <div style="background: #f093fb; color: white; padding: 20px; border-radius: 12px; text-align: center;">
                                    <div style="font-size: 32px; font-weight: bold; margin-bottom: 8px;">${results.knowledgeGraph.communities}</div>
                                    <div style="font-size: 14px; opacity: 0.9;">Á§æÁæ§ÈõÜÁæ§</div>
                                </div>
                                <div style="background: #4facfe; color: white; padding: 20px; border-radius: 12px; text-align: center;">
                                    <div style="font-size: 32px; font-weight: bold; margin-bottom: 8px;">${Math.round((results.knowledgeGraph.centralityScore || 0) * 100)}%</div>
                                    <div style="font-size: 14px; opacity: 0.9;">‰∏≠ÂøÉÂ∫¶ËØÑÂàÜ</div>
                                </div>
                            </div>
                        </section>

                        <!-- Action Buttons -->
                        <section style="text-align: center; padding: 40px 0;">
                            <button onclick="proceedToNextStep()" style="
                                background: linear-gradient(135deg, #667eea, #764ba2); 
                                color: white; border: none; padding: 16px 32px; 
                                border-radius: 12px; font-size: 16px; font-weight: 600; 
                                cursor: pointer; margin-right: 16px; box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
                            ">
                                üöÄ ËøõÂÖ•‰∏ã‰∏ÄÈò∂ÊÆµÔºöÂ∏ÇÂú∫Ë∞ÉÁ†î
                            </button>
                            <button onclick="saveAnalysisResults()" style="
                                background: white; color: #667eea; border: 2px solid #667eea; 
                                padding: 16px 32px; border-radius: 12px; font-size: 16px; 
                                font-weight: 600; cursor: pointer;
                            ">
                                üíæ ‰øùÂ≠òÂàÜÊûêÁªìÊûú
                            </button>
                        </section>
                    </div>
                </div>
            `;
            
            document.body.appendChild(resultsPanel);
        }

        // Helper functions for GraphRAG results panel
        window.closeGraphRAGResults = function() {
            const panel = document.getElementById('graphragResultsPanel');
            if (panel) {
                panel.style.animation = 'slideOutToRight 0.3s ease-in forwards';
                setTimeout(() => {
                    document.body.removeChild(panel);
                }, 300);
            }
        }

        window.exportAnalysisResults = function() {
            showNotification('üìä ÂàÜÊûêÊä•ÂëäÂØºÂá∫ÂäüËÉΩÂºÄÂèë‰∏≠...');
        }

        window.saveAnalysisResults = function() {
            showNotification('üíæ ÂàÜÊûêÁªìÊûúÂ∑≤‰øùÂ≠òÂà∞Áü•ËØÜÂ∫ì');
        }

        window.proceedToNextStep = function() {
            // Update workflow to Research step
            updateActiveStep('research');
            closeGraphRAGResults();
            showNotification('üöÄ Â∑≤ËøõÂÖ•Â∏ÇÂú∫Ë∞ÉÁ†îÈò∂ÊÆµÔºåÂºÄÂßãÂà∂ÂÆöË∞ÉÁ†îÁ≠ñÁï•');
            
            // Show research interface after a delay
            setTimeout(() => {
                showResearchInterface();
            }, 1000);
        }

        function showResearchInterface() {
            // This would open the next phase of the workflow
            // For now, just show a notification
            showNotification('üîç Â∏ÇÂú∫Ë∞ÉÁ†îÁïåÈù¢ÂºÄÂèë‰∏≠... Â∞ÜÂåÖÂê´Ë∞ÉÁ†îÈóÆÂç∑„ÄÅËÆøË∞àÊåáÂçóÁ≠âÂ∑•ÂÖ∑');
        }

        // Add slide out animation
        const additionalStyles = document.createElement('style');
        additionalStyles.textContent = `
            @keyframes slideOutToRight {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
        `;
        document.head.appendChild(additionalStyles);

        // Delete node - make global for onclick access
        window.deleteNode = function(event, buttonElement) {
            console.log('üóëÔ∏è Delete node function called!', event, buttonElement);
            
            try {
                event.stopPropagation();
                const nodeContent = buttonElement.closest('.node-content');
                if (!nodeContent) {
                    console.error('‚ùå Êó†Ê≥ïÊâæÂà∞node-contentÂÖÉÁ¥†');
                    return;
                }
                
                const titleElement = nodeContent.querySelector('.node-title');
                if (!titleElement) {
                    console.error('‚ùå Êó†Ê≥ïÊâæÂà∞node-titleÂÖÉÁ¥†');
                    return;
                }
                
                const title = titleElement.textContent;
                console.log('üóëÔ∏è Attempting to delete:', title);
                
                const treeNode = buttonElement.closest('.tree-node');
                if (!treeNode) {
                    console.error('‚ùå Êó†Ê≥ïÊâæÂà∞tree-nodeÂÖÉÁ¥†');
                    return;
                }
                
                // üîç Ê£ÄÊü•ËäÇÁÇπÊòØÂê¶ÊúâÂéüÂßãÊñá‰ª∂ÂêçÂ±ûÊÄß
                const originalFileName = treeNode.getAttribute('data-file-name');
                console.log('üîç Ê£ÄÊü•Êñá‰ª∂ÂêçÂ±ûÊÄß:');
                console.log('  - ÊòæÁ§∫ÂêçÁß∞:', title);
                console.log('  - ÂéüÂßãÊñá‰ª∂ÂêçÂ±ûÊÄß:', originalFileName);
                console.log('  - Â≠òÂÇ®ÈîÆÂ±ûÊÄß:', treeNode.getAttribute('data-file-storage-key'));
                
                // üîç ÊòæÁ§∫ÊâÄÊúâÂèØËÉΩÁöÑÂ±ûÊÄß
                const allAttributes = {};
                for (let attr of treeNode.attributes) {
                    allAttributes[attr.name] = attr.value;
                }
                console.log('üîç ËäÇÁÇπÊâÄÊúâÂ±ûÊÄß:', allAttributes);
            
                // üî• ‰ΩøÁî®ÂéüÂßãÊñá‰ª∂ÂêçËøõË°åÂà†Èô§ÔºàÂ¶ÇÊûúÂ≠òÂú®ÁöÑËØùÔºâ
                const fileNameToDelete = originalFileName || title;
                console.log('üóëÔ∏è Proceeding with deletion of:', fileNameToDelete);
                
                // üî• Á°ÆÂÆöÊòØÊñá‰ª∂ËøòÊòØÂàÜÁ±ª
                const iconElement = nodeContent.querySelector('.node-icon');
                if (!iconElement) {
                    console.error('‚ùå Êó†Ê≥ïÊâæÂà∞node-iconÂÖÉÁ¥†');
                    return;
                }
                
                const iconText = iconElement.textContent;
                const isFile = iconText.includes('üìÑ') || iconText.includes('üéØ');
                console.log('üóëÔ∏è File type detection - Icon text:', iconText, 'Is file:', isFile);
                
                // üî• Ê†πÊçÆÂ≠òÂÇ®ÁªìÊûÑÂà§Êñ≠ÊòØÊñá‰ª∂ËøòÊòØÂàÜÁ±ª
                const knowledgeTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
                const isCategory = fileNameToDelete in knowledgeTree;
                const isActualFile = Object.values(knowledgeTree).some(category => 
                    category.files && category.files.some(file => file.name === fileNameToDelete)
                );
                
                console.log('üîç ÁúüÂÆûÁ±ªÂûãÂà§Êñ≠:');
                console.log('  - ÊòØÂàÜÁ±ª:', isCategory);
                console.log('  - ÊòØÊñá‰ª∂:', isActualFile);
                console.log('  - ÂõæÊ†áÂà§Êñ≠:', isFile);
                
                if (isCategory && !isActualFile) {
                    // Âà†Èô§ÂàÜÁ±ªÔºöÊ∏ÖÁêÜÊï¥‰∏™ÂàÜÁ±ªÁöÑÊåÅ‰πÖÂåñÊï∞ÊçÆ
                    cleanupCategoryFromPersistentData(fileNameToDelete);
                    console.log('üóëÔ∏è Cleaned up category data for:', fileNameToDelete);
                } else if (isActualFile) {
                    // Âà†Èô§Êñá‰ª∂ÔºöÊ∏ÖÁêÜÊåÅ‰πÖÂåñÊï∞ÊçÆ
                    cleanupFileFromPersistentData(fileNameToDelete);
                    console.log('üóëÔ∏è Cleaned up file data for:', fileNameToDelete);
                } else {
                    console.log('‚ö†Ô∏è Êó†Ê≥ïÁ°ÆÂÆöÁ±ªÂûãÔºåÂ∞ùËØï‰∏§ÁßçÂà†Èô§ÊñπÂºè');
                    cleanupFileFromPersistentData(fileNameToDelete);
                    cleanupCategoryFromPersistentData(fileNameToDelete);
                }
                
                // ‰ªéDOM‰∏≠ÁßªÈô§
                console.log('üóëÔ∏è Removing DOM element for:', title);
                treeNode.remove();
                showNotification(`"${title}" deleted! üóëÔ∏è`);
                console.log('üóëÔ∏è Deletion completed for:', title);
                
            } catch (error) {
                console.error('‚ùå Delete function error:', error);
                alert('Âà†Èô§Âá∫Èîô: ' + error.message);
            }
        }


        function searchKnowledge(query) {
            const nodes = document.querySelectorAll('.tree-node');
            const lowerQuery = query.toLowerCase();
            
            nodes.forEach(node => {
                const title = node.querySelector('.node-title').textContent.toLowerCase();
                const matches = title.includes(lowerQuery);
                node.style.display = matches || !query ? 'block' : 'none';
            });
        }

        function importTemplate(templateType) {
            const templates = {
                marketing: 'Marketing Strategy Template',
                content: 'Content Creation Framework', 
                social: 'Social Media Guide',
                analytics: 'Analytics Template'
            };
            
            showNotification(`${templates[templateType]} imported successfully! üìã`);
        }

        function showNotification(message) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #10b981, #059669);
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                font-size: 14px;
                z-index: 3000;
                animation: slideInRight 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        function editNode(event, element) { event.stopPropagation(); }
        // Export selected knowledge as downloadable files
        window.exportSelectedKnowledge = function() {
            console.log('üì§ exportSelectedKnowledge called!');
            const selectedCheckboxes = document.querySelectorAll('.node-checkbox.selected');
            const selectedCount = selectedCheckboxes.length;
            console.log('üîç Selected checkboxes:', selectedCheckboxes);
            console.log('üîç Selected count:', selectedCount);
            console.log('üîç selectedNodes array:', selectedNodes);
            
            if (selectedCount === 0) {
                console.log('‚ö†Ô∏è No content selected for export');
                showNotification('‚ö†Ô∏è Please select content to export');
                return;
            }
            
            console.log('üì§ Exporting selected knowledge:', selectedNodes);
            
            // Create export data structure
            const exportData = {
                exportedAt: new Date().toISOString(),
                exportedBy: 'CreatorMind AI',
                selectedItems: [],
                totalCount: selectedCount
            };
            
            // Process each selected item
            selectedNodes.forEach(nodeName => {
                const nodeData = selectedNodesData[nodeName] || {};
                const item = {
                    name: nodeName,
                    type: nodeData.type || 'file',
                    content: nodeData.content || getSampleContent(nodeName) || 'No content available',
                    exportedAt: new Date().toISOString()
                };
                exportData.selectedItems.push(item);
            });
            
            // Create and download JSON file
            const jsonContent = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonContent], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            // Create download link
            const link = document.createElement('a');
            link.href = url;
            link.download = `knowledge-export-${new Date().getFullYear()}-${String(new Date().getMonth() + 1).padStart(2, '0')}-${String(new Date().getDate()).padStart(2, '0')}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            showNotification(`üì§ Exported ${selectedCount} items to your downloads folder!`);
            console.log('‚úÖ Export completed successfully');
        }
        
        function useSelectedContent() { showNotification('Selected content added to workflow! ‚ú®'); }

        // GraphRAG Service Integration
        // Multi-Agent System Classes
        class GraphAgent {
            constructor(graphRAGService) {
                this.service = graphRAGService;
                this.agentType = 'graph';
                this.capabilities = ['entity_extraction', 'relationship_mapping', 'graph_traversal'];
            }
            
            async analyze(content, context = {}) {
                console.log('üï∏Ô∏è GraphAgent: Analyzing content structure and relationships');
                
                const entities = await this.extractEntities(content);
                const relationships = await this.mapRelationships(entities, content);
                const graphStructure = await this.buildGraphStructure(entities, relationships);
                
                return {
                    agent: 'GraphAgent',
                    entities,
                    relationships,
                    graphStructure,
                    reasoning: this.generateGraphReasoning(graphStructure),
                    confidence: this.calculateGraphConfidence(entities, relationships)
                };
            }
            
            async extractEntities(content) {
                // ÂÆû‰ΩìÊèêÂèñÈÄªËæë
                const entityTypes = ['PERSON', 'ORG', 'TECH', 'CONCEPT', 'EVENT', 'LOCATION'];
                const entities = [];
                
                // Âü∫‰∫éÂÜÖÂÆπÁ±ªÂûãÂíåÊñá‰ª∂ÂêçÊèêÂèñÂÆû‰Ωì
                if (content.name) {
                    const filename = content.name.toLowerCase();
                    
                    if (filename.includes('api') || filename.includes('service')) {
                        entities.push({ type: 'TECH', value: 'APIÊúçÂä°', confidence: 0.9 });
                    }
                    if (filename.includes('user') || filename.includes('client')) {
                        entities.push({ type: 'CONCEPT', value: 'Áî®Êà∑ÁÆ°ÁêÜ', confidence: 0.8 });
                    }
                    if (filename.includes('data') || filename.includes('model')) {
                        entities.push({ type: 'CONCEPT', value: 'Êï∞ÊçÆÊ®°Âûã', confidence: 0.85 });
                    }
                }
                
                return entities;
            }
            
            async mapRelationships(entities, content) {
                const relationships = [];
                
                // Âü∫‰∫éÂÆû‰ΩìÈó¥ÁöÑËØ≠‰πâÂÖ≥Á≥ªÁîüÊàêËøûÊé•
                for (let i = 0; i < entities.length; i++) {
                    for (let j = i + 1; j < entities.length; j++) {
                        const rel = this.inferRelationship(entities[i], entities[j], content);
                        if (rel) relationships.push(rel);
                    }
                }
                
                return relationships;
            }
            
            inferRelationship(entity1, entity2, content) {
                if (entity1.type === 'TECH' && entity2.type === 'CONCEPT') {
                    return {
                        source: entity1.value,
                        target: entity2.value,
                        type: 'IMPLEMENTS',
                        confidence: 0.7
                    };
                }
                return null;
            }
            
            async buildGraphStructure(entities, relationships) {
                return {
                    nodes: entities.map((e, i) => ({ id: i, label: e.value, type: e.type })),
                    edges: relationships.map((r, i) => ({
                        id: i,
                        source: entities.findIndex(e => e.value === r.source),
                        target: entities.findIndex(e => e.value === r.target),
                        type: r.type
                    }))
                };
            }
            
            generateGraphReasoning(structure) {
                return [
                    `Ê£ÄÊµãÂà∞ ${structure.nodes.length} ‰∏™ÂÆû‰ΩìËäÇÁÇπ`,
                    `ËØÜÂà´‰∫Ü ${structure.edges.length} ‰∏™ÂÖ≥Á≥ªËøûÊé•`,
                    'Âü∫‰∫éÂõæÁªìÊûÑÂàÜÊûê‰∫ÜÂÜÖÂÆπËØ≠‰πâÂÖ≥Á≥ª'
                ];
            }
            
            calculateGraphConfidence(entities, relationships) {
                return Math.min(0.95, 0.6 + (entities.length * 0.05) + (relationships.length * 0.03));
            }
            
            // Êñ∞Â¢ûÔºö‰ªéÊñáÊ°£‰∏≠ÊèêÂèñÂÆû‰ΩìÁöÑÊñπÊ≥ï
            async extractEntitiesFromDocument(file, documentAnalysis) {
                console.log('üï∏Ô∏è GraphAgent: Extracting entities from document');
                
                const content = documentAnalysis.extractedContent || '';
                const fileType = documentAnalysis.fileType?.supportedFormat || 'UNKNOWN';
                
                const entities = await this.extractEntitiesFromContent(content, fileType);
                const relationships = await this.mapRelationships(entities, { name: file.name, content });
                
                return {
                    agent: 'GraphAgent',
                    entities,
                    relationships,
                    confidence: this.calculateGraphConfidence(entities, relationships)
                };
            }
            
            async extractEntitiesFromContent(content, fileType) {
                console.log('üîç GraphAgent: Analyzing content with length:', content.length || content.inferredContent?.length || 0);
                const entities = [];
                
                // Ê£ÄÊü•ÊòØÂê¶ÊòØAIÂàÜÊûêÁöÑÁªìÊûú
                if (content && typeof content === 'object' && content.aiGenerated) {
                    console.log('ü§ñ Using AI-analyzed content for entity extraction');
                    
                    // ‰ªéAIÂÆû‰Ωì‰∏≠ÊèêÂèñ
                    if (content.aiEntities && content.aiEntities.length > 0) {
                        content.aiEntities.forEach(entity => {
                            entities.push({
                                type: 'AI_ENTITY',
                                value: entity,
                                confidence: 0.85
                            });
                        });
                    }
                    
                    // ‰ªéAIÊ¶ÇÂøµ‰∏≠ÊèêÂèñ
                    if (content.aiConcepts && content.aiConcepts.length > 0) {
                        content.aiConcepts.forEach(concept => {
                            entities.push({
                                type: 'AI_CONCEPT', 
                                value: concept,
                                confidence: 0.8
                            });
                        });
                    }
                    
                    // ‰ªéÊé®Êñ≠ÂÜÖÂÆπ‰∏≠ÊèêÂèñÊõ¥Â§öÂÆû‰Ωì
                    if (content.inferredContent) {
                        const inferredEntities = this.extractEntitiesFromText(content.inferredContent);
                        entities.push(...inferredEntities);
                    }
                    
                    return this.deduplicateAndRankEntities(entities);
                }
                
                // Â§ÑÁêÜÊôÆÈÄöÊñáÊú¨ÂÜÖÂÆπ
                const textContent = typeof content === 'string' ? content : content.extractedContent || '';
                
                if (!textContent || textContent.length < 10) {
                    console.warn('‚ö†Ô∏è Content too short or empty, using filename analysis');
                    return [{
                        type: 'FILE',
                        value: 'Empty or short content',
                        confidence: 0.3
                    }];
                }
                
                // Âü∫‰∫éÊñá‰ª∂Á±ªÂûãÁöÑÂÆû‰ΩìËØÜÂà´Ê®°Âºè
                const patterns = this.getEntityPatternsByFileType(fileType);
                
                patterns.forEach(pattern => {
                    const matches = textContent.match(pattern.regex) || [];
                    matches.forEach(match => {
                        let cleanMatch = match.trim();
                        if (pattern.type === 'KEY' && cleanMatch.includes('"')) {
                            // ÊèêÂèñJSON key
                            const keyMatch = cleanMatch.match(/"([^"]+)"/);
                            if (keyMatch) cleanMatch = keyMatch[1];
                        } else if (pattern.type === 'HEADING' && cleanMatch.includes('#')) {
                            // Ê∏ÖÁêÜMarkdownÊ†áÈ¢ò
                            cleanMatch = cleanMatch.replace(/^#+\s*/, '');
                        }
                        
                        if (cleanMatch.length > 1) {
                            entities.push({
                                type: pattern.type,
                                value: cleanMatch,
                                confidence: pattern.confidence
                            });
                        }
                    });
                });
                
                // Âü∫‰∫éÂÖ≥ÈîÆËØçÁöÑÂÆû‰ΩìËØÜÂà´
                const words = textContent.toLowerCase().split(/\s+/).filter(w => w.length > 2);
                const keywords = this.extractKeywords(words);
                console.log('üî§ Extracted keywords:', keywords);
                
                keywords.forEach(keyword => {
                    entities.push({
                        type: 'CONCEPT',
                        value: keyword.toUpperCase(),
                        confidence: 0.7
                    });
                });
                
                // Âü∫‰∫éÂÜÖÂÆπÁ±ªÂûãÁöÑÁâπÊÆäÂÆû‰ΩìÊèêÂèñ
                const contentAnalysis = this.analyzeContentType(textContent);
                if (contentAnalysis.entities) {
                    entities.push(...contentAnalysis.entities);
                }
                
                const finalEntities = this.deduplicateAndRankEntities(entities);
                console.log('‚úÖ Final extracted entities:', finalEntities);
                return finalEntities;
            }
            
            // ‰ªéÊñáÊú¨‰∏≠ÊèêÂèñÂÆû‰ΩìÁöÑËæÖÂä©ÊñπÊ≥ï
            extractEntitiesFromText(text) {
                const entities = [];
                
                // Ê£ÄÊµãÊäÄÊúØËØçÊ±á
                const techTerms = ['API', 'REST', 'Êï∞ÊçÆÂ∫ì', 'ÁÆóÊ≥ï', 'Êú∫Âô®Â≠¶‰π†', '‰∫∫Â∑•Êô∫ËÉΩ', 'Á≥ªÁªü', 'Êû∂ÊûÑ', 'ËÆæËÆ°'];
                techTerms.forEach(term => {
                    if (text.includes(term) && this.isValidEntity(term)) {
                        entities.push({
                            type: 'TECH',
                            value: term,
                            confidence: 0.7
                        });
                    }
                });
                
                // Ê£ÄÊµã‰∏öÂä°ËØçÊ±á
                const businessTerms = ['ÈúÄÊ±Ç', 'Áî®Êà∑', '‰∫ßÂìÅ', 'ÂäüËÉΩ', 'ÊµÅÁ®ã', 'ÁÆ°ÁêÜ', 'ÂàÜÊûê', 'Êä•Âëä'];
                businessTerms.forEach(term => {
                    if (text.includes(term) && this.isValidEntity(term)) {
                        entities.push({
                            type: 'BUSINESS',
                            value: term,
                            confidence: 0.6
                        });
                    }
                });
                
                return entities;
            }
            
            analyzeContentType(content) {
                const entities = [];
                const lowercaseContent = content.toLowerCase();
                
                // Ê£ÄÊµãÊäÄÊúØÁõ∏ÂÖ≥ÂÜÖÂÆπ
                const techTerms = [
                    'api', 'database', 'server', 'client', 'framework', 'library', 
                    'algorithm', 'data structure', 'machine learning', 'artificial intelligence',
                    'frontend', 'backend', 'fullstack', 'microservice', 'docker', 'kubernetes'
                ];
                
                techTerms.forEach(term => {
                    if (lowercaseContent.includes(term)) {
                        entities.push({
                            type: 'TECH_TERM',
                            value: term.toUpperCase(),
                            confidence: 0.8
                        });
                    }
                });
                
                // Ê£ÄÊµã‰∫∫ÂêçÔºàÁÆÄÂçïÊ®°ÂºèÔºâ
                const namePattern = /\b[A-Z][a-z]+\s+[A-Z][a-z]+\b/g;
                const names = content.match(namePattern) || [];
                names.forEach(name => {
                    entities.push({
                        type: 'PERSON',
                        value: name,
                        confidence: 0.6
                    });
                });
                
                // Ê£ÄÊµãÊó•Êúü
                const datePattern = /\b\d{4}-\d{2}-\d{2}\b|\b\d{1,2}\/\d{1,2}\/\d{4}\b/g;
                const dates = content.match(datePattern) || [];
                dates.forEach(date => {
                    entities.push({
                        type: 'DATE',
                        value: date,
                        confidence: 0.9
                    });
                });
                
                return { entities };
            }
            
            getEntityPatternsByFileType(fileType) {
                const commonPatterns = [
                    { type: 'EMAIL', regex: /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, confidence: 0.9 },
                    { type: 'URL', regex: /https?:\/\/[^\s]+/g, confidence: 0.8 },
                    { type: 'TECH', regex: /\b(API|REST|GraphQL|React|Node\.js|Python|JavaScript|SQL|NoSQL|Docker|Kubernetes)\b/gi, confidence: 0.8 }
                ];
                
                const typeSpecificPatterns = {
                    'JSON': [
                        { type: 'KEY', regex: /"([^"]+)":/g, confidence: 0.6 }
                    ],
                    'CSV': [
                        { type: 'COLUMN', regex: /^[^,\n]+/gm, confidence: 0.7 }
                    ],
                    'MD': [
                        { type: 'HEADING', regex: /^#+\s+(.+)$/gm, confidence: 0.8 }
                    ]
                };
                
                return [...commonPatterns, ...(typeSpecificPatterns[fileType] || [])];
            }
            
            extractKeywords(words) {
                const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were']);
                const wordFreq = {};
                
                words.forEach(word => {
                    if (word.length > 3 && !stopWords.has(word)) {
                        wordFreq[word] = (wordFreq[word] || 0) + 1;
                    }
                });
                
                return Object.entries(wordFreq)
                    .filter(([word, freq]) => freq >= 2)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 10)
                    .map(([word]) => word);
            }
            
            deduplicateAndRankEntities(entities) {
                const entityMap = new Map();
                
                entities.forEach(entity => {
                    const key = `${entity.type}:${entity.value.toLowerCase()}`;
                    const existing = entityMap.get(key);
                    
                    if (!existing || entity.confidence > existing.confidence) {
                        entityMap.set(key, entity);
                    }
                });
                
                return Array.from(entityMap.values())
                    .sort((a, b) => b.confidence - a.confidence)
                    .slice(0, 20);
            }
        }
        
        class HybridAgent {
            constructor(graphRAGService) {
                this.service = graphRAGService;
                this.agentType = 'hybrid';
                this.capabilities = ['multi_modal_analysis', 'context_fusion', 'semantic_reasoning'];
            }
            
            async analyze(content, context = {}) {
                console.log('üîÑ HybridAgent: Performing multi-modal hybrid analysis');
                
                const textAnalysis = await this.analyzeTextContent(content);
                const structuralAnalysis = await this.analyzeStructure(content);
                const semanticAnalysis = await this.performSemanticReasoning(content, context);
                
                const fusedResults = await this.fuseAnalyses([textAnalysis, structuralAnalysis, semanticAnalysis]);
                
                return {
                    agent: 'HybridAgent',
                    textAnalysis,
                    structuralAnalysis,
                    semanticAnalysis,
                    fusedResults,
                    reasoning: this.generateHybridReasoning(fusedResults),
                    confidence: this.calculateHybridConfidence(fusedResults)
                };
            }
            
            async analyzeTextContent(content) {
                return {
                    contentType: this.detectContentType(content),
                    complexity: this.assessComplexity(content),
                    topics: this.extractTopics(content)
                };
            }
            
            async analyzeStructure(content) {
                return {
                    fileStructure: this.analyzeFileStructure(content),
                    organizationalPattern: this.detectOrganizationPattern(content),
                    dependencies: this.inferDependencies(content)
                };
            }
            
            async performSemanticReasoning(content, context) {
                return {
                    contextualRelevance: this.calculateContextRelevance(content, context),
                    semanticSimilarity: this.findSemanticSimilarities(content),
                    conceptualMapping: this.mapConcepts(content)
                };
            }
            
            async fuseAnalyses(analyses) {
                return {
                    combinedInsights: this.combineInsights(analyses),
                    crossModalConnections: this.findCrossModalConnections(analyses),
                    emergentPatterns: this.identifyEmergentPatterns(analyses)
                };
            }
            
            detectContentType(content) {
                const filename = content.name?.toLowerCase() || '';
                if (filename.includes('api')) return 'APIÊñáÊ°£';
                if (filename.includes('config')) return 'ÈÖçÁΩÆÊñá‰ª∂';
                if (filename.includes('data')) return 'Êï∞ÊçÆÊñá‰ª∂';
                return 'ÈÄöÁî®ÂÜÖÂÆπ';
            }
            
            generateHybridReasoning(results) {
                return [
                    'ÊâßË°å‰∫ÜÂ§öÊ®°ÊÄÅÂÜÖÂÆπÂàÜÊûê',
                    `ËûçÂêà‰∫ÜÊñáÊú¨„ÄÅÁªìÊûÑÂíåËØ≠‰πâ‰∏â‰∏™Áª¥Â∫¶ÁöÑÂàÜÊûêÁªìÊûú`,
                    `ËØÜÂà´Âá∫ ${results.crossModalConnections?.length || 0} ‰∏™Ë∑®Ê®°ÊÄÅËøûÊé•`,
                    'ÁîüÊàê‰∫ÜÁªºÂêàÊÄßÁöÑÁêÜËß£Ê°ÜÊû∂'
                ];
            }
            
            calculateHybridConfidence(results) {
                const baseConfidence = 0.75;
                const insightBonus = (results.combinedInsights?.length || 0) * 0.02;
                const connectionBonus = (results.crossModalConnections?.length || 0) * 0.03;
                return Math.min(0.98, baseConfidence + insightBonus + connectionBonus);
            }
            
            // Helper methods for HybridAgent
            assessComplexity(content) {
                return 'medium';
            }
            
            extractTopics(content) {
                return ['content analysis', 'file processing'];
            }
            
            analyzeFileStructure(content) {
                return 'standard file structure';
            }
            
            detectOrganizationPattern(content) {
                return 'hierarchical';
            }
            
            inferDependencies(content) {
                return [];
            }
            
            calculateContextRelevance(content, context) {
                return 0.8;
            }
            
            findSemanticSimilarities(content) {
                return [];
            }
            
            mapConcepts(content) {
                return {};
            }
            
            combineInsights(analyses) {
                return ['Combined multi-modal insights'];
            }
            
            findCrossModalConnections(analyses) {
                return ['Text-Structure connection', 'Structure-Semantic connection'];
            }
            
            identifyEmergentPatterns(analyses) {
                return ['Emergent pattern detected'];
            }
            
            // Êñ∞Â¢ûÔºö‰ªéÊñáÊ°£‰∏≠ÊèêÂèñÂÆû‰ΩìÁöÑÊñπÊ≥ï
            async extractEntitiesFromDocument(file, documentAnalysis) {
                console.log('üîÑ HybridAgent: Extracting entities from document');
                
                const textAnalysis = await this.analyzeTextContent({ name: file.name, content: documentAnalysis.extractedContent });
                const structuralAnalysis = await this.analyzeStructure({ name: file.name, structure: documentAnalysis.documentStructure });
                
                const entities = this.extractEntitiesFromAnalysis(textAnalysis, structuralAnalysis);
                
                return {
                    agent: 'HybridAgent',
                    entities,
                    relationships: [],
                    confidence: this.calculateHybridConfidence({ combinedInsights: entities, crossModalConnections: [] })
                };
            }
            
            extractEntitiesFromAnalysis(textAnalysis, structuralAnalysis) {
                const entities = [];
                
                // ‰ªéÊñáÊú¨ÂàÜÊûê‰∏≠ÊèêÂèñÂÆû‰Ωì
                if (textAnalysis.topics) {
                    textAnalysis.topics.forEach(topic => {
                        entities.push({
                            type: 'TOPIC',
                            value: topic,
                            confidence: 0.7,
                            source: 'text_analysis'
                        });
                    });
                }
                
                // ‰ªéÁªìÊûÑÂàÜÊûê‰∏≠ÊèêÂèñÂÆû‰Ωì
                if (structuralAnalysis.organizationalPattern) {
                    entities.push({
                        type: 'PATTERN',
                        value: structuralAnalysis.organizationalPattern,
                        confidence: 0.6,
                        source: 'structural_analysis'
                    });
                }
                
                return entities;
            }
        }
        
        class DeepResearchAgent {
            constructor(graphRAGService) {
                this.service = graphRAGService;
                this.agentType = 'deep_research';
                this.capabilities = ['deep_analysis', 'research_synthesis', 'insight_generation'];
            }
            
            async analyze(content, context = {}) {
                console.log('üîç DeepResearchAgent: Conducting deep research analysis');
                
                const domainAnalysis = await this.analyzeDomain(content);
                const knowledgeExtraction = await this.extractKnowledge(content, context);
                const insightGeneration = await this.generateDeepInsights(content, domainAnalysis, knowledgeExtraction);
                const researchSynthesis = await this.synthesizeResearch(insightGeneration);
                
                return {
                    agent: 'DeepResearchAgent',
                    domainAnalysis,
                    knowledgeExtraction,
                    insightGeneration,
                    researchSynthesis,
                    reasoning: this.generateResearchReasoning(researchSynthesis),
                    confidence: this.calculateResearchConfidence(researchSynthesis)
                };
            }
            
            async analyzeDomain(content) {
                return {
                    domain: this.identifyDomain(content),
                    expertise_level: this.assessExpertiseLevel(content),
                    domain_entities: this.extractDomainEntities(content),
                    technical_complexity: this.assessTechnicalComplexity(content)
                };
            }
            
            async extractKnowledge(content, context) {
                return {
                    key_concepts: this.extractKeyConcepts(content),
                    methodologies: this.identifyMethodologies(content),
                    best_practices: this.inferBestPractices(content),
                    potential_issues: this.identifyPotentialIssues(content)
                };
            }
            
            async generateDeepInsights(content, domainAnalysis, knowledgeExtraction) {
                const insights = [];
                
                // Âü∫‰∫éÈ¢ÜÂüüÂàÜÊûêÁîüÊàêÊ¥ûÂØü
                if (domainAnalysis.technical_complexity === 'high') {
                    insights.push('ËØ•ÂÜÖÂÆπÊ∂âÂèäÈ´òÊäÄÊúØÂ§çÊùÇÂ∫¶ÔºåÈúÄË¶Å‰∏ì‰∏öÁü•ËØÜÁêÜËß£');
                }
                
                // Âü∫‰∫éÁü•ËØÜÊèêÂèñÁîüÊàêÊ¥ûÂØü
                if (knowledgeExtraction.methodologies?.length > 0) {
                    insights.push(`ËØÜÂà´‰∫Ü ${knowledgeExtraction.methodologies.length} ÁßçÊñπÊ≥ïËÆ∫`);
                }
                
                return {
                    insights,
                    impact_assessment: this.assessImpact(content),
                    future_implications: this.predictFutureImplications(content),
                    recommendations: this.generateRecommendations(content)
                };
            }
            
            async synthesizeResearch(insights) {
                return {
                    synthesis_summary: this.createSynthesisSummary(insights),
                    key_findings: this.extractKeyFindings(insights),
                    research_gaps: this.identifyResearchGaps(insights),
                    actionable_outcomes: this.generateActionableOutcomes(insights)
                };
            }
            
            identifyDomain(content) {
                const filename = content.name?.toLowerCase() || '';
                if (filename.includes('ai') || filename.includes('ml')) return 'AI/Êú∫Âô®Â≠¶‰π†';
                if (filename.includes('web') || filename.includes('html')) return 'WebÂºÄÂèë';
                if (filename.includes('data')) return 'Êï∞ÊçÆÁßëÂ≠¶';
                return 'ÈÄöÁî®ÊäÄÊúØ';
            }
            
            generateResearchReasoning(synthesis) {
                return [
                    'ËøõË°å‰∫ÜÊ∑±Â∫¶È¢ÜÂüüÂàÜÊûê',
                    'ÊèêÂèñ‰∫ÜÊ†∏ÂøÉÁü•ËØÜË¶ÅÁ¥†',
                    'ÁîüÊàê‰∫ÜÊ∑±Â±ÇÊ¨°Ê¥ûÂØü',
                    `ÁªºÂêàÂàÜÊûêÂèëÁé∞‰∫Ü ${synthesis.key_findings?.length || 0} ‰∏™ÂÖ≥ÈîÆÂèëÁé∞`,
                    'ÂΩ¢Êàê‰∫ÜÂèØÊìç‰ΩúÁöÑÁ†îÁ©∂ÊàêÊûú'
                ];
            }
            
            calculateResearchConfidence(synthesis) {
                const baseConfidence = 0.8;
                const findingsBonus = (synthesis.key_findings?.length || 0) * 0.025;
                const actionableBonus = (synthesis.actionable_outcomes?.length || 0) * 0.02;
                return Math.min(0.99, baseConfidence + findingsBonus + actionableBonus);
            }
            
            // Helper methods for DeepResearchAgent
            assessExpertiseLevel(content) {
                return 'intermediate';
            }
            
            extractDomainEntities(content) {
                return ['ÊäÄÊúØÂÆû‰Ωì', 'Ê¶ÇÂøµÂÆû‰Ωì'];
            }
            
            assessTechnicalComplexity(content) {
                const filename = content.name?.toLowerCase() || '';
                if (filename.includes('ai') || filename.includes('ml') || filename.includes('algorithm')) {
                    return 'high';
                } else if (filename.includes('api') || filename.includes('service')) {
                    return 'medium';
                }
                return 'low';
            }
            
            extractKeyConcepts(content) {
                return ['Ê†∏ÂøÉÊ¶ÇÂøµ1', 'Ê†∏ÂøÉÊ¶ÇÂøµ2'];
            }
            
            identifyMethodologies(content) {
                return ['ÊñπÊ≥ïËÆ∫A', 'ÊñπÊ≥ïËÆ∫B'];
            }
            
            inferBestPractices(content) {
                return ['ÊúÄ‰Ω≥ÂÆûË∑µ1', 'ÊúÄ‰Ω≥ÂÆûË∑µ2'];
            }
            
            identifyPotentialIssues(content) {
                return ['ÊΩúÂú®ÈóÆÈ¢ò1', 'ÊΩúÂú®ÈóÆÈ¢ò2'];
            }
            
            assessImpact(content) {
                return 'medium impact';
            }
            
            predictFutureImplications(content) {
                return ['Future implication 1', 'Future implication 2'];
            }
            
            generateRecommendations(content) {
                return ['Recommendation 1', 'Recommendation 2'];
            }
            
            createSynthesisSummary(insights) {
                return 'ÁªºÂêàÂàÜÊûêÊÄªÁªì';
            }
            
            extractKeyFindings(insights) {
                return ['ÂÖ≥ÈîÆÂèëÁé∞1', 'ÂÖ≥ÈîÆÂèëÁé∞2', 'ÂÖ≥ÈîÆÂèëÁé∞3'];
            }
            
            identifyResearchGaps(insights) {
                return ['Á†îÁ©∂Áº∫Âè£1', 'Á†îÁ©∂Áº∫Âè£2'];
            }
            
            generateActionableOutcomes(insights) {
                return ['ÂèØÊìç‰ΩúÊàêÊûú1', 'ÂèØÊìç‰ΩúÊàêÊûú2'];
            }
            
            // Êñ∞Â¢ûÔºö‰ªéÊñáÊ°£‰∏≠ÊèêÂèñÂÆû‰ΩìÁöÑÊñπÊ≥ï
            async extractEntitiesFromDocument(file, documentAnalysis) {
                console.log('üîç DeepResearchAgent: Extracting entities from document');
                
                const domain = this.identifyDomain({ name: file.name, content: documentAnalysis.extractedContent });
                const domainEntities = this.extractDomainEntities({ name: file.name });
                const keyConcepts = this.extractKeyConcepts({ name: file.name, content: documentAnalysis.extractedContent });
                
                const entities = [
                    ...domainEntities.map(entity => ({ type: 'DOMAIN', value: entity, confidence: 0.8 })),
                    ...keyConcepts.map(concept => ({ type: 'CONCEPT', value: concept, confidence: 0.7 }))
                ];
                
                return {
                    agent: 'DeepResearchAgent',
                    entities,
                    relationships: [],
                    confidence: this.calculateResearchConfidence({ key_findings: entities, actionable_outcomes: [] })
                };
            }
        }

        class GraphRAGService {
            constructor() {
                this.baseUrl = 'http://127.0.0.1:8001/api'; // GraphRAG‰ª£ÁêÜÊúçÂä°
                this.isConnected = true; // üî• Âº∫Âà∂ÂêØÁî®Êú¨Âú∞ÊúçÂä°
                console.log('üöÄ GraphRAGÊúçÂä°Â∑≤ÂêØÁî®ÔºåURL:', this.baseUrl);
                // this.checkServiceHealth(); // ÂêØÂä®Êó∂Ê£ÄÊü•ÊúçÂä°ÂÅ•Â∫∑Áä∂ÊÄÅ
                
                // ÂàùÂßãÂåñÂ§öÊô∫ËÉΩ‰ΩìÁ≥ªÁªü
                this.graphAgent = new GraphAgent(this);
                this.hybridAgent = new HybridAgent(this);
                this.deepResearchAgent = new DeepResearchAgent(this);
                
                // ÊîØÊåÅÁöÑÊñá‰ª∂Ê†ºÂºè
                this.supportedFormats = {
                    'text/plain': 'TXT',
                    'application/pdf': 'PDF', 
                    'text/markdown': 'MD',
                    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'DOCX',
                    'application/msword': 'DOC',
                    'text/csv': 'CSV',
                    'application/json': 'JSON',
                    'application/x-yaml': 'YAML',
                    'text/yaml': 'YML'
                };
                
                this.checkConnection();
            }
            
            // Ê£ÄÊü•GraphRAGÊúçÂä°ÂÅ•Â∫∑Áä∂ÊÄÅ
            async checkServiceHealth() {
                try {
                    console.log('üîç Ê£ÄÊü•GraphRAGÊúçÂä°Áä∂ÊÄÅ...');
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10ÁßíË∂ÖÊó∂
                    
                    const response = await fetch(`${this.baseUrl}/auth/profile`, {
                        method: 'GET',
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('‚úÖ GraphRAGÊúçÂä°Ê≠£Â∏∏:', result);
                        this.isConnected = true;
                        return true;
                    } else {
                        throw new Error(`ÂÅ•Â∫∑Ê£ÄÊü•Â§±Ë¥•: ${response.status}`);
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è GraphRAGÊúçÂä°‰∏çÂèØÁî®:', error.message);
                    console.warn('üìã Â∞Ü‰ΩøÁî®Â§áÁî®ÂàÜÊûêÁ≥ªÁªü');
                    this.isConnected = false;
                    return false;
                }
            }
            
            // Êñ∞Â¢ûÔºöÂç≥Êó∂Êñá‰ª∂ÂÜÖÂÆπÂàÜÊûê
            async analyzeFileOnUpload(file) {
                // üö® DEBUG: GraphRAG Service ÂáΩÊï∞ÂÖ•Âè£ËøΩË∏™
                console.log('üö® DEBUG: ======= GraphRAG Service analyzeFileOnUpload ÂáΩÊï∞Ë¢´Ë∞ÉÁî® =======');
                console.log('üö® DEBUG: ‰º†ÂÖ•ÁöÑFileÂØπË±°ËØ¶ÁªÜ‰ø°ÊÅØ:');
                console.log('üö® DEBUG: - FileÂêçÁß∞:', file.name);
                console.log('üö® DEBUG: - FileÂ§ßÂ∞è:', file.size, 'Â≠óËäÇ');
                console.log('üö® DEBUG: - FileÁ±ªÂûã:', file.type);
                console.log('üö® DEBUG: - FileÊûÑÈÄ†Âô®:', file.constructor.name);
                console.log('üö® DEBUG: - FileÂØπË±°ÂÆåÊï¥‰ø°ÊÅØ:', file);
                
                // üö® DEBUG: Ê£ÄÊü•FileÂØπË±°ÁöÑËá™ÂÆö‰πâÂ±ûÊÄß
                if (file.sourceUrl) {
                    console.log('üö® DEBUG: - Ê£ÄÊµãÂà∞sourceUrl:', file.sourceUrl);
                    console.log('üö® DEBUG: - ËøôÊòØ‰ªéURLÂàõÂª∫ÁöÑFileÂØπË±°ÔºÅ');
                    if (file.sourceUrl.includes('youtube.com') || file.sourceUrl.includes('youtu.be')) {
                        console.log('üö® DEBUG: ‚ö†Ô∏è  ÂÖ≥ÈîÆÂèëÁé∞ÔºöËøôÊòØYouTube URLÁöÑFileÂØπË±°ÔºÅ');
                        console.log('üö® DEBUG: ‚ö†Ô∏è  ÊúüÊúõÔºöÁ≥ªÁªüÂ∫îËØ•Ê£ÄÊµãÂà∞ËøôÊòØËßÜÈ¢ëÂÜÖÂÆπÂπ∂Ë∞ÉÁî®ËßÜÈ¢ëÊèêÂèñÁÆ°ÈÅì');
                        console.log('üö® DEBUG: ‚ö†Ô∏è  ÈóÆÈ¢òÔºöÂ¶ÇÊûúÁ≥ªÁªüÊääÂÆÉÂΩì‰ΩúÊôÆÈÄöHTMLÊñá‰ª∂Â§ÑÁêÜÔºåÂ∞±‰ºöÂá∫Áé∞ÂÜÖÂÆπ‰∏çÊ≠£Á°ÆÁöÑÈóÆÈ¢ò');
                    }
                }
                if (file.title) {
                    console.log('üö® DEBUG: - Ê£ÄÊµãÂà∞title:', file.title);
                }
                
                // üö® DEBUG: È¢ÑËØªÂèñFileÂÜÖÂÆπËøõË°åÂàÜÊûê
                try {
                    const fileText = await file.text();
                    console.log('üö® DEBUG: - FileÂÜÖÂÆπÈïøÂ∫¶:', fileText.length);
                    console.log('üö® DEBUG: - FileÂÜÖÂÆπÈ¢ÑËßàÔºàÂâç200Â≠óÁ¨¶Ôºâ:', fileText.substring(0, 200));
                    
                    // Ê£ÄÊü•ÊòØÂê¶ÊòØYouTube URLÂÜÖÂÆπ
                    if (fileText.includes('youtube.com') && fileText.length < 200) {
                        console.log('üö® DEBUG: ‚ö†Ô∏è  ÂÖ≥ÈîÆÂèëÁé∞ÔºöFileÂÜÖÂÆπÊòØÁÆÄÁü≠ÁöÑYouTube URLÔºÅ');
                        console.log('üö® DEBUG: ‚ö†Ô∏è  ËøôË°®ÊòéFileÂØπË±°ÂèØËÉΩÂåÖÂê´URLËÄå‰∏çÊòØÊèêÂèñÁöÑÂÜÖÂÆπ');
                    }
                    
                    // Ê£ÄÊü•ÊòØÂê¶ÊòØHTMLÈ°µÈù¢ÂÜÖÂÆπ  
                    if (fileText.includes('<html') || fileText.includes('<!DOCTYPE') || 
                        fileText.includes('ÂÖ≥‰∫é Êñ∞Èóª ÁâàÊùÉ')) {
                        console.log('üö® DEBUG: ‚ö†Ô∏è  ÂÖ≥ÈîÆÂèëÁé∞ÔºöFileÂÜÖÂÆπÊòØHTMLÈ°µÈù¢ÂÜÖÂÆπÔºÅ');
                        console.log('üö® DEBUG: ‚ö†Ô∏è  ËøôÂèØËÉΩÂ∞±ÊòØÈóÆÈ¢òÊâÄÂú®ÔºöYouTube URLË¢´ÂΩì‰ΩúHTMLÈ°µÈù¢Â§ÑÁêÜ');
                    }
                } catch (textError) {
                    console.log('üö® DEBUG: - Êó†Ê≥ïÈ¢ÑËØªÂèñFileÂÜÖÂÆπ:', textError);
                }
                
                console.log('üö® DEBUG: Âç≥Â∞ÜËøõÂÖ•ÂáΩÊï∞‰∏ªË¶ÅÈÄªËæë...');
                console.log('üöÄ ÂºÄÂßãÊñá‰ª∂ÂàÜÊûê:', file.name);
                
                // Â¶ÇÊûúÊúçÂä°Êú™ËøûÊé•ÔºåÂÖàÂ∞ùËØïÈáçÊñ∞ËøûÊé•
                if (!this.isConnected) {
                    console.log('üîÑ ÊúçÂä°Êú™ËøûÊé•ÔºåÂ∞ùËØïÈáçÊñ∞ËøûÊé•...');
                    await this.checkServiceHealth();
                }
                
                try {
                    // üöÄ ‰ºòÂÖà‰ΩøÁî®GraphRAG AgentÁöÑÁúüÊ≠£ËÉΩÂäõ
                    if (this.isConnected) {
                        console.log('üîó ‰ΩøÁî®GraphRAG AgentËøõË°å‰∏ì‰∏öÂàÜÊûê');
                        return await this.useGraphRAGAgent(file);
                    }
                    
                    // üîÑ GraphRAGÁ¶ªÁ∫øÊó∂ÁöÑÈ´òË¥®ÈáèÂ§áÁî®ÊñπÊ°à
                    console.log('‚ö†Ô∏è GraphRAG AgentÁ¶ªÁ∫øÔºå‰ΩøÁî®ÂÜÖÁΩÆAIÂàÜÊûê');
                    
                    // Á¨¨‰∏ÄÊ≠•ÔºöËØªÂèñÊñá‰ª∂ÁúüÂÆûÂÜÖÂÆπ
                    let fileContent = '';
                    if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {
                        // üî• ‰ΩøÁî®PDF.jsÊèêÂèñÁúüÂÆûPDFÂÜÖÂÆπ
                        console.log('üìÑ ÂºÄÂßãÊèêÂèñPDFÁúüÂÆûÂÜÖÂÆπ...');
                        try {
                            fileContent = await this.extractPDFText(file);
                            console.log('‚úÖ PDFÂÜÖÂÆπÊèêÂèñÊàêÂäüÔºåÈïøÂ∫¶:', fileContent.length);
                        } catch (pdfError) {
                            console.log('‚ùå PDFÊèêÂèñÂ§±Ë¥•Ôºå‰ΩøÁî®Êñá‰ª∂ÂêçÂàÜÊûê:', pdfError.message);
                            fileContent = `PDFÊñá‰ª∂: ${file.name}`;
                        }
                    } else {
                        try {
                            fileContent = await this.readTextFile(file);
                            console.log('‚úÖ Êñá‰ª∂ÂÜÖÂÆπËØªÂèñÊàêÂäüÔºåÈïøÂ∫¶:', fileContent.length);
                        } catch (error) {
                            console.log('‚ùå Êñá‰ª∂ËØªÂèñÂ§±Ë¥•:', error.message);
                            fileContent = `Êñá‰ª∂: ${file.name}`;
                        }
                    }
                    
                    // Á¨¨‰∫åÊ≠•ÔºöGPT-5 nanoÊô∫ËÉΩÂàÜÊûê
                    const intelligentAnalysis = await this.analyzeFileContent(file, fileContent);
                    
                    // Á¨¨‰∏âÊ≠•ÔºöÊûÑÂª∫ËøîÂõûÁªìÊûú
                    return {
                        fileName: file.name,
                        fileType: this.identifyFileType(file),
                        fileSize: file.size,
                        analysisTimestamp: new Date().toISOString(),
                        extractedContent: intelligentAnalysis.content,
                        concepts: intelligentAnalysis.concepts || [],
                        entities: intelligentAnalysis.entities || [],
                        relationships: intelligentAnalysis.relationships || [],
                        positionSuggestion: {
                            primarySuggestion: {
                                path: intelligentAnalysis.knowledgeTreeSuggestion,
                                confidence: intelligentAnalysis.confidence
                            },
                            alternatives: [] // GPT-5 nano‰ºöÁªôÂá∫ÊúÄ‰Ω≥Âª∫ËÆÆ
                        },
                        processingStage: 'completed',
                        confidence: intelligentAnalysis.confidence
                    };
                    
                } catch (error) {
                    console.error('‚ùå Êñá‰ª∂ÂàÜÊûêÂ§±Ë¥•:', error);
                    return {
                        fileName: file.name,
                        fileType: this.identifyFileType(file),
                        fileSize: file.size,
                        extractedContent: `ÂàÜÊûêÂ§±Ë¥•: ${file.name}`,
                        concepts: [],
                        entities: [],
                        positionSuggestion: {
                            primarySuggestion: {
                                path: 'Êú™ÂàÜÁ±ª',
                                confidence: 0.3
                            },
                            alternatives: []
                        },
                        processingStage: 'failed',
                        error: error.message
                    };
                }
            }
            
            // ËØÜÂà´Êñá‰ª∂Á±ªÂûã
            identifyFileType(file) {
                const mimeType = file.type;
                const extension = file.name.split('.').pop()?.toLowerCase();
                
                return {
                    mimeType,
                    extension,
                    supportedFormat: this.supportedFormats[mimeType] || extension?.toUpperCase() || 'UNKNOWN',
                    isSupported: !!this.supportedFormats[mimeType] || ['txt', 'md', 'csv', 'json', 'yml', 'yaml'].includes(extension)
                };
            }
            
            // Â§öÊ†ºÂºèÊñáÊ°£Â§ÑÁêÜ
            async processMultiFormatDocument(file) {
                console.log('üìÑ Processing multi-format document:', file.name);
                
                const fileType = this.identifyFileType(file);
                
                if (!fileType.isSupported) {
                    throw new Error(`Unsupported file format: ${fileType.supportedFormat}`);
                }
                
                let extractedContent = '';
                let documentStructure = {};
                
                try {
                    // Áªü‰∏ÄÊñá‰ª∂Â§ÑÁêÜÊµÅÁ®ã - ËØªÂèñÂÜÖÂÆπÂêéÁî®GPT-4oÊô∫ËÉΩÂàÜÊûê
                    console.log('üìÑ Áªü‰∏ÄÂ§ÑÁêÜÊñá‰ª∂:', file.name, file.type);
                    
                    // Á¨¨‰∏ÄÊ≠•ÔºöËØªÂèñÊñá‰ª∂ÂÜÖÂÆπ
                    if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {
                        // PDFÊñá‰ª∂ÈúÄË¶ÅÁâπÊÆäÂ§ÑÁêÜÔºàÁõÆÂâç‰ΩøÁî®Êñá‰ª∂ÂêçÂàÜÊûêÔºåÂèØ‰ª•ÈõÜÊàêPDF.jsÔºâ
                        extractedContent = `PDFÊñá‰ª∂: ${file.name}`;
                        console.log('üìÑ PDFÊñá‰ª∂Â∞Ü‰ΩøÁî®Êñá‰ª∂ÂêçËøõË°åÊô∫ËÉΩÂàÜÊûê');
                    } else {
                        // ÂÖ∂‰ªñÊñá‰ª∂Á±ªÂûãÔºöTXT, MD, JSON, CSVÁ≠âÈÉΩÂ∞ùËØï‰Ωú‰∏∫ÊñáÊú¨ËØªÂèñ
                        try {
                            extractedContent = await this.readTextFile(file);
                            console.log('‚úÖ Êñá‰ª∂ÂÜÖÂÆπËØªÂèñÊàêÂäüÔºåÈïøÂ∫¶:', extractedContent.length);
                        } catch (readError) {
                            console.log('‚ùå Êñá‰ª∂ÂÜÖÂÆπËØªÂèñÂ§±Ë¥•Ôºå‰ΩøÁî®Êñá‰ª∂ÂêçÂàÜÊûê:', readError.message);
                            extractedContent = `Êñá‰ª∂: ${file.name}`;
                        }
                    }
                    
                    // Á¨¨‰∫åÊ≠•Ôºö‰ΩøÁî®GPT-4oËøõË°åÊô∫ËÉΩÂÜÖÂÆπÂàÜÊûê
                    const intelligentAnalysis = await this.analyzeFileContent(file, extractedContent);
                    
                    // Á¨¨‰∏âÊ≠•ÔºöÊûÑÂª∫Áªü‰∏ÄÁöÑÊñáÊ°£ÁªìÊûÑ
                    documentStructure = {
                        type: 'intelligent_analysis',
                        concepts: intelligentAnalysis.concepts || [],
                        entities: intelligentAnalysis.entities || [],
                        relationships: intelligentAnalysis.relationships || [],
                        summary: intelligentAnalysis.content,
                        knowledgeTreeSuggestion: intelligentAnalysis.knowledgeTreeSuggestion,
                        confidence: intelligentAnalysis.confidence
                    };
                    
                    console.log(`üìä AIÂàÜÊûêÁªìÊûú: ${intelligentAnalysis.entities?.length || 0}‰∏™ÂÆû‰Ωì, ${intelligentAnalysis.concepts?.length || 0}‰∏™Ê¶ÇÂøµ, ${intelligentAnalysis.relationships?.length || 0}‰∏™ÂÖ≥Á≥ª`);
                    
                    // Êõ¥Êñ∞extractedContent‰∏∫ÂàÜÊûêÁªìÊûú
                    extractedContent = intelligentAnalysis.content;
                    
                    return {
                        fileType,
                        extractedContent,
                        documentStructure,
                        contentLength: extractedContent.length,
                        processingMethod: this.isConnected ? 'graphrag_service' : 'local_processing'
                    };
                    
                } catch (error) {
                    console.warn('‚ö†Ô∏è Document processing failed, using fallback:', error);
                    return this.generateDocumentFallback(file, fileType);
                }
            }
            
            // ËØªÂèñÊñáÊú¨Êñá‰ª∂
            async readTextFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = e => {
                        console.log('üìÑ File content extracted, length:', e.target.result?.length || 0);
                        resolve(e.target.result || '');
                    };
                    reader.onerror = e => {
                        console.error('‚ùå Failed to read file:', e);
                        reject(new Error('Failed to read file'));
                    };
                    reader.readAsText(file);
                });
            }
            
            // ÂàÜÊûêÊñáÊú¨ÁªìÊûÑ
            analyzeTextStructure(content) {
                const lines = content.split('\n');
                const words = content.split(/\s+/).filter(w => w.length > 0);
                const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
                
                return {
                    lineCount: lines.length,
                    wordCount: words.length,
                    sentenceCount: sentences.length,
                    averageWordsPerSentence: Math.round(words.length / Math.max(sentences.length, 1)),
                    hasStructuredContent: this.detectStructuredContent(lines),
                    contentType: this.classifyTextContent(content)
                };
            }
            
            // LLMÈ©±Âä®ÁöÑÂÆû‰ΩìÂÖ≥Á≥ªÊèêÂèñ
            async extractEntitiesAndRelationships(file, documentAnalysis) {
                console.log('ü§ñ Extracting entities and relationships using LLM');
                
                if (this.isConnected) {
                    // ‰ΩøÁî®ÁúüÂÆûÁöÑGraphRAGÊúçÂä°
                    return await this.callGraphRAGEntityExtraction(file, documentAnalysis);
                } else {
                    // ‰ΩøÁî®Â§öÊô∫ËÉΩ‰ΩìÁ≥ªÁªüËøõË°åÂÆû‰ΩìÂÖ≥Á≥ªÊèêÂèñ
                    return await this.multiAgentEntityExtraction(file, documentAnalysis);
                }
            }
            
            // Â§öÊô∫ËÉΩ‰ΩìÂÆû‰ΩìÊèêÂèñ
            async multiAgentEntityExtraction(file, documentAnalysis) {
                const [graphResult, hybridResult, researchResult] = await Promise.all([
                    this.graphAgent.extractEntitiesFromDocument(file, documentAnalysis).catch(e => ({ error: e.message })),
                    this.hybridAgent.extractEntitiesFromDocument(file, documentAnalysis).catch(e => ({ error: e.message })),
                    this.deepResearchAgent.extractEntitiesFromDocument(file, documentAnalysis).catch(e => ({ error: e.message }))
                ]);
                
                return this.fuseEntityExtractionResults([graphResult, hybridResult, researchResult]);
            }
            
            // Á§æÂå∫Ê£ÄÊµã‰∏éÊëòË¶Å
            async performCommunityDetection(entityAnalysis) {
                console.log('üèòÔ∏è Performing community detection and summarization');
                
                const entities = entityAnalysis.entities || [];
                const relationships = entityAnalysis.relationships || [];
                
                // ÊûÑÂª∫ÂõæÁªìÊûÑÁî®‰∫éÁ§æÂå∫Ê£ÄÊµã
                const graph = this.buildEntityGraph(entities, relationships);
                
                // ÁÆÄÂåñÁöÑÁ§æÂå∫Ê£ÄÊµãÁÆóÊ≥ïÔºàÊ®°ÊãüLeidenÁÆóÊ≥ïÔºâ
                const communities = this.detectCommunitiesSimplified(graph);
                
                // ‰∏∫ÊØè‰∏™Á§æÂå∫ÁîüÊàêÊëòË¶Å
                const communitySummaries = await this.generateCommunitySummaries(communities, entities);
                
                return {
                    totalCommunities: communities.length,
                    communities,
                    communitySummaries,
                    detectionMethod: 'simplified_leiden',
                    modularityScore: this.calculateModularity(graph, communities)
                };
            }
            
            // Áü•ËØÜÊ†ë‰ΩçÁΩÆÂª∫ËÆÆ
            async suggestKnowledgeTreePosition(file, fullAnalysis) {
                console.log('üå≥ Suggesting knowledge tree position', fullAnalysis);
                
                const suggestions = [];
                const entities = fullAnalysis.entityAnalysis?.entities || [];
                const communities = fullAnalysis.communityAnalysis?.communities || [];
                const documentAnalysis = fullAnalysis.documentAnalysis || {};
                const documentType = documentAnalysis.fileType?.supportedFormat;
                
                // Ê£ÄÊü•ÊòØÂê¶ÊúâAIÂàÜÊûêÁªìÊûú
                const aiClassification = documentAnalysis.extractedContent?.aiClassification;
                if (aiClassification && aiClassification !== 'ÊñáÊ°£/ÂÖ∂‰ªñ') {
                    console.log('ü§ñ Using AI classification:', aiClassification);
                    suggestions.push({
                        path: aiClassification,
                        confidence: 0.9,
                        reason: 'AIÊô∫ËÉΩÂàÜÊûêÊé®Ëçê',
                        category: 'ai_classification'
                    });
                }
                
                // Âü∫‰∫éÊñáÊ°£Á±ªÂûãÁöÑÂª∫ËÆÆ
                if (documentType) {
                    suggestions.push(this.suggestByDocumentType(documentType, file.name));
                }
                
                // Âü∫‰∫éÊñá‰ª∂ÂêçÁöÑÊô∫ËÉΩÂª∫ËÆÆ
                const fileNameSuggestion = this.suggestByFileName(file.name);
                if (fileNameSuggestion) {
                    suggestions.push(fileNameSuggestion);
                }
                
                // Âü∫‰∫éÂÆû‰ΩìÁöÑÂª∫ËÆÆ
                if (entities.length > 0) {
                    suggestions.push(...this.suggestByEntities(entities));
                }
                
                // Âü∫‰∫éÁ§æÂå∫ÁöÑÂª∫ËÆÆ
                if (communities.length > 0) {
                    suggestions.push(...this.suggestByCommunities(communities));
                }
                
                // Â¶ÇÊûúÊ≤°Êúâ‰ªª‰ΩïÂª∫ËÆÆÔºåÊèê‰æõÈªòËÆ§Âª∫ËÆÆ
                if (suggestions.length === 0) {
                    suggestions.push({
                        path: 'ÊñáÊ°£/Êú™ÂàÜÁ±ª',
                        confidence: 0.5,
                        reason: 'ÈªòËÆ§ÂàÜÁ±ª‰ΩçÁΩÆ',
                        category: 'default'
                    });
                }
                
                // ÊéíÂ∫èÂπ∂ÈÄâÊã©ÊúÄ‰Ω≥Âª∫ËÆÆ
                const rankedSuggestions = this.rankSuggestions(suggestions);
                
                console.log('üìã Generated suggestions:', rankedSuggestions);
                
                return {
                    primarySuggestion: rankedSuggestions[0],
                    alternatives: rankedSuggestions.slice(1, 4),
                    confidence: rankedSuggestions[0]?.confidence || 0.5,
                    reasoning: this.generatePositionReasoning(fullAnalysis, rankedSuggestions[0])
                };
            }
            
            // Âü∫‰∫éÊñá‰ª∂ÂêçÁöÑÂª∫ËÆÆ
            suggestByFileName(fileName) {
                const lowerName = fileName.toLowerCase();
                
                if (lowerName.includes('ÈúÄÊ±Ç') || lowerName.includes('requirement')) {
                    return {
                        path: '‰∫ßÂìÅ/ÈúÄÊ±ÇÊñáÊ°£',
                        confidence: 0.85,
                        reason: 'Êñá‰ª∂ÂêçÂåÖÂê´ÈúÄÊ±ÇÁõ∏ÂÖ≥ËØçÊ±á',
                        category: 'filename_analysis'
                    };
                } else if (lowerName.includes('api') || lowerName.includes('Êé•Âè£')) {
                    return {
                        path: 'ÊäÄÊúØ/APIÊñáÊ°£',
                        confidence: 0.85,
                        reason: 'Êñá‰ª∂ÂêçÂåÖÂê´APIÁõ∏ÂÖ≥ËØçÊ±á',
                        category: 'filename_analysis'
                    };
                } else if (lowerName.includes('insight') || lowerName.includes('ÂàÜÊûê')) {
                    return {
                        path: 'ÂàÜÊûê/Ê¥ûÂØüÊä•Âëä',
                        confidence: 0.85,
                        reason: 'Êñá‰ª∂ÂêçÂåÖÂê´ÂàÜÊûêÁõ∏ÂÖ≥ËØçÊ±á',
                        category: 'filename_analysis'
                    };
                }
                
                return null;
            }
            
            async checkConnection() {
                try {
                    const response = await fetch(`${this.baseUrl}/auth/profile`, {
                        method: 'GET',
                        headers: {'Content-Type': 'application/json'}
                    });
                    this.isConnected = response.ok;
                    console.log('üîó GraphRAG Service connection:', this.isConnected ? 'Connected' : 'Disconnected');
                } catch (error) {
                    this.isConnected = false;
                    console.log('‚ö†Ô∏è GraphRAG Service offline, using enhanced simulation');
                }
            }
            
            async analyzeContent(file, additionalContext = {}) {
                console.log('ü§ñ Starting Multi-Agent GraphRAG analysis for:', file.name);
                
                if (!this.isConnected) {
                    console.log('üì° GraphRAG service offline, using multi-agent enhanced analysis');
                    return this.multiAgentAnalysis(file, additionalContext);
                }
                
                try {
                    // Â∞ùËØïËøûÊé•ÁúüÂÆûÁöÑGraphRAGÊúçÂä°
                    const formData = new FormData();
                    formData.append('file', file);
                    formData.append('context', JSON.stringify(additionalContext));
                    
                    const response = await fetch(`${this.baseUrl}/graphrag/analyze`, {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        throw new Error(`GraphRAG API error: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    
                    // Âç≥‰ΩøÊúâÁúüÂÆûÊúçÂä°Ôºå‰πüÁî®Â§öÊô∫ËÉΩ‰ΩìÁ≥ªÁªüÂ¢ûÂº∫ÁªìÊûú
                    const enhancedResult = await this.enhanceWithMultiAgent(result, file, additionalContext);
                    return this.processGraphRAGResult(enhancedResult);
                    
                } catch (error) {
                    console.error('‚ùå GraphRAG service failed, falling back to multi-agent analysis:', error);
                    return this.multiAgentAnalysis(file, additionalContext);
                }
            }
            
            async multiAgentAnalysis(file, additionalContext = {}) {
                console.log('üöÄ Running Multi-Agent Analysis Pipeline');
                
                // Âπ∂Ë°åËøêË°åÂ§ö‰∏™Êô∫ËÉΩ‰Ωì
                const [graphResult, hybridResult, researchResult] = await Promise.all([
                    this.graphAgent.analyze(file, additionalContext).catch(e => {
                        console.warn('GraphAgent failed:', e);
                        return { agent: 'GraphAgent', error: e.message };
                    }),
                    this.hybridAgent.analyze(file, additionalContext).catch(e => {
                        console.warn('HybridAgent failed:', e);
                        return { agent: 'HybridAgent', error: e.message };
                    }),
                    this.deepResearchAgent.analyze(file, additionalContext).catch(e => {
                        console.warn('DeepResearchAgent failed:', e);
                        return { agent: 'DeepResearchAgent', error: e.message };
                    })
                ]);
                
                // ËûçÂêàÂ§öÊô∫ËÉΩ‰ΩìÁªìÊûú
                const fusedResult = await this.fuseMultiAgentResults([graphResult, hybridResult, researchResult]);
                
                // Ëé∑ÂèñÂü∫Á°ÄÂàÜÊûê‰Ωú‰∏∫Ë°•ÂÖÖ
                const basicAnalysis = await this.enhancedSimulatedAnalysis(file, additionalContext);
                
                // Â∫îÁî®ÂõæÊé®ÁêÜÂ¢ûÂº∫
                const enhancedWithGraphReasoning = await this.enhanceInsightsWithGraphReasoning({
                    ...basicAnalysis,
                    multiAgentAnalysis: {
                        graphAgent: graphResult,
                        hybridAgent: hybridResult,
                        deepResearchAgent: researchResult,
                        fusedInsights: fusedResult
                    }
                });
                
                return {
                    ...enhancedWithGraphReasoning,
                    isMultiAgent: true,
                    serviceStatus: this.isConnected ? 'connected' : 'multi-agent-fallback'
                };
            }
            
            async enhanceWithMultiAgent(baseResult, file, additionalContext) {
                console.log('üî• Enhancing GraphRAG result with multi-agent analysis');
                
                // ËøêË°åÂ§öÊô∫ËÉΩ‰ΩìÂ¢ûÂº∫
                const multiAgentEnhancement = await this.multiAgentAnalysis(file, additionalContext);
                
                // ËûçÂêàÂü∫Á°ÄÁªìÊûúÂíåÂ§öÊô∫ËÉΩ‰ΩìÁªìÊûú
                return {
                    ...baseResult,
                    multiAgentEnhancement: multiAgentEnhancement.multiAgentAnalysis,
                    enhancedInsights: this.combineInsights(baseResult, multiAgentEnhancement),
                    confidence: Math.max(baseResult.confidence || 0.8, multiAgentEnhancement.confidence || 0.85)
                };
            }
            
            async fuseMultiAgentResults(results) {
                console.log('üîÑ Fusing multi-agent analysis results');
                
                const validResults = results.filter(r => !r.error);
                const failedAgents = results.filter(r => r.error);
                
                if (failedAgents.length > 0) {
                    console.warn(`${failedAgents.length} agents failed:`, failedAgents.map(r => r.agent));
                }
                
                // ÊèêÂèñÊâÄÊúâÊô∫ËÉΩ‰ΩìÁöÑÊ¥ûÂØü
                const allInsights = [];
                const allReasoning = [];
                let totalConfidence = 0;
                
                validResults.forEach(result => {
                    if (result.reasoning) allReasoning.push(...result.reasoning);
                    if (result.confidence) totalConfidence += result.confidence;
                    
                    // ÊèêÂèñÁâπÂÆöÁ±ªÂûãÁöÑÊ¥ûÂØü
                    if (result.agent === 'GraphAgent') {
                        allInsights.push('ÂõæÁªìÊûÑÂàÜÊûê: ËØÜÂà´ÂÆû‰ΩìÂíåÂÖ≥Á≥ªÁΩëÁªú');
                    } else if (result.agent === 'HybridAgent') {
                        allInsights.push('Â§öÊ®°ÊÄÅËûçÂêà: ÁªºÂêàÊñáÊú¨„ÄÅÁªìÊûÑÂíåËØ≠‰πâÂàÜÊûê');
                    } else if (result.agent === 'DeepResearchAgent') {
                        allInsights.push('Ê∑±Â∫¶Á†îÁ©∂: È¢ÜÂüüÁü•ËØÜÊèêÂèñÂíåÊ¥ûÂØüÁîüÊàê');
                    }
                });
                
                const averageConfidence = validResults.length > 0 ? totalConfidence / validResults.length : 0.8;
                
                return {
                    fusedInsights: allInsights,
                    combinedReasoning: allReasoning,
                    agentConsensus: this.calculateAgentConsensus(validResults),
                    fusedConfidence: averageConfidence,
                    activeAgents: validResults.map(r => r.agent),
                    failedAgents: failedAgents.map(r => r.agent)
                };
            }
            
            calculateAgentConsensus(results) {
                // ËÆ°ÁÆóÊô∫ËÉΩ‰ΩìÈó¥ÁöÑÂÖ±ËØÜÂ∫¶
                const consensusTopics = new Set();
                
                results.forEach(result => {
                    if (result.entities) {
                        result.entities.forEach(entity => consensusTopics.add(entity.value));
                    }
                    if (result.concepts) {
                        result.concepts.forEach(concept => consensusTopics.add(concept));
                    }
                });
                
                return {
                    commonTopics: Array.from(consensusTopics),
                    consensusStrength: Math.min(results.length / 3, 1), // ÊúÄÂ§ö3‰∏™Êô∫ËÉΩ‰Ωì
                    agreementLevel: results.length > 1 ? 'high' : 'single-agent'
                };
            }
            
            combineInsights(baseResult, multiAgentResult) {
                const combined = [];
                
                if (baseResult.keyInsights) combined.push(...baseResult.keyInsights);
                if (multiAgentResult.multiAgentAnalysis?.fusedInsights?.fusedInsights) {
                    combined.push(...multiAgentResult.multiAgentAnalysis.fusedInsights.fusedInsights);
                }
                
                return Array.from(new Set(combined)); // ÂéªÈáç
            }
            
            async enhanceInsightsWithGraphReasoning(analysis) {
                console.log('üß† Enhancing insights with graph-based reasoning');
                
                if (!analysis) return analysis;
                
                // ÊûÑÂª∫Áü•ËØÜÂõæË∞±Êé®ÁêÜÂ¢ûÂº∫Âô®
                const graphReasoning = await this.performGraphBasedReasoning(analysis);
                
                // Â¢ûÂº∫ÂéüÊúâÊ¥ûÂØü
                const enhancedInsights = await this.generateGraphEnhancedInsights(analysis, graphReasoning);
                
                // ÁîüÊàêÊé®ÁêÜË∑ØÂæÑ
                const reasoningPaths = await this.generateReasoningPaths(analysis, graphReasoning);
                
                return {
                    ...analysis,
                    graphReasoning,
                    enhancedInsights,
                    reasoningPaths,
                    hasGraphReasoning: true
                };
            }
            
            async performGraphBasedReasoning(analysis) {
                // Âü∫‰∫éÂõæÁªìÊûÑÁöÑÊé®ÁêÜ
                const graphStructure = this.buildReasoningGraph(analysis);
                const centralConcepts = this.identifyCentralConcepts(graphStructure);
                const connectionPatterns = this.analyzeConnectionPatterns(graphStructure);
                const inferredRelationships = this.inferNewRelationships(graphStructure);
                
                return {
                    graphStructure,
                    centralConcepts,
                    connectionPatterns,
                    inferredRelationships,
                    reasoningScore: this.calculateReasoningScore(graphStructure)
                };
            }
            
            buildReasoningGraph(analysis) {
                const nodes = [];
                const edges = [];
                
                // ‰ªéÂÆû‰ΩìÂàõÂª∫ËäÇÁÇπ
                if (analysis.entities) {
                    analysis.entities.forEach((entity, index) => {
                        nodes.push({
                            id: `entity_${index}`,
                            type: 'entity',
                            label: typeof entity === 'string' ? entity : entity.value || entity.label,
                            weight: 1
                        });
                    });
                }
                
                // ‰ªéÊ¶ÇÂøµÂàõÂª∫ËäÇÁÇπ
                if (analysis.concepts) {
                    analysis.concepts.forEach((concept, index) => {
                        nodes.push({
                            id: `concept_${index}`,
                            type: 'concept',
                            label: typeof concept === 'string' ? concept : concept.value || concept.label,
                            weight: 1.5
                        });
                    });
                }
                
                // ‰ªéÂÖ≥Á≥ªÂàõÂª∫Ëæπ
                if (analysis.relationships) {
                    analysis.relationships.forEach((rel, index) => {
                        edges.push({
                            id: `rel_${index}`,
                            source: this.findNodeByLabel(nodes, rel.source),
                            target: this.findNodeByLabel(nodes, rel.target),
                            type: rel.type || 'RELATED_TO',
                            weight: rel.confidence || 0.7
                        });
                    });
                }
                
                return { nodes, edges };
            }
            
            identifyCentralConcepts(graphStructure) {
                const nodeConnectivity = {};
                
                // ËÆ°ÁÆóËäÇÁÇπËøûÊé•Â∫¶
                graphStructure.nodes.forEach(node => {
                    nodeConnectivity[node.id] = 0;
                });
                
                graphStructure.edges.forEach(edge => {
                    if (edge.source && edge.target) {
                        nodeConnectivity[edge.source] = (nodeConnectivity[edge.source] || 0) + 1;
                        nodeConnectivity[edge.target] = (nodeConnectivity[edge.target] || 0) + 1;
                    }
                });
                
                // ÊâæÂá∫ËøûÊé•Â∫¶ÊúÄÈ´òÁöÑËäÇÁÇπ
                const sortedNodes = Object.entries(nodeConnectivity)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 5)
                    .map(([nodeId, connectivity]) => {
                        const node = graphStructure.nodes.find(n => n.id === nodeId);
                        return {
                            ...node,
                            connectivity,
                            centrality: connectivity / Math.max(graphStructure.edges.length, 1)
                        };
                    });
                
                return sortedNodes;
            }
            
            analyzeConnectionPatterns(graphStructure) {
                const patterns = [];
                
                // ÂàÜÊûêÈõÜÁæ§Ê®°Âºè
                const clusters = this.detectClusters(graphStructure);
                if (clusters.length > 1) {
                    patterns.push({
                        type: 'cluster_formation',
                        description: `ËØÜÂà´‰∫Ü ${clusters.length} ‰∏™Ê¶ÇÂøµÈõÜÁæ§`,
                        strength: clusters.length / Math.max(graphStructure.nodes.length / 3, 1)
                    });
                }
                
                // ÂàÜÊûêÊ°•Êé•Ê®°Âºè
                const bridges = this.detectBridgeNodes(graphStructure);
                if (bridges.length > 0) {
                    patterns.push({
                        type: 'bridge_connections',
                        description: `ÂèëÁé∞ ${bridges.length} ‰∏™Ê°•Êé•ËäÇÁÇπËøûÊé•‰∏çÂêåÊ¶ÇÂøµÂüü`,
                        strength: bridges.length / Math.max(graphStructure.nodes.length, 1)
                    });
                }
                
                return patterns;
            }
            
            inferNewRelationships(graphStructure) {
                const inferred = [];
                
                // Âü∫‰∫éÂÖ±ÂêåÈÇªÂ±ÖÊé®Êñ≠Êñ∞ÂÖ≥Á≥ª
                graphStructure.nodes.forEach((node1, i) => {
                    graphStructure.nodes.forEach((node2, j) => {
                        if (i >= j) return;
                        
                        const commonNeighbors = this.findCommonNeighbors(node1, node2, graphStructure);
                        if (commonNeighbors.length >= 2) {
                            inferred.push({
                                source: node1.label,
                                target: node2.label,
                                type: 'INFERRED_RELATION',
                                confidence: Math.min(0.8, commonNeighbors.length / 3),
                                reason: `ÈÄöËøá ${commonNeighbors.length} ‰∏™ÂÖ±ÂêåËøûÊé•Êé®Êñ≠`
                            });
                        }
                    });
                });
                
                return inferred.slice(0, 5); // ÈôêÂà∂Êï∞Èáè
            }
            
            async generateGraphEnhancedInsights(analysis, graphReasoning) {
                const insights = [];
                
                // Âü∫‰∫é‰∏≠ÂøÉÊ¶ÇÂøµÁöÑÊ¥ûÂØü
                if (graphReasoning.centralConcepts?.length > 0) {
                    const topConcept = graphReasoning.centralConcepts[0];
                    insights.push({
                        type: 'centrality',
                        content: `"${topConcept.label}" ÊòØÊ†∏ÂøÉÊ¶ÇÂøµÔºåÂÖ∑Êúâ ${topConcept.connectivity} ‰∏™ËøûÊé•`,
                        confidence: topConcept.centrality,
                        reasoning: 'Âü∫‰∫éÂõæ‰∏≠ÂøÉÊÄßÂàÜÊûê'
                    });
                }
                
                // Âü∫‰∫éËøûÊé•Ê®°ÂºèÁöÑÊ¥ûÂØü
                graphReasoning.connectionPatterns?.forEach(pattern => {
                    insights.push({
                        type: 'pattern',
                        content: pattern.description,
                        confidence: Math.min(pattern.strength, 0.9),
                        reasoning: 'Âü∫‰∫éÂõæËøûÊé•Ê®°ÂºèÂàÜÊûê'
                    });
                });
                
                // Âü∫‰∫éÊé®Êñ≠ÂÖ≥Á≥ªÁöÑÊ¥ûÂØü
                if (graphReasoning.inferredRelationships?.length > 0) {
                    insights.push({
                        type: 'inference',
                        content: `Êé®Êñ≠Âá∫ ${graphReasoning.inferredRelationships.length} ‰∏™ÊΩúÂú®ÂÖ≥Á≥ª`,
                        confidence: 0.75,
                        reasoning: 'Âü∫‰∫éÂõæÊé®ÁêÜÂàÜÊûê'
                    });
                }
                
                return insights;
            }
            
            async generateReasoningPaths(analysis, graphReasoning) {
                const paths = [];
                
                // ÁîüÊàê‰ªéÊ†∏ÂøÉÊ¶ÇÂøµÂà∞ÂÖ∂‰ªñÊ¶ÇÂøµÁöÑÊé®ÁêÜË∑ØÂæÑ
                if (graphReasoning.centralConcepts?.length > 0) {
                    const centralNode = graphReasoning.centralConcepts[0];
                    
                    paths.push({
                        type: 'centrality_path',
                        steps: [
                            `ËØÜÂà´Ê†∏ÂøÉÊ¶ÇÂøµ: ${centralNode.label}`,
                            `ÂàÜÊûêËøûÊé•Â∫¶: ${centralNode.connectivity} ‰∏™Áõ¥Êé•ËøûÊé•`,
                            `ËÆ°ÁÆó‰∏≠ÂøÉÊÄß: ${Math.round(centralNode.centrality * 100)}% ‰∏≠ÂøÉÂ∫¶`,
                            `Êé®Êñ≠ÈáçË¶ÅÊÄß: Âú®Áü•ËØÜÂõæË∞±‰∏≠Âç†ÊçÆ‰∏≠ÂøÉÂú∞‰Ωç`
                        ],
                        confidence: centralNode.centrality
                    });
                }
                
                // ÁîüÊàêÊé®ÁêÜË∑ØÂæÑÁî®‰∫éÊé®Êñ≠ÂÖ≥Á≥ª
                graphReasoning.inferredRelationships?.forEach((rel, index) => {
                    if (index < 2) { // ÈôêÂà∂Ë∑ØÂæÑÊï∞Èáè
                        paths.push({
                            type: 'inference_path',
                            steps: [
                                `ÂèëÁé∞Ê¶ÇÂøµ: ${rel.source}`,
                                `ÂèëÁé∞Ê¶ÇÂøµ: ${rel.target}`,
                                `ÂàÜÊûêÂÖ±ÂêåËøûÊé•`,
                                `Êé®Êñ≠ÂÖ≥Á≥ª: ${rel.type}`,
                                `ÁΩÆ‰ø°Â∫¶ËØÑ‰º∞: ${Math.round(rel.confidence * 100)}%`
                            ],
                            confidence: rel.confidence
                        });
                    }
                });
                
                return paths;
            }
            
            // ËæÖÂä©ÊñπÊ≥ï
            findNodeByLabel(nodes, label) {
                const node = nodes.find(n => n.label === label);
                return node ? node.id : null;
            }
            
            detectClusters(graphStructure) {
                // ÁÆÄÂåñÁöÑÈõÜÁæ§Ê£ÄÊµã
                const visited = new Set();
                const clusters = [];
                
                graphStructure.nodes.forEach(node => {
                    if (!visited.has(node.id)) {
                        const cluster = this.exploreCluster(node, graphStructure, visited);
                        if (cluster.length > 1) {
                            clusters.push(cluster);
                        }
                    }
                });
                
                return clusters;
            }
            
            exploreCluster(startNode, graphStructure, visited, cluster = []) {
                if (visited.has(startNode.id)) return cluster;
                
                visited.add(startNode.id);
                cluster.push(startNode);
                
                // ÊâæÂà∞Áõ∏ÈÇªËäÇÁÇπ
                graphStructure.edges.forEach(edge => {
                    let neighborId = null;
                    if (edge.source === startNode.id) neighborId = edge.target;
                    else if (edge.target === startNode.id) neighborId = edge.source;
                    
                    if (neighborId && !visited.has(neighborId)) {
                        const neighbor = graphStructure.nodes.find(n => n.id === neighborId);
                        if (neighbor) {
                            this.exploreCluster(neighbor, graphStructure, visited, cluster);
                        }
                    }
                });
                
                return cluster;
            }
            
            detectBridgeNodes(graphStructure) {
                // Ê£ÄÊµãÊ°•Êé•ËäÇÁÇπÔºàËøûÊé•‰∏çÂêåÈõÜÁæ§ÁöÑËäÇÁÇπÔºâ
                const bridges = [];
                
                graphStructure.nodes.forEach(node => {
                    const neighbors = this.getNeighbors(node, graphStructure);
                    if (neighbors.length >= 3) {
                        // ÁÆÄÂåñÂà§Êñ≠ÔºöËøûÊé•Êï∞Â§öÁöÑËäÇÁÇπÂèØËÉΩÊòØÊ°•Êé•ËäÇÁÇπ
                        bridges.push(node);
                    }
                });
                
                return bridges;
            }
            
            getNeighbors(node, graphStructure) {
                const neighbors = [];
                graphStructure.edges.forEach(edge => {
                    if (edge.source === node.id) {
                        const neighbor = graphStructure.nodes.find(n => n.id === edge.target);
                        if (neighbor) neighbors.push(neighbor);
                    } else if (edge.target === node.id) {
                        const neighbor = graphStructure.nodes.find(n => n.id === edge.source);
                        if (neighbor) neighbors.push(neighbor);
                    }
                });
                return neighbors;
            }
            
            findCommonNeighbors(node1, node2, graphStructure) {
                const neighbors1 = this.getNeighbors(node1, graphStructure);
                const neighbors2 = this.getNeighbors(node2, graphStructure);
                
                return neighbors1.filter(n1 => 
                    neighbors2.some(n2 => n1.id === n2.id)
                );
            }
            
            calculateReasoningScore(graphStructure) {
                const nodeCount = graphStructure.nodes.length;
                const edgeCount = graphStructure.edges.length;
                const density = nodeCount > 1 ? edgeCount / (nodeCount * (nodeCount - 1) / 2) : 0;
                
                return Math.min(0.95, 0.5 + density * 0.4 + (nodeCount / 10) * 0.1);
            }
            
            // Ê∑ªÂä†Áº∫Â§±ÁöÑËæÖÂä©ÊñπÊ≥ï
            detectStructuredContent(lines) {
                // Ê£ÄÊµãÊòØÂê¶‰∏∫ÁªìÊûÑÂåñÂÜÖÂÆπÔºàÂ¶Ç‰ª£Á†Å„ÄÅÈÖçÁΩÆÊñá‰ª∂Á≠âÔºâ
                const structureIndicators = lines.filter(line => 
                    line.trim().match(/^[\s]*[{}\[\]()]/g) || 
                    line.includes(':') || 
                    line.includes('=') || 
                    line.startsWith('#') ||
                    line.startsWith('-') ||
                    line.startsWith('*')
                );
                return structureIndicators.length / Math.max(lines.length, 1) > 0.3;
            }
            
            classifyTextContent(content) {
                const lowercaseContent = content.toLowerCase();
                
                if (lowercaseContent.includes('import') || lowercaseContent.includes('function') || lowercaseContent.includes('class')) {
                    return 'code';
                } else if (lowercaseContent.includes('# ') || lowercaseContent.includes('## ')) {
                    return 'markdown';
                } else if (lowercaseContent.includes('abstract') || lowercaseContent.includes('introduction') || lowercaseContent.includes('conclusion')) {
                    return 'academic_paper';
                } else if (lowercaseContent.includes('api') || lowercaseContent.includes('endpoint') || lowercaseContent.includes('request')) {
                    return 'api_documentation';
                } else {
                    return 'general_text';
                }
            }
            
            analyzeJSONStructure(content) {
                try {
                    const json = JSON.parse(content);
                    return {
                        isValidJSON: true,
                        objectCount: this.countJSONObjects(json),
                        depth: this.calculateJSONDepth(json),
                        hasArrays: this.hasArrays(json),
                        topLevelKeys: Object.keys(json || {})
                    };
                } catch (error) {
                    return { isValidJSON: false, error: error.message };
                }
            }
            
            analyzeCSVStructure(content) {
                const lines = content.split('\n').filter(line => line.trim());
                const firstLine = lines[0] || '';
                const columnCount = firstLine.split(',').length;
                
                return {
                    rowCount: lines.length,
                    columnCount,
                    hasHeader: this.detectCSVHeader(firstLine),
                    estimatedDataTypes: this.detectCSVDataTypes(lines.slice(1, 6))
                };
            }
            
            async processComplexDocument(file) {
                // ÂØπ‰∫éÂ§çÊùÇÊñáÊ°£Ê†ºÂºèÔºåÂ∞ùËØïË∞ÉÁî®GraphRAGÊúçÂä°
                if (this.isConnected) {
                    try {
                        const formData = new FormData();
                        formData.append('file', file);
                        
                        const response = await fetch(`${this.baseUrl}/content/input`, {
                            method: 'POST',
                            body: formData
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            return {
                                content: result.extracted_text || '',
                                structure: result.document_structure || {}
                            };
                        }
                    } catch (error) {
                        console.warn('GraphRAG document processing failed:', error);
                    }
                }
                
                // ÂõûÈÄÄÂà∞Âü∫Á°ÄÂ§ÑÁêÜ
                return this.generateDocumentFallback(file, this.identifyFileType(file));
            }
            
            generateDocumentFallback(file, fileType) {
                return {
                    fileType,
                    extractedContent: `[${fileType.supportedFormat}Êñá‰ª∂ÂÜÖÂÆπÊèêÂèñÂ§±Ë¥•Ôºå‰ΩøÁî®Êñá‰ª∂ÂêçËøõË°åÂü∫Á°ÄÂàÜÊûê]`,
                    documentStructure: {
                        fileName: file.name,
                        fileSize: file.size,
                        analysisType: 'fallback'
                    },
                    contentLength: 0,
                    processingMethod: 'fallback'
                };
            }
            
            async callGraphRAGEntityExtraction(file, documentAnalysis) {
                try {
                    const response = await fetch(`${this.baseUrl}/graphrag/analyze`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            content: documentAnalysis.extractedContent,
                            file_info: {
                                name: file.name,
                                type: documentAnalysis.fileType.supportedFormat
                            }
                        })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        return {
                            entities: result.entities || [],
                            relationships: result.relationships || [],
                            extractionMethod: 'graphrag_service'
                        };
                    }
                } catch (error) {
                    console.warn('GraphRAG entity extraction failed:', error);
                }
                
                // ÂõûÈÄÄÂà∞Â§öÊô∫ËÉΩ‰ΩìÊèêÂèñ
                return this.multiAgentEntityExtraction(file, documentAnalysis);
            }
            
            fuseEntityExtractionResults(results) {
                const validResults = results.filter(r => !r.error);
                const allEntities = [];
                const allRelationships = [];
                
                validResults.forEach(result => {
                    if (result.entities) allEntities.push(...result.entities);
                    if (result.relationships) allRelationships.push(...result.relationships);
                });
                
                return {
                    entities: this.deduplicateEntities(allEntities),
                    relationships: this.deduplicateRelationships(allRelationships),
                    extractionMethod: 'multi_agent_fusion',
                    sourceAgents: validResults.map(r => r.agent || 'unknown')
                };
            }
            
            buildEntityGraph(entities, relationships) {
                return {
                    nodes: entities.map((entity, index) => ({
                        id: index,
                        label: typeof entity === 'string' ? entity : entity.value || entity.label,
                        type: typeof entity === 'object' ? entity.type : 'ENTITY'
                    })),
                    edges: relationships.map((rel, index) => ({
                        id: index,
                        source: this.findEntityIndex(entities, rel.source),
                        target: this.findEntityIndex(entities, rel.target),
                        type: rel.type || 'RELATED_TO'
                    })).filter(edge => edge.source !== -1 && edge.target !== -1)
                };
            }
            
            detectCommunitiesSimplified(graph) {
                // ÁÆÄÂåñÁöÑÁ§æÂå∫Ê£ÄÊµãÁÆóÊ≥ï
                const communities = [];
                const visited = new Set();
                
                graph.nodes.forEach(node => {
                    if (!visited.has(node.id)) {
                        const community = this.expandCommunity(node, graph, visited);
                        if (community.length > 1) {
                            communities.push(community);
                        }
                    }
                });
                
                return communities;
            }
            
            async generateCommunitySummaries(communities, entities) {
                return communities.map((community, index) => ({
                    communityId: index,
                    size: community.length,
                    entities: community.map(nodeId => {
                        const entity = entities[nodeId];
                        return typeof entity === 'string' ? entity : entity.value || entity.label;
                    }),
                    summary: `Á§æÂå∫ ${index + 1}: ÂåÖÂê´ ${community.length} ‰∏™Áõ∏ÂÖ≥ÂÆû‰Ωì`,
                    theme: this.inferCommunityTheme(community, entities)
                }));
            }
            
            calculateModularity(graph, communities) {
                // ÁÆÄÂåñÁöÑÊ®°ÂùóÂ∫¶ËÆ°ÁÆó
                if (communities.length <= 1) return 0;
                return Math.min(0.8, communities.length / Math.max(graph.nodes.length / 3, 1));
            }
            
            suggestByDocumentType(documentType, fileName) {
                const suggestions = {
                    'TXT': { path: 'ÊñáÊ°£/ÊñáÊú¨Êñá‰ª∂', confidence: 0.6 },
                    'MD': { path: 'ÊñáÊ°£/Markdown', confidence: 0.8 },
                    'PDF': { path: 'ÊñáÊ°£/PDFÊñáÊ°£', confidence: 0.7 },
                    'JSON': { path: 'Êï∞ÊçÆ/ÈÖçÁΩÆÊñá‰ª∂', confidence: 0.8 },
                    'CSV': { path: 'Êï∞ÊçÆ/Êï∞ÊçÆË°®', confidence: 0.9 },
                    'DOCX': { path: 'ÊñáÊ°£/WordÊñáÊ°£', confidence: 0.8 }
                };
                
                const suggestion = suggestions[documentType] || { path: 'ÂÖ∂‰ªñ/Êú™ÂàÜÁ±ª', confidence: 0.4 };
                
                return {
                    ...suggestion,
                    reason: `Âü∫‰∫éÊñáÊ°£Á±ªÂûã ${documentType} ÁöÑÂª∫ËÆÆ`,
                    category: 'document_type'
                };
            }
            
            suggestByEntities(entities) {
                const suggestions = [];
                const entityTypes = {};
                
                entities.forEach(entity => {
                    const type = typeof entity === 'object' ? entity.type : 'GENERAL';
                    entityTypes[type] = (entityTypes[type] || 0) + 1;
                });
                
                Object.entries(entityTypes).forEach(([type, count]) => {
                    if (count >= 2) {
                        const path = this.getPathByEntityType(type);
                        suggestions.push({
                            path,
                            confidence: Math.min(0.9, 0.6 + (count * 0.1)),
                            reason: `Ê£ÄÊµãÂà∞ ${count} ‰∏™ ${type} Á±ªÂûãÂÆû‰Ωì`,
                            category: 'entity_based'
                        });
                    }
                });
                
                return suggestions;
            }
            
            suggestByCommunities(communities) {
                return communities.map((community, index) => ({
                    path: `Áü•ËØÜÂõæË∞±/Á§æÂå∫${index + 1}`,
                    confidence: Math.min(0.8, 0.5 + (community.size * 0.05)),
                    reason: `Âü∫‰∫éÁ§æÂå∫Ê£ÄÊµãÁªìÊûúÔºåÂåÖÂê´ ${community.size} ‰∏™ÂÆû‰Ωì`,
                    category: 'community_based'
                }));
            }
            
            rankSuggestions(suggestions) {
                return suggestions
                    .sort((a, b) => (b.confidence || 0) - (a.confidence || 0))
                    .slice(0, 5);
            }
            
            generatePositionReasoning(fullAnalysis, primarySuggestion) {
                if (!primarySuggestion) return 'Êó†Ê≥ïÁîüÊàê‰ΩçÁΩÆÂª∫ËÆÆ';
                
                const reasons = [primarySuggestion.reason];
                
                if (fullAnalysis.entityAnalysis?.entities?.length > 0) {
                    reasons.push(`ÂåÖÂê´ ${fullAnalysis.entityAnalysis.entities.length} ‰∏™ÂÆû‰Ωì`);
                }
                
                if (fullAnalysis.communityAnalysis?.totalCommunities > 0) {
                    reasons.push(`ËØÜÂà´‰∫Ü ${fullAnalysis.communityAnalysis.totalCommunities} ‰∏™Ê¶ÇÂøµÁ§æÂå∫`);
                }
                
                return reasons.join('Ôºõ');
            }
            
            calculateOverallConfidence(analyses) {
                const confidences = analyses
                    .map(analysis => analysis.confidence || 0.5)
                    .filter(c => c > 0);
                
                if (confidences.length === 0) return 0.5;
                
                return confidences.reduce((sum, c) => sum + c, 0) / confidences.length;
            }
            
            async generateFallbackAnalysis(file) {
                return {
                    fileName: file.name,
                    basicInfo: `Âü∫Á°ÄÂàÜÊûê: ${file.name} (${this.formatFileSize(file.size)})`,
                    suggestedPath: 'ÂÖ∂‰ªñ/Êú™ÂàÜÁ±ª',
                    confidence: 0.3
                };
            }
            
            // Êõ¥Â§öËæÖÂä©ÊñπÊ≥ï
            countJSONObjects(obj, count = 0) {
                if (typeof obj === 'object' && obj !== null) {
                    count++;
                    Object.values(obj).forEach(value => {
                        count = this.countJSONObjects(value, count);
                    });
                }
                return count;
            }
            
            calculateJSONDepth(obj, depth = 0) {
                if (typeof obj === 'object' && obj !== null) {
                    const depths = Object.values(obj).map(value => this.calculateJSONDepth(value, depth + 1));
                    return Math.max(depth, ...depths);
                }
                return depth;
            }
            
            hasArrays(obj) {
                return Array.isArray(obj) || (typeof obj === 'object' && obj !== null && Object.values(obj).some(v => this.hasArrays(v)));
            }
            
            detectCSVHeader(firstLine) {
                return !/^\d/.test(firstLine) && firstLine.includes(',');
            }
            
            detectCSVDataTypes(dataLines) {
                return ['string', 'number', 'mixed'];
            }
            
            deduplicateEntities(entities) {
                const seen = new Set();
                return entities.filter(entity => {
                    const key = typeof entity === 'string' ? entity : entity.value || entity.label;
                    if (seen.has(key)) return false;
                    seen.add(key);
                    return true;
                });
            }
            
            deduplicateRelationships(relationships) {
                const seen = new Set();
                return relationships.filter(rel => {
                    const key = `${rel.source}-${rel.type}-${rel.target}`;
                    if (seen.has(key)) return false;
                    seen.add(key);
                    return true;
                });
            }
            
            findEntityIndex(entities, entityLabel) {
                return entities.findIndex(entity => 
                    (typeof entity === 'string' ? entity : entity.value || entity.label) === entityLabel
                );
            }
            
            expandCommunity(startNode, graph, visited, community = []) {
                if (visited.has(startNode.id)) return community;
                
                visited.add(startNode.id);
                community.push(startNode.id);
                
                // ÊâæÂà∞ÊâÄÊúâÁõ∏ÈÇªËäÇÁÇπ
                graph.edges.forEach(edge => {
                    let neighborId = null;
                    if (edge.source === startNode.id) neighborId = edge.target;
                    else if (edge.target === startNode.id) neighborId = edge.source;
                    
                    if (neighborId !== null && !visited.has(neighborId)) {
                        const neighbor = graph.nodes.find(n => n.id === neighborId);
                        if (neighbor) {
                            this.expandCommunity(neighbor, graph, visited, community);
                        }
                    }
                });
                
                return community;
            }
            
            inferCommunityTheme(community, entities) {
                // Âü∫‰∫éÁ§æÂå∫‰∏≠ÁöÑÂÆû‰ΩìÊé®Êñ≠‰∏ªÈ¢ò
                const themes = ['ÊäÄÊúØ', '‰∏öÂä°', 'Êï∞ÊçÆ', 'ÊµÅÁ®ã', 'Ê¶ÇÂøµ'];
                return themes[community.length % themes.length];
            }
            
            getPathByEntityType(type) {
                const pathMapping = {
                    'TECH': 'ÊäÄÊúØ/ÊäÄÊúØÊ†à',
                    'PERSON': 'Âõ¢Èòü/‰∫∫Âëò',
                    'ORG': 'ÁªÑÁªá/Êú∫ÊûÑ',
                    'CONCEPT': 'Ê¶ÇÂøµ/ÁêÜËÆ∫',
                    'LOCATION': 'Âú∞ÁêÜ/‰ΩçÁΩÆ',
                    'EVENT': '‰∫ã‰ª∂/Ê¥ªÂä®'
                };
                
                return pathMapping[type] || 'ÂÖ∂‰ªñ/ÂÆû‰Ωì';
            }
            
            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            
            // PDFÊñá‰ª∂Â§ÑÁêÜ
            async processPDFFile(file) {
                console.log('üìÑ Processing PDF file - using intelligent content analysis');
                
                // Áî±‰∫éPDFÈúÄË¶Å‰∏ìÈó®ÁöÑËß£ÊûêÂ∫ìÔºåÊàë‰ª¨‰ΩøÁî®Êô∫ËÉΩÂõûÈÄÄÁ≠ñÁï•
                // Âü∫‰∫éÊñá‰ª∂ÂêçÂíåÂ§ßÂ∞èËøõË°åÂÜÖÂÆπÊé®Êñ≠ÂíåÊ®°ÊãüÁúüÂÆûÂÜÖÂÆπ
                const fileName = file.name.toLowerCase();
                const fileSize = file.size;
                
                // Áõ¥Êé•‰ΩøÁî®Êô∫ËÉΩÂÜÖÂÆπÂàÜÊûê
                const aiAnalyzedContent = await this.analyzeFileContent(file, `PDFÊñá‰ª∂: ${fileName}`);
                
                return aiAnalyzedContent;
            }
            
            // üìÑ ‰ΩøÁî®PDF.jsÊèêÂèñÁúüÂÆûPDFÂÜÖÂÆπ
            async extractPDFText(file) {
                console.log('üî• ‰ΩøÁî®PDF.jsÊèêÂèñPDFÊñáÊú¨ÂÜÖÂÆπ');
                
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    
                    reader.onload = async function(e) {
                        try {
                            const arrayBuffer = e.target.result;
                            
                            // ÈÖçÁΩÆPDF.js worker
                            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                            
                            // Âä†ËΩΩPDFÊñáÊ°£
                            const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                            console.log('üìñ PDFÂä†ËΩΩÊàêÂäüÔºåÊÄªÈ°µÊï∞:', pdf.numPages);
                            
                            let fullText = '';
                            
                            // ÊèêÂèñÊâÄÊúâÈ°µÈù¢ÁöÑÊñáÊú¨
                            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                                const page = await pdf.getPage(pageNum);
                                const textContent = await page.getTextContent();
                                
                                const pageText = textContent.items.map(item => item.str).join(' ');
                                fullText += pageText + '\n';
                                
                                console.log(`üìÑ È°µÈù¢ ${pageNum}/${pdf.numPages} ÊèêÂèñÂÆåÊàêÔºåÊú¨È°µÂ≠óÁ¨¶Êï∞: ${pageText.length}`);
                            }
                            
                            console.log('‚úÖ PDFÂÖ®ÊñáÊèêÂèñÂÆåÊàêÔºåÊÄªÂ≠óÁ¨¶Êï∞:', fullText.length);
                            resolve(fullText.trim());
                            
                        } catch (error) {
                            console.error('‚ùå PDFËß£ÊûêÂ§±Ë¥•:', error);
                            reject(error);
                        }
                    };
                    
                    reader.onerror = () => reject(new Error('Êñá‰ª∂ËØªÂèñÂ§±Ë¥•'));
                    reader.readAsArrayBuffer(file);
                });
            }
            
            // PDFÊñáÊú¨ÊèêÂèñ‰∏ìÁî®‰∫éGraphRAG (Â§çÁî®‰∏ªË¶ÅÁöÑPDFËß£ÊûêÈÄªËæë)
            async extractPDFTextForGraphRAG(file) {
                try {
                    console.log('üìñ ‰∏∫GraphRAGÊèêÂèñPDFÊñáÊú¨:', file.name);
                    
                    const arrayBuffer = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = e => resolve(e.target.result);
                        reader.onerror = reject;
                        reader.readAsArrayBuffer(file);
                    });
                    
                    const uint8Array = new Uint8Array(arrayBuffer);
                    let text = '';
                    
                    // ÁÆÄÂçïÁöÑPDFÊñáÊú¨ÊèêÂèñÔºàÊü•ÊâæÊñáÊú¨ÊµÅÔºâ
                    const decoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: false });
                    const pdfString = decoder.decode(uint8Array);
                    
                    // Êü•ÊâæÊñáÊú¨ÂÜÖÂÆπÁöÑÁÆÄÂçïÊ≠£ÂàôË°®ËææÂºè
                    const textMatches = pdfString.match(/BT\s+.*?\s+ET/gs);
                    if (textMatches) {
                        for (const match of textMatches) {
                            // ÊèêÂèñÊã¨Âè∑ÂÜÖÁöÑÊñáÊú¨
                            const textContent = match.match(/\((.*?)\)/g);
                            if (textContent) {
                                textContent.forEach(t => {
                                    text += t.replace(/[()]/g, '') + ' ';
                                });
                            }
                        }
                    }
                    
                    // Â¶ÇÊûúÁÆÄÂçïÊèêÂèñÂ§±Ë¥•ÔºåÂ∞ùËØïÊü•ÊâæÂèØËØªÊñáÊú¨
                    if (text.length < 50) {
                        console.log('‚ö†Ô∏è Â∞ùËØïÂ§áÁî®ÊñáÊú¨ÊèêÂèñÊñπÊ≥ï');
                        const lines = pdfString.split('\n');
                        for (const line of lines) {
                            if (line.length > 10 && 
                                !line.match(/^[<>%\d\s]+$/) &&
                                !line.includes('obj') &&
                                !line.includes('endobj') &&
                                !line.includes('stream') &&
                                !line.includes('endstream')) {
                                
                                const cleanLine = line.replace(/[^\w\s\u4e00-\u9fff.,!?;:()\-]/g, '').trim();
                                if (cleanLine.length > 5) {
                                    text += cleanLine + '\n';
                                }
                            }
                        }
                    }
                    
                    console.log(`üìÑ GraphRAG PDFÊñáÊú¨ÊèêÂèñÂÆåÊàê: ${text.length} Â≠óÁ¨¶`);
                    return text.trim();
                    
                } catch (error) {
                    console.error('‚ùå GraphRAG PDFÊñáÊú¨ÊèêÂèñÂ§±Ë¥•:', error);
                    throw error;
                }
            }
            
            // üöÄ ‰ΩøÁî®ÁúüÊ≠£ÁöÑGraphRAG AgentÊúçÂä°
            async useGraphRAGAgent(file) {
                // üö® DEBUG: GraphRAG Agent Ë∞ÉÁî®ÂÖ•Âè£ËøΩË∏™
                console.log('üö® DEBUG: ======= useGraphRAGAgent ÂáΩÊï∞Ë¢´Ë∞ÉÁî® =======');
                console.log('üö® DEBUG: ÂáÜÂ§áÂèëÈÄÅFileÂØπË±°Âà∞GraphRAGÂêéÁ´ØÊúçÂä°');
                console.log('üö® DEBUG: - ÊúçÂä°ËøûÊé•Áä∂ÊÄÅ:', this.isConnected);
                console.log('üö® DEBUG: - ÂêéÁ´ØURL:', this.graphRAGUrl);
                
                // üö® DEBUG: ËØ¶ÁªÜÂàÜÊûê‰º†ÂÖ•ÁöÑFileÂØπË±°
                console.log('üö® DEBUG: ‰º†ÂÖ•FileÂØπË±°ËØ¶ÁªÜÂàÜÊûê:');
                console.log('üö® DEBUG: - FileÂêçÁß∞:', file.name);
                console.log('üö® DEBUG: - FileÂ§ßÂ∞è:', file.size, 'Â≠óËäÇ');
                console.log('üö® DEBUG: - FileÁ±ªÂûã:', file.type);
                console.log('üö® DEBUG: - ÊúÄÂêé‰øÆÊîπÊó∂Èó¥:', file.lastModified ? new Date(file.lastModified) : 'N/A');
                
                // üö® DEBUG: Ê£ÄÊü•Ëá™ÂÆö‰πâÂ±ûÊÄß
                if (file.sourceUrl) {
                    console.log('üö® DEBUG: - sourceUrlÂ≠òÂú®:', file.sourceUrl);
                    if (file.sourceUrl.includes('youtube.com') || file.sourceUrl.includes('youtu.be')) {
                        console.log('üö® DEBUG: ‚ö†Ô∏è  ÂÖ≥ÈîÆÔºöËøôÊòØYouTube URLÁîüÊàêÁöÑFileÂØπË±°ÔºÅ');
                        console.log('üö® DEBUG: ‚ö†Ô∏è  ÊúüÊúõÔºöGraphRAGÂêéÁ´ØÂ∫îËØ•Ê£ÄÊµãÂà∞ËøôÊòØËßÜÈ¢ëURLÂπ∂‰ΩøÁî®ËßÜÈ¢ëÊèêÂèñÁÆ°ÈÅì');
                        console.log('üö® DEBUG: ‚ö†Ô∏è  ÊúüÊúõÁªìÊûúÔºö2694Â≠óÁ¨¶ÁöÑËßÜÈ¢ëËΩ¨ÂΩïÂÜÖÂÆπ');
                        console.log('üö® DEBUG: ‚ö†Ô∏è  ÈóÆÈ¢òÂú∫ÊôØÔºöÂ¶ÇÊûúËøîÂõû98Â≠óÁ¨¶ËØ¥ÊòéË¢´ÈîôËØØÂΩì‰ΩúHTMLÊñá‰ª∂Â§ÑÁêÜ');
                    }
                }
                
                // üö® DEBUG: Â∞ùËØïÈ¢ÑËØªÊñá‰ª∂ÂÜÖÂÆπ
                try {
                    const fileContent = await file.text();
                    console.log('üö® DEBUG: - Êñá‰ª∂ÂÆûÈôÖÂÜÖÂÆπÈïøÂ∫¶:', fileContent.length);
                    console.log('üö® DEBUG: - Êñá‰ª∂ÂÜÖÂÆπÈ¢ÑËßàÔºàÂâç300Â≠óÁ¨¶Ôºâ:');
                    console.log('üö® DEBUG:   "' + fileContent.substring(0, 300) + '"');
                    
                    // Ê£ÄÊü•ÂÜÖÂÆπÁâπÂæÅ
                    const isUrl = fileContent.trim().startsWith('http') && fileContent.length < 200;
                    const isHtml = fileContent.includes('<html') || fileContent.includes('<!DOCTYPE');
                    const isYouTubeGeneric = fileContent.includes('ÂÖ≥‰∫é Êñ∞Èóª ÁâàÊùÉ');
                    
                    console.log('üö® DEBUG: - ÂÜÖÂÆπÁ±ªÂûãÂàÜÊûê:');
                    console.log('üö® DEBUG:   * ÊòØURL: ', isUrl);
                    console.log('üö® DEBUG:   * ÊòØHTML: ', isHtml);
                    console.log('üö® DEBUG:   * ÊòØYouTubeÈÄöÁî®È°µÈù¢: ', isYouTubeGeneric);
                    
                    if (isYouTubeGeneric) {
                        console.log('üö® DEBUG: ‚ö†Ô∏è  ÂèëÁé∞ÈóÆÈ¢òÔºöFileÂÜÖÂÆπÊòØYouTubeÈÄöÁî®È°µÈù¢Ôºå‰∏çÊòØËßÜÈ¢ëËΩ¨ÂΩïÔºÅ');
                        console.log('üö® DEBUG: ‚ö†Ô∏è  ËøôËØ¥ÊòéURLË¢´ÈîôËØØÂ§ÑÁêÜ‰∏∫HTMLÈ°µÈù¢ÊèêÂèñ');
                    }
                } catch (readError) {
                    console.log('üö® DEBUG: - Êó†Ê≥ïËØªÂèñÊñá‰ª∂ÂÜÖÂÆπ:', readError);
                }
                
                console.log('ü§ñ Ë∞ÉÁî®GraphRAG AgentËøõË°åÂ§öÊ†ºÂºèÊñáÊ°£Â§ÑÁêÜ');
                console.log('üìÑ Êñá‰ª∂‰ø°ÊÅØ:', {
                    name: file.name,
                    type: file.type,
                    size: file.size
                });
                
                try {
                    // üî• Áõ¥Êé•ÂèëÈÄÅÂéüÂßãÊñá‰ª∂ÁªôGraphRAGÔºåËÆ©ÂÆÉÂ§ÑÁêÜ
                    console.log('üöÄ Áõ¥Êé•ÂèëÈÄÅÊñá‰ª∂ÁªôGraphRAG AgentÂ§ÑÁêÜ');
                    const fileToSend = file;
                    
                    // ÂàõÂª∫FormDataÊù•ÂèëÈÄÅÊñá‰ª∂
                    const formData = new FormData();
                    formData.append('file', fileToSend);
                    formData.append('analysis_type', 'comprehensive'); // ÁªºÂêàÂàÜÊûê
                    formData.append('extract_entities', 'true'); // ÂÆû‰ΩìÊèêÂèñ
                    formData.append('extract_relationships', 'true'); // ÂÖ≥Á≥ªÊèêÂèñ
                    formData.append('community_detection', 'true'); // Á§æÂå∫Ê£ÄÊµã
                    
                    console.log('üìã ÂèëÈÄÅÂà∞GraphRAGÁöÑÂèÇÊï∞:', {
                        fileName: fileToSend.name,
                        fileType: fileToSend.type,
                        fileSize: fileToSend.size,
                        analysisType: 'comprehensive'
                    });
                    
                    // Ë∞ÉÁî®GraphRAG AgentÁöÑÂàÜÊûêAPIÔºåÊ∑ªÂä†Ë∂ÖÊó∂ÊéßÂà∂
                    console.log(`üåê Ê≠£Âú®Ë∞ÉÁî® ${this.baseUrl}/analyze`);
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30ÁßíË∂ÖÊó∂
                    
                    const response = await fetch(`${this.baseUrl}/graphrag/analyze`, {
                        method: 'POST',
                        body: formData,
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    console.log(`üì° GraphRAG APIÂìçÂ∫îÁä∂ÊÄÅ: ${response.status}`);
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('‚ùå GraphRAG APIÈîôËØØÂìçÂ∫î:', errorText);
                        throw new Error(`GraphRAG API error: ${response.status} - ${errorText}`);
                    }
                    
                    const graphRAGResult = await response.json();
                    
                    // üö® DEBUG: GraphRAG ÂêéÁ´ØÂìçÂ∫îËØ¶ÁªÜÂàÜÊûê
                    console.log('üö® DEBUG: ======= GraphRAGÂêéÁ´ØÂìçÂ∫îËØ¶ÁªÜÂàÜÊûê =======');
                    console.log('üö® DEBUG: ÂìçÂ∫îÁä∂ÊÄÅÁ†Å:', response.status);
                    console.log('üö® DEBUG: ÂìçÂ∫îÂÆåÊï¥ÂØπË±°:', graphRAGResult);
                    
                    // ÂàÜÊûêÂìçÂ∫îÁªìÊûÑ
                    console.log('üö® DEBUG: ÂìçÂ∫îÁªìÊûÑÂàÜÊûê:');
                    console.log('üö® DEBUG: - status:', graphRAGResult.status);
                    console.log('üö® DEBUG: - analysisÂ≠òÂú®:', !!graphRAGResult.analysis);
                    console.log('üö® DEBUG: - extraction_method:', graphRAGResult.extraction_method);
                    console.log('üö® DEBUG: - platform:', graphRAGResult.platform);
                    console.log('üö® DEBUG: - extraction_type:', graphRAGResult.extraction_type);
                    
                    if (graphRAGResult.analysis) {
                        const analysis = graphRAGResult.analysis;
                        console.log('üö® DEBUG: analysisÂØπË±°ËØ¶ÁªÜ‰ø°ÊÅØ:');
                        console.log('üö® DEBUG: - contentÈïøÂ∫¶:', analysis.content?.length || 0);
                        console.log('üö® DEBUG: - contentÈ¢ÑËßàÔºàÂâç200Â≠óÁ¨¶Ôºâ:', analysis.content?.substring(0, 200) || 'N/A');
                        console.log('üö® DEBUG: - entitiesÊï∞Èáè:', analysis.entities?.length || 0);
                        console.log('üö® DEBUG: - conceptsÊï∞Èáè:', analysis.concepts?.length || 0);
                        console.log('üö® DEBUG: - relationshipsÊï∞Èáè:', analysis.relationships?.length || 0);
                        console.log('üö® DEBUG: - confidence:', analysis.confidence);
                        
                        // Ê£ÄÊü•ÂÜÖÂÆπË¥®Èáè
                        if (analysis.content) {
                            const isGeneric = analysis.content.includes('ÂÖ≥‰∫é Êñ∞Èóª ÁâàÊùÉ');
                            const isShort = analysis.content.length < 200;
                            const hasVideoContent = analysis.content.includes('‚ô™') || 
                                                  analysis.content.includes('lyrics') || 
                                                  analysis.content.includes('transcript');
                            
                            console.log('üö® DEBUG: ÂÜÖÂÆπË¥®ÈáèÂàÜÊûê:');
                            console.log('üö® DEBUG: - ÊòØÈÄöÁî®YouTubeÈ°µÈù¢:', isGeneric);
                            console.log('üö® DEBUG: - ÂÜÖÂÆπËøáÁü≠ (<200):', isShort);
                            console.log('üö® DEBUG: - ÂåÖÂê´ËßÜÈ¢ëÂÜÖÂÆπÊ†áËØÜ:', hasVideoContent);
                            
                            if (isGeneric) {
                                console.log('üö® DEBUG: ‚ö†Ô∏è  ÈóÆÈ¢òÁ°ÆËÆ§ÔºöËøîÂõûÁöÑÊòØYouTubeÈÄöÁî®È°µÈù¢ÂÜÖÂÆπÔºå‰∏çÊòØËßÜÈ¢ëËΩ¨ÂΩïÔºÅ');
                                console.log('üö® DEBUG: ‚ö†Ô∏è  ËøôË°®ÊòéÂêéÁ´ØÊ≤°ÊúâÊ≠£Á°ÆÊ£ÄÊµãÂà∞ËøôÊòØËßÜÈ¢ëURL');
                            }
                            
                            if (hasVideoContent) {
                                console.log('üö® DEBUG: ‚úÖ Â•ΩÊ∂àÊÅØÔºöÊ£ÄÊµãÂà∞ËßÜÈ¢ëÂÜÖÂÆπÔºåÁ≥ªÁªüÂ∑•‰ΩúÊ≠£Â∏∏ÔºÅ');
                            }
                        }
                        
                        // Ê£ÄÊü•Êñá‰ª∂‰ø°ÊÅØ
                        if (analysis.fileInfo) {
                            console.log('üö® DEBUG: fileInfoÂØπË±°:');
                            console.log('üö® DEBUG: - filename:', analysis.fileInfo.filename);
                            console.log('üö® DEBUG: - type:', analysis.fileInfo.type);
                            console.log('üö® DEBUG: - source_url:', analysis.fileInfo.source_url);
                            console.log('üö® DEBUG: - textLength:', analysis.fileInfo.textLength);
                        }
                    }
                    
                    console.log('üö® DEBUG: ======= GraphRAGÂìçÂ∫îÂàÜÊûêÂÆåÊàê =======');
                    console.log('‚úÖ GraphRAG AgentÂàÜÊûêÂÆåÊàê!');
                    console.log('üîç ÂÆåÊï¥ÂàÜÊûêÁªìÊûú:', JSON.stringify(graphRAGResult, null, 2));
                    
                    // üéØ Á°ÆËÆ§ËøôÊòØÁúüÊ≠£ÁöÑGraphRAGÂàÜÊûê
                    if (graphRAGResult.analysis) {
                        console.log('üß† AIÂàÜÊûêÂÜÖÂÆπ:', graphRAGResult.analysis.content?.substring(0, 100) + '...');
                        console.log('üè∑Ô∏è ÊèêÂèñÁöÑÊ¶ÇÂøµ:', graphRAGResult.analysis.concepts);
                        console.log('üë• ËØÜÂà´ÁöÑÂÆû‰Ωì:', graphRAGResult.analysis.entities);
                        console.log('üìç Âª∫ËÆÆ‰ΩçÁΩÆ:', graphRAGResult.analysis.knowledgeTreeSuggestion);
                        console.log('üéØ ÁΩÆ‰ø°Â∫¶:', graphRAGResult.analysis.confidence);
                    }
                    
                    // ËΩ¨Êç¢GraphRAGÁªìÊûú‰∏∫Êàë‰ª¨ÁöÑÊ†ºÂºè - ÈÄÇÈÖçÊñ∞APIÁªìÊûÑ
                    const analysis = graphRAGResult.analysis || {};
                    const fileInfo = analysis.fileInfo || {};
                    
                    return {
                        fileName: file.name,
                        fileType: fileInfo.type || this.identifyFileType(file),
                        fileSize: fileInfo.size || file.size,
                        analysisTimestamp: new Date().toISOString(),
                        extractedContent: analysis.content || 'ÊñáÊ°£ÂàÜÊûêÂÆåÊàê',
                        concepts: analysis.concepts || [],
                        entities: analysis.entities || [],
                        relationships: analysis.relationships || [],
                        communities: analysis.communities || [],
                        positionSuggestion: {
                            primarySuggestion: {
                                path: analysis.knowledgeTreeSuggestion || this.mapGraphRAGToKnowledgeTree(analysis),
                                confidence: analysis.confidence || 0.88
                            },
                            alternatives: this.generateAlternativesFromGraphRAG(analysis)
                        },
                        processingStage: 'completed',
                        confidence: analysis.confidence || 0.88,
                        graphData: analysis.graph_data,
                        isGraphRAGAnalysis: true
                    };
                    
                } catch (error) {
                    console.error('‚ùå GraphRAG AgentË∞ÉÁî®Â§±Ë¥•:', error);
                    
                    // Â¶ÇÊûúÊòØË∂ÖÊó∂ÊàñÁΩëÁªúÈîôËØØÔºå‰ΩøÁî®Â§áÁî®ÂàÜÊûê
                    if (error.name === 'AbortError') {
                        console.log('‚è±Ô∏è GraphRAG APIË∞ÉÁî®Ë∂ÖÊó∂Ôºå‰ΩøÁî®Â§áÁî®ÂàÜÊûê');
                    } else {
                        console.log('üîÑ GraphRAG APIË∞ÉÁî®Â§±Ë¥•Ôºå‰ΩøÁî®Â§áÁî®ÂàÜÊûê');
                    }
                    
                    // ÂõûÈÄÄÂà∞ÂÜÖÁΩÆÂàÜÊûê
                    this.isConnected = false;
                    return this.fallbackAnalysis(file);
                }
            }
            
            // üîÑ Â§áÁî®ÂàÜÊûêÊñπÊ≥ïÔºàÂΩìGraphRAGÂ§±Ë¥•Êó∂‰ΩøÁî®Ôºâ
            async fallbackAnalysis(file) {
                console.log('üîÑ ‰ΩøÁî®Â§áÁî®ÂàÜÊûêÊñπÊ≥ï:', file.name);
                
                try {
                    // Â∞ùËØï‰ΩøÁî®ÂÜÖÁΩÆAIÂàÜÊûê
                    const content = await this.extractFileContent(file);
                    const analysis = await this.analyzeFileContent(file, content);
                    
                    if (analysis) {
                        console.log('‚úÖ Â§áÁî®ÂàÜÊûêÊàêÂäü');
                        return analysis;
                    }
                } catch (error) {
                    console.log('‚ùå Â§áÁî®AIÂàÜÊûê‰πüÂ§±Ë¥•:', error.message);
                }
                
                // ÊúÄÂêéÂõûÈÄÄÂà∞Âü∫Êú¨ÂàÜÊûê
                console.log('üîß ‰ΩøÁî®Âü∫Êú¨Êñá‰ª∂ÂàÜÊûê');
                return {
                    fileName: file.name,
                    fileType: this.identifyFileType(file),
                    fileSize: file.size,
                    analysisTimestamp: new Date().toISOString(),
                    extractedContent: `ËøôÊòØÊñá‰ª∂ "${file.name}" ÁöÑÂü∫Êú¨‰ø°ÊÅØ„ÄÇÊñá‰ª∂Â§ßÂ∞è: ${(file.size/1024).toFixed(1)} KB`,
                    concepts: ['ÊñáÊ°£', 'Â∑≤‰∏ä‰º†'],
                    entities: [file.name.split('.')[0]],
                    relationships: [],
                    communities: [],
                    positionSuggestion: {
                        primarySuggestion: {
                            path: `ÊñáÊ°£ÁÆ°ÁêÜ/${this.identifyFileType(file).supportedFormat}Êñá‰ª∂`,
                            confidence: 0.6
                        },
                        alternatives: []
                    },
                    processingStage: 'completed',
                    confidence: 0.6,
                    isGraphRAGAnalysis: false
                };
            }
            
            // Â∞ÜGraphRAGÁªìÊûúÊò†Â∞ÑÂà∞Áü•ËØÜÊ†ë‰ΩçÁΩÆ
            mapGraphRAGToKnowledgeTree(analysis) {
                // ‰ºòÂÖà‰ΩøÁî®APIËøîÂõûÁöÑknowledgeTreeSuggestion
                if (analysis.knowledgeTreeSuggestion) {
                    return analysis.knowledgeTreeSuggestion;
                }
                
                // Âü∫‰∫éÊ¶ÇÂøµÂàÜÊûêÊù•Âª∫ËÆÆ‰ΩçÁΩÆ
                if (analysis.concepts && analysis.concepts.length > 0) {
                    const primaryConcept = analysis.concepts[0];
                    return `Ê¶ÇÂøµÁü•ËØÜ/${primaryConcept}`;
                }
                
                // Âü∫‰∫éÂÆû‰ΩìÂàÜÊûêÊù•Âª∫ËÆÆ‰ΩçÁΩÆ  
                if (analysis.entities && analysis.entities.length > 0) {
                    const primaryEntity = analysis.entities[0];
                    return `ÂÆû‰ΩìÁü•ËØÜ/${primaryEntity}`;
                }
                
                return 'Êô∫ËÉΩÂàÜÁ±ª/GraphRAGÂàÜÊûê';
            }
            
            // ‰ªéGraphRAGÁªìÊûúÁîüÊàêÊõø‰ª£Âª∫ËÆÆ
            generateAlternativesFromGraphRAG(graphRAGResult) {
                const alternatives = [];
                
                if (graphRAGResult.communities) {
                    graphRAGResult.communities.slice(1, 4).forEach(community => {
                        alternatives.push({
                            path: `${community.category}/${community.subcategory}`,
                            confidence: community.confidence || 0.7,
                            reason: `Âü∫‰∫éÁ§æÂå∫Ê£ÄÊµã: ${community.description}`
                        });
                    });
                }
                
                return alternatives;
            }
            
            // Êô∫ËÉΩÂÜÖÂÆπÂàÜÊûê - Áõ¥Êé•Âü∫‰∫éÊñá‰ª∂ÂÜÖÂÆπ
            async analyzeFileContent(file, content) {
                console.log('üß† Êô∫ËÉΩÂàÜÊûêÊñá‰ª∂ÂÜÖÂÆπ:', file.name, 'ÂÜÖÂÆπÈïøÂ∫¶:', content ? content.length : 0);
                
                try {
                    // ‰ΩøÁî®GPT-4oËøõË°åÁúüÂÆûÂÜÖÂÆπÂàÜÊûê
                    const analysis = await this.callOpenAIWithContent(file.name, content);
                    if (analysis) {
                        console.log('‚úÖ OpenAIÂàÜÊûêÊàêÂäü');
                        return analysis;
                    }
                } catch (error) {
                    console.log('‚ùå AIÂàÜÊûêÂ§±Ë¥•Ôºå‰ΩøÁî®Êô∫ËÉΩËßÑÂàôÂºïÊìé:', error.message);
                }
                
                // Â§áÁî®ÊñπÊ°àÔºöÂü∫‰∫éÁúüÂÆûÂÜÖÂÆπÁöÑÊô∫ËÉΩÂàÜÊûê
                return this.smartContentAnalysis(file.name, content);
            }
            
            // Âü∫‰∫éÁúüÂÆûÂÜÖÂÆπÁöÑOpenAIÂàÜÊûê
            async callOpenAIWithContent(fileName, content) {
                const apiKey = process.env.OPENAI_API_KEY || 'your-openai-api-key-here';
                
                if (!apiKey) {
                    throw new Error('No OpenAI API key configured');
                }
                
                // Â¢ûÂä†ÂÜÖÂÆπÊèêÂèñÈïøÂ∫¶‰ª•Ëé∑ÂæóÊõ¥‰∏∞ÂØåÁöÑÂàÜÊûê
                const contentSample = content ? content.substring(0, 6000) : '';
                console.log(`üìÑ Â§ÑÁêÜÂÜÖÂÆπÈïøÂ∫¶: ${contentSample.length} Â≠óÁ¨¶`);
                
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [{
                            role: 'system',
                            content: '‰Ω†ÊòØ‰∏Ä‰∏™‰∏ì‰∏öÁöÑÁü•ËØÜÂõæË∞±ÊûÑÂª∫‰∏ìÂÆ∂Ôºå‰∏ìÈó®‰ªéÊñáÊ°£‰∏≠ÊèêÂèñ‰∏∞ÂØåÁöÑÂÆû‰Ωì„ÄÅÊ¶ÇÂøµÂíåÂÖ≥Á≥ª„ÄÇËØ∑ËøîÂõûËØ¶ÁªÜÁöÑÁªìÊûÑÂåñÂàÜÊûêÁªìÊûú„ÄÇ'
                        }, {
                            role: 'user',
                            content: `ËØ∑ÂØπ‰ª•‰∏ãÊñáÊ°£ËøõË°åÊ∑±Â∫¶Áü•ËØÜÂõæË∞±ÂàÜÊûêÔºö

ÊñáÊ°£ÂêçÁß∞: ${fileName}
ÊñáÊ°£ÂÜÖÂÆπ: 
${contentSample}

ÂàÜÊûêË¶ÅÊ±ÇÔºö
1. ÊèêÂèñÊäÄÊúØÊ¶ÇÂøµ„ÄÅÂ∑•ÂÖ∑„ÄÅÊ°ÜÊû∂„ÄÅÊñπÊ≥ïËÆ∫Á≠â‰∏ì‰∏öÂÆû‰Ωì
2. ËØÜÂà´‰∏öÂä°Ê¶ÇÂøµ„ÄÅÊµÅÁ®ã„ÄÅËßíËâ≤„ÄÅÂäüËÉΩÊ®°ÂùóÁ≠â‰∏öÂä°ÂÆû‰Ωì  
3. ÂèëÁé∞Ê¶ÇÂøµÈó¥ÁöÑÂ±ÇÊ¨°ÂÖ≥Á≥ª„ÄÅ‰æùËµñÂÖ≥Á≥ª„ÄÅÂÖ≥ËÅîÂÖ≥Á≥ª
4. Êèê‰æõËØ¶ÁªÜÁöÑÂÜÖÂÆπÊëòË¶ÅÂíåÂàÜÊûê
5. ÁâπÂà´ÂÖ≥Ê≥®ÔºöÁ≥ªÁªüÊû∂ÊûÑ„ÄÅÊäÄÊúØÊ†à„ÄÅ‰∏öÂä°ÊµÅÁ®ã„ÄÅ‰∫ßÂìÅÂäüËÉΩÁ≠âÊ†∏ÂøÉË¶ÅÁ¥†

ËØ∑ËøîÂõûJSONÊ†ºÂºèÔºàÊó†markdownÂåÖË£ÖÔºâÔºö
{
  "content": "ËØ¶ÁªÜÁöÑ500-800Â≠óÂÜÖÂÆπÂàÜÊûêÊëòË¶ÅÔºåÂåÖÂê´ÊäÄÊúØÊû∂ÊûÑ„ÄÅ‰∏öÂä°ÊµÅÁ®ã„ÄÅÂÖ≥ÈîÆÁâπÊÄßÁ≠â",
  "concepts": [
    "Ê†∏ÂøÉ‰∏öÂä°Ê¶ÇÂøµ1", "ÊäÄÊúØÊû∂ÊûÑÊ¶ÇÂøµ2", "ÊñπÊ≥ïËÆ∫Ê¶ÇÂøµ3", "Â∑•ÂÖ∑Ê°ÜÊû∂4", "ÊµÅÁ®ãÊ¶ÇÂøµ5",
    "Á≥ªÁªüÊ®°Âùó6", "Êï∞ÊçÆÊ¶ÇÂøµ7", "Áî®Êà∑‰ΩìÈ™å8", "ÊÄßËÉΩ‰ºòÂåñ9", "ÂÆâÂÖ®Êú∫Âà∂10"
  ],
  "entities": [
    "ÂÖ∑‰ΩìÊäÄÊúØÂ∑•ÂÖ∑1", "‰∏öÂä°ÂÆû‰Ωì2", "Á≥ªÁªüÁªÑ‰ª∂3", "Êï∞ÊçÆË°®4", "APIÊé•Âè£5",
    "Áî®Êà∑ËßíËâ≤6", "ÂäüËÉΩÊ®°Âùó7", "ÁÆóÊ≥ïÊ®°Âûã8", "Âπ≥Âè∞ÊúçÂä°9", "Ê†áÂáÜËßÑËåÉ10"
  ],
  "relationships": [
    {"source": "ÂÆû‰ΩìA", "target": "ÂÆû‰ΩìB", "type": "contains", "description": "ÂåÖÂê´ÂÖ≥Á≥ª"},
    {"source": "Ê¶ÇÂøµC", "target": "Ê¶ÇÂøµD", "type": "implements", "description": "ÂÆûÁé∞ÂÖ≥Á≥ª"},
    {"source": "Â∑•ÂÖ∑E", "target": "ÊµÅÁ®ãF", "type": "supports", "description": "ÊîØÊåÅÂÖ≥Á≥ª"}
  ],
  "knowledgeTreeSuggestion": "ÊäÄÊúØÊû∂ÊûÑ/Êô∫ËÉΩÂÜÖÂÆπÂ∑•‰ΩúÊµÅ/‰∫ßÂìÅÈúÄÊ±ÇÁÆ°ÁêÜ",
  "confidence": 0.9
}`
                        }],
                        temperature: 0.2,
                        max_tokens: 2000
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`OpenAI API error: ${response.status}`);
                }
                
                const data = await response.json();
                const aiResponse = data.choices[0].message.content;
                
                console.log('ü§ñ OpenAIÂéüÂßãÂìçÂ∫î:', aiResponse);
                console.log('üìè ÂìçÂ∫îÈïøÂ∫¶:', aiResponse.length);
                console.log('üîç ÂìçÂ∫îÂâç50Â≠óÁ¨¶:', aiResponse.substring(0, 50));
                
                try {
                    // Ê∏ÖÁêÜÂìçÂ∫îÂÜÖÂÆπ - ÁßªÈô§ÂèØËÉΩÁöÑmarkdown‰ª£Á†ÅÂùóÊ†áËÆ∞
                    let cleanResponse = aiResponse.trim();
                    if (cleanResponse.startsWith('```json')) {
                        cleanResponse = cleanResponse.replace(/^```json\s*/, '').replace(/```\s*$/, '');
                    }
                    if (cleanResponse.startsWith('```')) {
                        cleanResponse = cleanResponse.replace(/^```\s*/, '').replace(/```\s*$/, '');
                    }
                    
                    console.log('üßπ Ê∏ÖÁêÜÂêéÁöÑÂìçÂ∫î:', cleanResponse);
                    
                    const parsed = JSON.parse(cleanResponse);
                    console.log('‚úÖ JSONËß£ÊûêÊàêÂäü:', parsed);
                    
                    return {
                        content: parsed.content || 'Êô∫ËÉΩÂàÜÊûêÁöÑÊñáÊ°£ÂÜÖÂÆπ',
                        concepts: parsed.concepts || [],
                        entities: parsed.entities || [],
                        relationships: parsed.relationships || [],
                        knowledgeTreeSuggestion: parsed.knowledgeTreeSuggestion || 'Êô∫ËÉΩÂàÜÁ±ª',
                        confidence: parsed.confidence || 0.8,
                        fileSize: content ? content.length : 0
                    };
                } catch (parseError) {
                    console.error('‚ùå AIÂìçÂ∫îJSONËß£ÊûêÂ§±Ë¥•:', parseError);
                    console.log('üîç ÂéüÂßãÂìçÂ∫îÂÜÖÂÆπ:', aiResponse);
                    console.log('üîÑ ÂõûÈÄÄÂà∞Êô∫ËÉΩËßÑÂàôÂºïÊìé');
                    return this.smartContentAnalysis(fileName, content);
                }
            }
            
            // Êô∫ËÉΩÂÜÖÂÆπÂàÜÊûê - Â§áÁî®ÊñπÊ°à
            smartContentAnalysis(fileName, content) {
                console.log('üßÆ ‰ΩøÁî®Êô∫ËÉΩËßÑÂàôÂºïÊìéÂàÜÊûêÂÜÖÂÆπ');
                
                const fileExt = fileName.split('.').pop().toLowerCase();
                const contentSample = content ? content.substring(0, 500) : '';
                
                // Âü∫‰∫éÂÜÖÂÆπÁöÑÊô∫ËÉΩÊé®Êñ≠
                let category = 'Êú™ÂàÜÁ±ª';
                let concepts = [];
                let entities = [];
                
                if (fileExt === 'pdf') {
                    category = 'ÊñáÊ°£/PDFËµÑÊñô';
                    concepts = ['PDFÊñáÊ°£', 'Êñá‰ª∂ËµÑÊñô'];
                } else if (contentSample.includes('API') || contentSample.includes('Êé•Âè£')) {
                    category = 'ÂºÄÂèë/APIÊñáÊ°£';
                    concepts = ['API', 'Êé•Âè£ÊñáÊ°£'];
                } else if (contentSample.includes('ÈúÄÊ±Ç') || contentSample.includes('ÂäüËÉΩ')) {
                    category = 'È°πÁõÆ/ÈúÄÊ±ÇÊñáÊ°£';
                    concepts = ['‰∫ßÂìÅÈúÄÊ±Ç', 'ÂäüËÉΩËÆæËÆ°'];
                } else if (contentSample.includes('‰ª£Á†Å') || contentSample.includes('function')) {
                    category = 'ÂºÄÂèë/‰ª£Á†ÅËµÑÊñô';
                    concepts = ['‰ª£Á†Å', 'ÂºÄÂèë'];
                }
                
                return {
                    content: contentSample || `${fileName} ÊñáÊ°£ÂÜÖÂÆπ`,
                    concepts: concepts,
                    entities: entities,
                    knowledgeTreeSuggestion: category,
                    confidence: 0.6,
                    fileSize: content ? content.length : 0
                };
            }

            // Â∑≤Â∫üÂºÉÔºö‰ΩøÁî®Êñ∞ÁöÑanalyzeFileContentÊñπÊ≥ï‰ª£Êõø
            async analyzeFileNameWithAI(fileName, fileSize) {
                console.log('‚ö†Ô∏è  analyzeFileNameWithAIÂ∑≤Â∫üÂºÉÔºåËØ∑‰ΩøÁî®analyzeFileContent');
                // ‰∏∫ÂÖºÂÆπÊÄß‰øùÁïôÔºå‰ΩÜÂª∫ËÆÆ‰ΩøÁî®Êñ∞ÊñπÊ≥ï
                return this.smartContentAnalysis(fileName, '');
            }
            
            // Â∑≤Â∫üÂºÉÔºö‰ΩøÁî®callOpenAIWithContent‰ª£Êõø
            async callOpenAI(fileName, fileSize) {
                console.log('‚ö†Ô∏è  callOpenAIÂ∑≤Â∫üÂºÉÔºå‰ΩøÁî®callOpenAIWithContent');
                return this.callOpenAIWithContent(fileName, `Êñá‰ª∂: ${fileName}`);
            }
            
            // Â∑≤Âà†Èô§ÔºöÊú¨Âú∞AIË∞ÉÁî®ÂäüËÉΩÔºàÁÆÄÂåñÁ≥ªÁªüÊû∂ÊûÑÔºâ
            
            // Ëß£ÊûêAIÂàÜÊûêÂìçÂ∫î
            parseAIAnalysisResponse(aiContent, fileName, fileSize) {
                console.log('üîç Parsing AI analysis response');
                
                return {
                    aiGenerated: true,
                    aiContent: aiContent,
                    inferredContent: this.extractInferredContent(aiContent),
                    aiEntities: this.extractAIEntities(aiContent),
                    aiConcepts: this.extractAIConcepts(aiContent),
                    aiClassification: this.extractAIClassification(aiContent),
                    confidence: 0.85,
                    source: 'AI Analysis',
                    fileName: fileName,
                    fileSize: fileSize
                };
            }
            
            // Â¢ûÂº∫ÁöÑËßÑÂàôÂºïÊìéÂàÜÊûê
            async enhancedRuleBasedAnalysis(fileName, fileSize) {
                console.log('üßÆ Using enhanced rule-based analysis (AI simulation)');
                
                const analysis = {
                    fileName,
                    fileSize,
                    aiGenerated: false,
                    confidence: 0.7,
                    source: 'Enhanced Rule Engine'
                };
                
                // Âü∫‰∫éÊñá‰ª∂ÂêçÁöÑÊô∫ËÉΩÊé®Êñ≠
                const lowerName = fileName.toLowerCase();
                
                // Ê£ÄÊµã‰∏≠ÊñáÂÜÖÂÆπ
                const hasChinese = /[\u4e00-\u9fa5]/.test(fileName);
                
                // Êô∫ËÉΩÂÜÖÂÆπÊé®Êñ≠
                if (lowerName.includes('ÈúÄÊ±Ç') || lowerName.includes('requirement')) {
                    analysis.inferredContent = `ËøôÊòØ‰∏Ä‰∏™ÈúÄÊ±ÇÊñáÊ°£ÔºåÂèØËÉΩÂåÖÂê´Ôºö\n- ‰∫ßÂìÅÂäüËÉΩÈúÄÊ±Ç\n- Áî®Êà∑ÊïÖ‰∫ãÂíåÁî®‰æã\n- ÊäÄÊúØËßÑÊ†ºËØ¥Êòé\n- È™åÊî∂Ê†áÂáÜ\n- Á≥ªÁªüÊû∂ÊûÑËÆæËÆ°`;
                    analysis.aiEntities = ['‰∫ßÂìÅÈúÄÊ±Ç', 'ÂäüËÉΩËßÑÊ†º', 'Áî®Êà∑‰ΩìÈ™å', 'Á≥ªÁªüËÆæËÆ°'];
                    analysis.aiConcepts = ['ÈúÄÊ±ÇÁÆ°ÁêÜ', '‰∫ßÂìÅËÆæËÆ°', 'Áî®Êà∑Á†îÁ©∂'];
                    analysis.aiClassification = 'ÊñáÊ°£/‰∫ßÂìÅÈúÄÊ±Ç';
                } else if (lowerName.includes('insight') || lowerName.includes('ÂàÜÊûê')) {
                    analysis.inferredContent = `ËøôÊòØ‰∏Ä‰∏™Ê¥ûÂØüÂàÜÊûêÊñáÊ°£ÔºåÂèØËÉΩÂåÖÂê´Ôºö\n- Êï∞ÊçÆÂàÜÊûêÁªìÊûú\n- Â∏ÇÂú∫Ë∞ÉÁ†îÂèëÁé∞\n- Áî®Êà∑Ë°å‰∏∫Ê¥ûÂØü\n- ÂïÜ‰∏öÊô∫ËÉΩÊä•Âëä\n- Ë∂ãÂäøÂàÜÊûê`;
                    analysis.aiEntities = ['Êï∞ÊçÆÂàÜÊûê', 'Â∏ÇÂú∫Ê¥ûÂØü', 'Áî®Êà∑Ë°å‰∏∫', 'ÂïÜ‰∏öÊô∫ËÉΩ'];
                    analysis.aiConcepts = ['Êï∞ÊçÆÁßëÂ≠¶', 'Â∏ÇÂú∫Á†îÁ©∂', 'Áî®Êà∑ÂàÜÊûê'];
                    analysis.aiClassification = 'Êï∞ÊçÆ/ÂàÜÊûêÊä•Âëä';
                } else if (lowerName.includes('api') || lowerName.includes('Êé•Âè£')) {
                    analysis.inferredContent = `ËøôÊòØ‰∏Ä‰∏™APIÊñáÊ°£ÔºåÂèØËÉΩÂåÖÂê´Ôºö\n- Êé•Âè£ËßÑËåÉËØ¥Êòé\n- ËØ∑Ê±ÇÂìçÂ∫îÊ†ºÂºè\n- ËÆ§ËØÅÊñπÂºè\n- ÈîôËØØ‰ª£Á†Å\n- ‰ΩøÁî®Á§∫‰æã`;
                    analysis.aiEntities = ['APIÊé•Âè£', 'REST', 'JSON', 'HTTP'];
                    analysis.aiConcepts = ['Êé•Âè£ËÆæËÆ°', 'WebÊúçÂä°', 'APIÁÆ°ÁêÜ'];
                    analysis.aiClassification = 'ÊäÄÊúØ/APIÊñáÊ°£';
                } else if (lowerName.includes('report') || lowerName.includes('Êä•Âëä')) {
                    analysis.inferredContent = `ËøôÊòØ‰∏Ä‰∏™Êä•ÂëäÊñáÊ°£ÔºåÂèØËÉΩÂåÖÂê´Ôºö\n- ÊâßË°åÊëòË¶Å\n- ËØ¶ÁªÜÂàÜÊûê\n- ÁªìËÆ∫Âª∫ËÆÆ\n- Êï∞ÊçÆÂõæË°®\n- ÈôÑÂΩïËµÑÊñô`;
                    analysis.aiEntities = ['Êä•Âëä', 'ÂàÜÊûêÁªìÊûú', 'Âª∫ËÆÆ', 'Êï∞ÊçÆ'];
                    analysis.aiConcepts = ['ÂïÜ‰∏öÂàÜÊûê', 'Êä•ÂëäÊí∞ÂÜô', 'Êï∞ÊçÆÂëàÁé∞'];
                    analysis.aiClassification = 'ÊñáÊ°£/ÂàÜÊûêÊä•Âëä';
                } else {
                    // ÈÄöÁî®ÂàÜÊûê
                    analysis.inferredContent = `Âü∫‰∫éÊñá‰ª∂Âêç"${fileName}"ÁöÑÂàÜÊûêÔºö\n- Êñá‰ª∂Â§ßÂ∞è: ${Math.round(fileSize/1024)}KB\n- ÂèØËÉΩÊòØ${hasChinese ? '‰∏≠Êñá' : 'Ëã±Êñá'}ÊñáÊ°£\n- ÈúÄË¶ÅËøõ‰∏ÄÊ≠•ÂÜÖÂÆπÂàÜÊûêÁ°ÆÂÆöÂÖ∑‰ΩìÁ±ªÂûã`;
                    analysis.aiEntities = [fileName.split('.')[0], 'ÊñáÊ°£ÂÜÖÂÆπ'];
                    analysis.aiConcepts = ['ÊñáÊ°£ÁÆ°ÁêÜ', 'ÂÜÖÂÆπÂàÜÊûê'];
                    analysis.aiClassification = 'ÊñáÊ°£/ÂÖ∂‰ªñ';
                }
                
                return analysis;
            }
            
            // ‰ªéAIÂìçÂ∫î‰∏≠ÊèêÂèñÊé®Êñ≠ÂÜÖÂÆπ
            extractInferredContent(aiContent) {
                const lines = aiContent.split('\n').filter(line => line.trim().length > 0);
                return lines.slice(0, 5).join('\n');
            }
            
            // ‰ªéAIÂìçÂ∫î‰∏≠ÊèêÂèñÂÆû‰Ωì
            extractAIEntities(aiContent) {
                const entities = [];
                const lowerContent = aiContent.toLowerCase();
                
                // ÂØªÊâæÂÆû‰ΩìÁõ∏ÂÖ≥ÁöÑÂÖ≥ÈîÆËØç
                const patterns = [
                    /ÂÆû‰Ωì[Ôºö:]\s*([^„ÄÇ\n]+)/g,
                    /entities[Ôºö:]\s*([^.\n]+)/g,
                    /ÂÖ≥ÈîÆËØç[Ôºö:]\s*([^„ÄÇ\n]+)/g,
                    /keywords[Ôºö:]\s*([^.\n]+)/g
                ];
                
                patterns.forEach(pattern => {
                    let match;
                    while ((match = pattern.exec(aiContent)) !== null) {
                        const entityText = match[1];
                        const entityList = entityText.split(/[,Ôºå„ÄÅ]/).map(e => e.trim()).filter(e => e.length > 0);
                        entities.push(...entityList);
                    }
                });
                
                // ËøáÊª§ÊéâÂä®‰ΩúÁü≠ËØ≠Âíå‰∏çÂêàÈÄÇÁöÑÂÆû‰Ωì
                const filteredEntities = entities.filter(entity => this.isValidEntity(entity));
                
                return filteredEntities.slice(0, 10); // ÈôêÂà∂Êï∞Èáè
            }

            // ÂÆû‰ΩìÈ™åËØÅÂáΩÊï∞Ôºå‰ºòÂåñËøáÊª§ÈÄªËæë‰øùÁïôÊõ¥Â§öÊúâÊïàÂÆû‰Ωì
            isValidEntity(entity) {
                if (!entity || entity.length < 2) return false;
                
                const entityLower = entity.toLowerCase().trim();
                
                // Âè™ËøáÊª§ÊòéÊòæÁöÑÂä®‰ΩúÁü≠ËØ≠ÂºÄÂ§¥ÔºàÂáèÂ∞ëËøáÊª§Ôºâ
                const strictActionPhrases = [
                    'ÊèêÂçá', '‰ºòÂåñ', 'ÊîπËøõ', 'Â¢ûÂº∫', 'Âª∫Á´ã', 'ÂàõÂª∫', 'ÂºÄÂèë', 'ËÆæËÆ°', 'ÂÆûÁé∞', 'ÊûÑÂª∫',
                    'Âà∂ÂÆö', 'ÊâßË°å', 'Êé®Ëøõ', 'Âº∫Âåñ', 'Âä†Âº∫', 'ÂÆåÂñÑ'
                ];
                
                // Ê£ÄÊü•ÊòØÂê¶‰ª•Âä®‰ΩúËØçÂºÄÂ§¥
                for (const action of strictActionPhrases) {
                    if (entityLower.startsWith(action) && entityLower.length <= action.length + 2) {
                        return false; // Âè™ËøáÊª§Á∫ØÂä®‰ΩúËØçÔºå‰∏çËøáÊª§Â§çÂêàÊ¶ÇÂøµ
                    }
                }
                
                // ËøáÊª§ÊéâÂ§™Áü≠ÊàñÂ§™ÈïøÁöÑÂÆû‰Ωì
                if (entityLower.length < 2 || entityLower.length > 30) return false;
                
                // ËøáÊª§ÊéâÁ∫ØÊï∞Â≠óÊàñÁ∫ØÁ¨¶Âè∑
                if (/^[\d\s\-_]+$/.test(entityLower) || /^[^\w\u4e00-\u9fa5]+$/.test(entityLower)) {
                    return false;
                }
                
                // Âè™ËøáÊª§ÊúÄÂü∫Á°ÄÁöÑÂÅúÁî®ËØç
                const basicStopWords = [
                    'ÁöÑ', 'Âíå', '‰∏é', 'Êàñ', '‰ΩÜ', 'ËÄå', 'Âú®', '‰∏∫', '‰ªé', 'Âà∞', 'Áî±',
                    'Ëøô', 'ÈÇ£', 'Ëøô‰∏™', 'ÈÇ£‰∏™', '‰ªÄ‰πà', 'Â¶Ç‰Ωï', '‰∏∫‰ªÄ‰πà', 'ÊÄé‰πà',
                    'ÊòØ', 'Êúâ', 'Ê≤°Êúâ', 'ÂèØ‰ª•', 'Â∫îËØ•', 'ÂøÖÈ°ª',
                    'the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by',
                    'is', 'are', 'was', 'were', 'be', 'been', 'have', 'has', 'had'
                ];
                
                if (basicStopWords.includes(entityLower)) {
                    return false;
                }
                
                // ÂÖÅËÆ∏Êõ¥Â§öÊäÄÊúØÂíå‰∏öÂä°Ê¶ÇÂøµÈÄöËøáÔºàÂáèÂ∞ëÈÄöÁî®ËØçËøáÊª§Ôºâ
                const allowedPatterns = [
                    /Á≥ªÁªü/, /Âπ≥Âè∞/, /ÊúçÂä°/, /Ê®°Âùó/, /ÁªÑ‰ª∂/, /Êû∂ÊûÑ/, /Ê°ÜÊû∂/, /Â∑•ÂÖ∑/, /ÊäÄÊúØ/, /ÊñπÊ°à/,
                    /ÊµÅÁ®ã/, /ÁÆ°ÁêÜ/, /ÂàÜÊûê/, /ËÆæËÆ°/, /ÂºÄÂèë/, /‰∫ßÂìÅ/, /Áî®Êà∑/, /ÂäüËÉΩ/, /Êé•Âè£/, /Êï∞ÊçÆ/,
                    /Êô∫ËÉΩ/, /ÁÆóÊ≥ï/, /Ê®°Âûã/, /ÂºïÊìé/, /ÁΩëÁªú/, /ÂÆâÂÖ®/, /ÊÄßËÉΩ/, /‰ºòÂåñ/, /ÈÖçÁΩÆ/, /ÈÉ®ÁΩ≤/
                ];
                
                for (const pattern of allowedPatterns) {
                    if (pattern.test(entityLower)) {
                        return true; // ÊäÄÊúØÂíå‰∏öÂä°Áõ∏ÂÖ≥Ê¶ÇÂøµÁõ¥Êé•ÈÄöËøá
                    }
                }
                
                return true; // ÈªòËÆ§‰øùÁïôÂÖ∂‰ªñÂÆû‰Ωì
            }
            
            // ‰ªéAIÂìçÂ∫î‰∏≠ÊèêÂèñÊ¶ÇÂøµ
            extractAIConcepts(aiContent) {
                const concepts = [];
                const conceptPatterns = [
                    /Ê¶ÇÂøµ[Ôºö:]\s*([^„ÄÇ\n]+)/g,
                    /concepts[Ôºö:]\s*([^.\n]+)/g,
                    /‰∏ªÈ¢ò[Ôºö:]\s*([^„ÄÇ\n]+)/g,
                    /topics[Ôºö:]\s*([^.\n]+)/g
                ];
                
                conceptPatterns.forEach(pattern => {
                    let match;
                    while ((match = pattern.exec(aiContent)) !== null) {
                        const conceptText = match[1];
                        const conceptList = conceptText.split(/[,Ôºå„ÄÅ]/).map(c => c.trim()).filter(c => c.length > 0);
                        concepts.push(...conceptList);
                    }
                });
                
                return concepts.slice(0, 8); // ÈôêÂà∂Êï∞Èáè
            }
            
            // ‰ªéAIÂìçÂ∫î‰∏≠ÊèêÂèñÂàÜÁ±ª
            extractAIClassification(aiContent) {
                const classificationPatterns = [
                    /ÂàÜÁ±ª[Ôºö:]\s*([^„ÄÇ\n]+)/g,
                    /classification[Ôºö:]\s*([^.\n]+)/g,
                    /Á±ªÂà´[Ôºö:]\s*([^„ÄÇ\n]+)/g,
                    /category[Ôºö:]\s*([^.\n]+)/g
                ];
                
                for (const pattern of classificationPatterns) {
                    const match = pattern.exec(aiContent);
                    if (match) {
                        return match[1].trim();
                    }
                }
                
                return 'ÊñáÊ°£/ÂÖ∂‰ªñ';
            }
            
            // ÂàÜÊûêPDFÁªìÊûÑ
            analyzePDFStructure(content) {
                return {
                    isPDF: true,
                    contentLength: content.inferredContent?.length || 0,
                    hasAIAnalysis: content.aiGenerated || false,
                    confidence: content.confidence || 0.7,
                    analysisMethod: content.source || 'Rule-based'
                };
            }
            
            processGraphRAGResult(result) {
                return {
                    entities: result.entities || [],
                    relationships: result.relationships || [],
                    concepts: result.concepts || [],
                    categories: result.categories || [],
                    graphData: result.graph_data || null,
                    reasoning: result.reasoning_chain || [],
                    confidence: result.confidence || 0.8,
                    summary: result.summary || '',
                    keyInsights: result.key_insights || [],
                    suggestedActions: result.suggested_actions || []
                };
            }
            
            async enhancedSimulatedAnalysis(file, additionalContext) {
                console.log('üî¨ Running enhanced simulated GraphRAG analysis');
                
                // ‰ΩøÁî®Êàë‰ª¨ÊîπËøõÁöÑÂàÜÊûêÁ≥ªÁªü‰Ωú‰∏∫ÂõûÈÄÄ
                const basicAnalysis = await performEnhancedAnalysis(file, 
                    this.getExistingCategories(), 
                    this.getPotentialNewCategories()
                );
                
                // Ê®°ÊãüGraphRAGÁöÑÈ¢ùÂ§ñÂäüËÉΩ
                const simulatedGraphRAGFeatures = this.simulateGraphRAGFeatures(file, basicAnalysis);
                
                return {
                    ...basicAnalysis,
                    ...simulatedGraphRAGFeatures,
                    isSimulated: true,
                    serviceStatus: 'offline'
                };
            }
            
            simulateGraphRAGFeatures(file, basicAnalysis) {
                const filename = file.name.toLowerCase();
                
                // Ê®°ÊãüÂÆû‰ΩìÊèêÂèñ
                const entities = this.extractSimulatedEntities(filename);
                
                // Ê®°ÊãüÂÖ≥Á≥ªËØÜÂà´
                const relationships = this.generateSimulatedRelationships(entities);
                
                // Ê®°ÊãüÊ¶ÇÂøµËÅöÁ±ª
                const concepts = this.identifySimulatedConcepts(filename, basicAnalysis);
                
                // Ê®°ÊãüÊé®ÁêÜÈìæ
                const reasoning = this.generateReasoningChain(basicAnalysis);
                
                return {
                    entities: entities,
                    relationships: relationships,
                    concepts: concepts,
                    reasoning: reasoning,
                    keyInsights: this.generateKeyInsights(filename, entities),
                    graphData: this.generateSimulatedGraphData(entities, relationships)
                };
            }
            
            extractSimulatedEntities(filename) {
                const entities = [];
                const entityPatterns = {
                    'ORGANIZATION': ['company', 'corp', 'inc', 'ltd', 'agency'],
                    'PERSON': ['ceo', 'manager', 'director', 'analyst'],
                    'LOCATION': ['sydney', 'melbourne', 'australia', 'china', 'usa'],
                    'PRODUCT': ['app', 'software', 'platform', 'service'],
                    'CONCEPT': ['strategy', 'analysis', 'research', 'campaign', 'content']
                };
                
                Object.entries(entityPatterns).forEach(([type, patterns]) => {
                    patterns.forEach(pattern => {
                        if (filename.includes(pattern)) {
                            entities.push({
                                name: pattern.charAt(0).toUpperCase() + pattern.slice(1),
                                type: type,
                                confidence: Math.random() * 0.3 + 0.7,
                                mentions: Math.floor(Math.random() * 5) + 1
                            });
                        }
                    });
                });
                
                // Ê∑ªÂä†‰∏Ä‰∫õÈÄöÁî®ÂÆû‰Ωì
                if (entities.length < 3) {
                    entities.push(
                        {name: 'Content Marketing', type: 'CONCEPT', confidence: 0.8, mentions: 3},
                        {name: 'Digital Strategy', type: 'CONCEPT', confidence: 0.75, mentions: 2},
                        {name: 'Market Analysis', type: 'CONCEPT', confidence: 0.7, mentions: 1}
                    );
                }
                
                return entities;
            }
            
            generateSimulatedRelationships(entities) {
                const relationships = [];
                const relationTypes = ['RELATED_TO', 'PART_OF', 'INFLUENCES', 'DEPENDS_ON', 'CREATES'];
                
                for (let i = 0; i < entities.length - 1; i++) {
                    for (let j = i + 1; j < entities.length && relationships.length < 5; j++) {
                        if (Math.random() > 0.6) {
                            relationships.push({
                                source: entities[i].name,
                                target: entities[j].name,
                                relationship: relationTypes[Math.floor(Math.random() * relationTypes.length)],
                                confidence: Math.random() * 0.4 + 0.6,
                                strength: Math.random() * 0.5 + 0.5
                            });
                        }
                    }
                }
                
                return relationships;
            }
            
            identifySimulatedConcepts(filename, basicAnalysis) {
                const concepts = [];
                const conceptMap = {
                    'market': ['Market Segmentation', 'Competitive Analysis', 'Consumer Behavior'],
                    'content': ['Content Strategy', 'Editorial Planning', 'Brand Voice'],
                    'social': ['Social Engagement', 'Community Building', 'Influencer Marketing'],
                    'data': ['Data Analytics', 'Performance Metrics', 'Business Intelligence'],
                    'campaign': ['Campaign Management', 'Marketing Automation', 'Lead Generation']
                };
                
                Object.entries(conceptMap).forEach(([keyword, relatedConcepts]) => {
                    if (filename.includes(keyword)) {
                        relatedConcepts.forEach(concept => {
                            concepts.push({
                                name: concept,
                                relevance: Math.random() * 0.3 + 0.7,
                                category: basicAnalysis.bestMatch?.name || 'General'
                            });
                        });
                    }
                });
                
                return concepts.slice(0, 5); // ÈôêÂà∂‰∏∫5‰∏™Ê¶ÇÂøµ
            }
            
            generateReasoningChain(basicAnalysis) {
                return [
                    {
                        step: 1,
                        action: 'Document Analysis',
                        description: `Analyzed file structure and metadata`,
                        confidence: 0.9
                    },
                    {
                        step: 2,
                        action: 'Entity Recognition',
                        description: `Identified key entities and concepts`,
                        confidence: 0.85
                    },
                    {
                        step: 3,
                        action: 'Relationship Mapping',
                        description: `Mapped relationships between entities`,
                        confidence: 0.8
                    },
                    {
                        step: 4,
                        action: 'Category Classification',
                        description: `Classified content into ${basicAnalysis.bestMatch?.name || 'appropriate category'}`,
                        confidence: basicAnalysis.confidence || 0.75
                    }
                ];
            }
            
            generateKeyInsights(filename, entities) {
                const insights = [];
                
                if (entities.some(e => e.type === 'ORGANIZATION')) {
                    insights.push('üìä Document contains organizational structure information');
                }
                
                if (entities.some(e => e.type === 'CONCEPT')) {
                    insights.push('üí° Strategic concepts and methodologies identified');
                }
                
                if (filename.includes('2024') || filename.includes('2025')) {
                    insights.push('üìÖ Contains current/future planning information');
                }
                
                insights.push(`üîç ${entities.length} key entities extracted for knowledge graph`);
                
                return insights;
            }
            
            generateSimulatedGraphData(entities, relationships) {
                const nodes = entities.map(entity => ({
                    id: entity.name,
                    label: entity.name,
                    type: entity.type,
                    size: entity.confidence * 20 + 10,
                    color: this.getNodeColor(entity.type)
                }));
                
                const edges = relationships.map(rel => ({
                    source: rel.source,
                    target: rel.target,
                    label: rel.relationship,
                    weight: rel.strength
                }));
                
                return { nodes, edges };
            }
            
            getNodeColor(type) {
                const colors = {
                    'ORGANIZATION': '#ff6b6b',
                    'PERSON': '#4ecdc4',
                    'LOCATION': '#45b7d1',
                    'PRODUCT': '#f9ca24',
                    'CONCEPT': '#6c5ce7'
                };
                return colors[type] || '#a0a0a0';
            }
            
            getExistingCategories() {
                return [
                    { 
                        name: "üìä Market Research", 
                        confidence: 0.85, 
                        reason: "Contains market data and consumer insights",
                        keywords: ["market", "research", "survey", "consumer", "audience", "demographic", "trend", "analysis"],
                        fileTypes: ["xlsx", "csv", "pdf", "docx"],
                        minConfidence: 0.7
                    },
                    { 
                        name: "‚úçÔ∏è Content Strategy", 
                        confidence: 0.78, 
                        reason: "Includes content planning and editorial guidelines",
                        keywords: ["content", "blog", "editorial", "writing", "article", "copy", "seo", "publishing"],
                        fileTypes: ["docx", "txt", "md", "pdf"],
                        minConfidence: 0.6
                    },
                    { 
                        name: "üì± Social Media", 
                        confidence: 0.92, 
                        reason: "Social media metrics and campaign data detected",
                        keywords: ["social", "instagram", "tiktok", "facebook", "twitter", "linkedin", "engagement", "follower"],
                        fileTypes: ["png", "jpg", "jpeg", "pdf", "xlsx"],
                        minConfidence: 0.8
                    },
                    { 
                        name: "üìà Analytics & Data", 
                        confidence: 0.89, 
                        reason: "Performance metrics and statistical analysis",
                        keywords: ["analytics", "data", "kpi", "metrics", "performance", "dashboard", "report", "statistics"],
                        fileTypes: ["xlsx", "csv", "json", "pdf"],
                        minConfidence: 0.75
                    },
                    { 
                        name: "üéØ Campaign Planning", 
                        confidence: 0.74, 
                        reason: "Campaign objectives and target audience info",
                        keywords: ["campaign", "strategy", "plan", "launch", "marketing", "promotion", "advertising"],
                        fileTypes: ["pptx", "pdf", "docx"],
                        minConfidence: 0.65
                    }
                ];
            }
            
            getPotentialNewCategories() {
                return [
                    { name: "üé® Brand Design", confidence: 0.88, reason: "Visual branding and design assets detected" },
                    { name: "üìß Email Marketing", confidence: 0.82, reason: "Email campaign templates and automation workflows" },
                    { name: "üé• Video Content", confidence: 0.90, reason: "Video production scripts and multimedia content" },
                    { name: "üìû Customer Support", confidence: 0.75, reason: "Support documentation and customer service materials" },
                    { name: "üí∞ Sales Materials", confidence: 0.83, reason: "Sales presentations and lead generation content" },
                    { name: "üîç SEO & Keywords", confidence: 0.87, reason: "Search engine optimization and keyword research" },
                    { name: "üì± Mobile App", confidence: 0.79, reason: "Mobile application development and UX content" },
                    { name: "üõí E-commerce", confidence: 0.85, reason: "Product descriptions and online store content" },
                    { name: "üìä Business Intelligence", confidence: 0.91, reason: "Business reporting and data visualization" },
                    { name: "üéì Training & Education", confidence: 0.73, reason: "Educational materials and training content" }
                ];
            }
        }
        
        // Initialize GraphRAG Service
        const graphRAGService = new GraphRAGService();

        // Multi-modal Input Functions
        let currentInputMode = 'text';
        let recognition = null;
        
        // Manual input tracking for Send button restriction
        let isManualInput = false;

        // Switch input modes
        window.switchInputMode = function(mode) {
            console.log('üîÑ Switching to mode:', mode);
            // Update button states
            document.querySelectorAll('.input-mode-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.mode === mode) {
                    btn.classList.add('active');
                }
            });
            
            // Hide all mode contents
            document.querySelectorAll('.input-mode-content').forEach(content => {
                content.style.display = 'none';
            });
            
            // Show selected mode
            const targetMode = document.getElementById(mode + 'InputMode');
            if (targetMode) {
                targetMode.style.display = 'block';
                console.log('‚úÖ Switched to', mode, 'mode');
            } else {
                console.error('‚ùå Mode not found:', mode + 'InputMode');
            }
            currentInputMode = mode;
        }

        // ü§ñ Smart Input Handlers - Auto-detect content type
        
        // Handle smart text input - detects URLs and other patterns
        window.handleSmartInput = function(value) {
            console.log('ü§ñ Smart input analysis:', value.length, 'chars');
            
            // URL detection
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            const urls = value.match(urlRegex);
            
            if (urls && urls.length > 0) {
                console.log('üîó URL detected:', urls[0]);
                // Auto-fetch URL content if it's the only content
                if (value.trim() === urls[0]) {
                    setTimeout(() => {
                        fetchUrlContentFromInput(urls[0]);
                    }, 1000);
                }
            }
        };

        // Handle smart file drop
        window.handleSmartDrop = function(event) {
            console.log('üìÅ Smart drop handler triggered');
            event.preventDefault();
            event.stopPropagation();
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                console.log('üìÅ Files dropped:', files.length);
                handleFileInput(files);
            }
            
            // Reset visual state
            event.target.style.borderColor = '#cbd5e1';
            event.target.style.backgroundColor = '#f8fafc';
        };

        // Handle file input (from file picker or drag-drop)
        window.handleFileInput = function(files) {
            console.log('üìÅ Processing files through smart input:', files.length);
            if (files && files.length > 0) {
                // Use existing file processing logic
                processUploadedFiles(files);
            }
        };

        // Fetch URL content from input and save to knowledge tree
        window.fetchUrlContentFromInput = async function(url) {
            console.log('üîó Auto-fetching URL:', url);
            console.log('üîç DEBUG: ÂºÄÂßãURLÁ±ªÂûãÊ£ÄÊµã...');
            console.log('üîç DEBUG: URLÂåÖÂê´youtube.com/watch?', url.includes('youtube.com/watch'));
            console.log('üîç DEBUG: URLÂåÖÂê´youtu.be/?', url.includes('youtu.be/'));
            
            // üî• YouTube URL Áõ¥Êé•Â§ÑÁêÜ - ‰ΩøÁî®ËßÜÈ¢ëÊèêÂèñÁÆ°ÈÅì
            if (url.includes('youtube.com/watch') || url.includes('youtu.be/') || url.includes('bilibili.com') || url.includes('vimeo.com')) {
                console.log('üé¨ Ê£ÄÊµãÂà∞ËßÜÈ¢ëURLÔºåÂêØÁî®ËßÜÈ¢ëÊèêÂèñÊ®°Âºè');
                console.log('üîç DEBUG: ËßÜÈ¢ëÊ£ÄÊµãÈÄªËæëÂëΩ‰∏≠ÔºåÂáÜÂ§áË∞ÉÁî®/api/scrape');
                
                // Show video specific loading state
                const urlContent = document.getElementById('urlContent');
                if (urlContent) {
                    urlContent.style.display = 'block';
                    urlContent.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
                            <div style="width: 24px; height: 24px; border: 2px solid #3b82f6; border-top: transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                            <span>üé¨ ËßÜÈ¢ëÂÜÖÂÆπÊèêÂèñ‰∏≠: ${url}</span>
                        </div>
                    `;
                }
                
                try {
                    // Áõ¥Êé•Ë∞ÉÁî®ËßÜÈ¢ëÂàÜÊûêAPIÔºå‰∏çËµ∞Êñá‰ª∂‰∏ä‰º†ÊµÅÁ®ã
                    console.log('üîÑ ÂêØÂä®ËßÜÈ¢ëÂÜÖÂÆπÊèêÂèñ...');
                    console.log('üîç DEBUG: ÂèëÈÄÅAPIËØ∑Ê±ÇÂà∞ /api/scrape');
                    console.log('üîç DEBUG: ËØ∑Ê±Ç‰Ωì:', { url: url });
                    
                    const response = await fetch('http://localhost:8000/api/scrape', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ url: url })
                    });
                    
                    console.log('üîç DEBUG: APIÂìçÂ∫îÁä∂ÊÄÅ:', response.status, response.statusText);
                    
                    if (!response.ok) {
                        console.log('‚ùå DEBUG: APIËØ∑Ê±ÇÂ§±Ë¥•:', response.status);
                        throw new Error(`ËßÜÈ¢ëÂàÜÊûêÂ§±Ë¥•: ${response.status}`);
                    }
                    
                    const analysisResult = await response.json();
                    console.log('üîç DEBUG: APIËøîÂõûÁªìÊûú:', analysisResult);
                    console.log('üîç DEBUG: ÁªìÊûúÁä∂ÊÄÅ:', analysisResult.status);
                    console.log('üîç DEBUG: ÂÜÖÂÆπÈïøÂ∫¶:', analysisResult?.analysis?.content?.length || 'N/A');
                    
                    if (analysisResult.status === 'success') {
                        console.log('‚úÖ ËßÜÈ¢ëÂÜÖÂÆπÊèêÂèñÊàêÂäü');
                        console.log('üîç DEBUG: ÊàêÂäüË∑ØÂæÑ - ÂáÜÂ§áÊòæÁ§∫ÁªìÊûú');
                        
                        // ÊòæÁ§∫ËßÜÈ¢ëÂàÜÊûêÁªìÊûú
                        displayURLAnalysisResults(analysisResult.analysis, url);
                        
                        // ‰øùÂ≠òÂà∞Áü•ËØÜÊ†ë
                        const videoFile = new File([analysisResult.analysis.content], 
                            `video_${new URL(url).hostname}_${Date.now()}.txt`, 
                            { type: 'text/plain' });
                        videoFile.sourceUrl = url;
                        
                        await autoSaveToKnowledgeTree(videoFile, analysisResult);
                        
                        showNotification('üé¨ ËßÜÈ¢ëÂÜÖÂÆπÊèêÂèñÂÆåÊàêÂπ∂‰øùÂ≠òÂà∞Áü•ËØÜÂ∫ì!');
                        
                        // Ê∏ÖÁêÜËæìÂÖ•Âå∫Âüü
                        setTimeout(() => {
                            clearUploadArea();
                        }, 3000);
                        
                        return; // Áõ¥Êé•ËøîÂõûÔºå‰∏çÁªßÁª≠Â∏∏ËßÑÊµÅÁ®ã
                    } else {
                        console.log('‚ùå DEBUG: ËßÜÈ¢ëÂàÜÊûêAPIËøîÂõûÂ§±Ë¥•Áä∂ÊÄÅ');
                        console.log('üîç DEBUG: Â§±Ë¥•Ê∂àÊÅØ:', analysisResult.message || 'N/A');
                        throw new Error(analysisResult.message || 'ËßÜÈ¢ëÂàÜÊûêÂ§±Ë¥•');
                    }
                    
                } catch (error) {
                    console.error('‚ùå ËßÜÈ¢ëÊèêÂèñÂ§±Ë¥•:', error);
                    console.log('üîç DEBUG: ËøõÂÖ•ËßÜÈ¢ëÊèêÂèñÈîôËØØÂ§ÑÁêÜÂàÜÊîØ');
                    console.log('üîç DEBUG: ÈîôËØØÁ±ªÂûã:', error.name);
                    console.log('üîç DEBUG: ÈîôËØØÊ∂àÊÅØ:', error.message);
                    
                    // ÊòæÁ§∫ÈîôËØØÁä∂ÊÄÅ
                    if (urlContent) {
                        urlContent.innerHTML = `
                            <h4 style="margin: 0 0 12px 0; color: #dc2626;">‚ùå ËßÜÈ¢ëÊèêÂèñÂ§±Ë¥•</h4>
                            <p style="color: #6b7280; margin: 0 0 8px 0;">URL: ${url}</p>
                            <div style="background: #fef2f2; border: 1px solid #fecaca; border-radius: 8px; padding: 12px; color: #dc2626;">
                                ${error.message}
                            </div>
                        `;
                    }
                    
                    showNotification('‚ùå ËßÜÈ¢ëÂÜÖÂÆπÊèêÂèñÂ§±Ë¥•', 'error');
                    console.log('üîç DEBUG: ËßÜÈ¢ëÂ§ÑÁêÜÂ§±Ë¥•ÔºåÂç≥Â∞ÜËøîÂõûÔºå‰∏çÁªßÁª≠ÈÄöÁî®URLÊµÅÁ®ã');
                    return; // Â§±Ë¥•‰πüÁõ¥Êé•ËøîÂõûÔºå‰∏çÁªßÁª≠Â∏∏ËßÑÊµÅÁ®ã
                }
            }

            // üî• GitHub URL Áõ¥Êé•Â§ÑÁêÜ - ÈÅøÂÖçHTMLÊñá‰ª∂ËΩ¨Êç¢
            if (url.includes('github.com/') && url.match(/github\.com\/[^\/]+\/[^\/]+/)) {
                console.log('üéØ Ê£ÄÊµãÂà∞GitHub URLÔºåÂêØÁî®Áõ¥Êé•Â§ÑÁêÜÊ®°Âºè');
                console.log('üîç DEBUG: GitHub URLÂ§ÑÁêÜÂàÜÊîØÂºÄÂßã');
                
                // Show GitHub specific loading state
                const urlContent = document.getElementById('urlContent');
                if (urlContent) {
                    urlContent.style.display = 'block';
                    urlContent.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
                            <div style="width: 24px; height: 24px; border: 2px solid #3b82f6; border-top: transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                            <span>üîç GitHubÈ°πÁõÆÂàÜÊûê‰∏≠: ${url}</span>
                        </div>
                    `;
                }
                
                try {
                    // ÂàõÂª∫ÁÆÄÂçïÁöÑÊñáÊú¨Êñá‰ª∂ËÄå‰∏çÊòØHTMLÊñá‰ª∂
                    const githubFile = new File([url], 'github_url.txt', { type: 'text/plain' });
                    githubFile.sourceUrl = url;
                    githubFile.title = `GitHubÈ°πÁõÆ: ${url}`;
                    githubFile.description = 'GitHub repository analysis';
                    
                    console.log('üîÑ GitHubÈ°πÁõÆÊ∑±Â∫¶ÂàÜÊûêÂêØÂä®...');
                    
                    // Áõ¥Êé•Ë∞ÉÁî®GraphRAGÂàÜÊûê
                    const analysisResult = await graphRAGService.analyzeFileOnUpload(githubFile);
                    
                    // ‰øùÂ≠òÂà∞Áü•ËØÜÊ†ë
                    console.log('üéØ GitHubÂàÜÊûêÂÆåÊàêÔºå‰øùÂ≠òÂà∞Áü•ËØÜÊ†ë');
                    await autoSaveToKnowledgeTree(githubFile, analysisResult);
                    
                    // ÊòæÁ§∫ÊàêÂäüÁä∂ÊÄÅ
                    if (urlContent) {
                        urlContent.innerHTML = `
                            <h4 style="margin: 0 0 12px 0; color: #374151;">‚úÖ GitHubÈ°πÁõÆÂàÜÊûêÂÆåÊàê</h4>
                            <p style="color: #6b7280; margin: 0 0 8px 0;">URL: ${url}</p>
                            <div style="background: #dcfce7; border: 1px solid #bbf7d0; border-radius: 8px; padding: 12px; color: #166534;">
                                ‚úÖ GitHubÈ°πÁõÆÂàÜÊûêÂÆåÊàêÂπ∂‰øùÂ≠òÂà∞Áü•ËØÜÊ†ë
                            </div>
                        `;
                    }
                    
                    showNotification('üîó GitHubÈ°πÁõÆÂàÜÊûêÂÆåÊàêÂπ∂‰øùÂ≠òÂà∞Áü•ËØÜÂ∫ì!');
                    
                    // Ê∏ÖÁêÜËæìÂÖ•Âå∫Âüü
                    setTimeout(() => {
                        clearUploadArea();
                    }, 3000);
                    
                    return; // Áõ¥Êé•ËøîÂõûÔºå‰∏çÁªßÁª≠Â∏∏ËßÑÊµÅÁ®ã
                    
                } catch (error) {
                    console.error('‚ùå GitHubÁõ¥Êé•ÂàÜÊûêÂ§±Ë¥•:', error);
                    // ÁªßÁª≠Ëµ∞Â∏∏ËßÑÊµÅÁ®ã‰Ωú‰∏∫Â§áÈÄâ
                }
            }
            
            // üö® DEBUG: ËøõÂÖ•ÈÄöÁî®URLÂ§ÑÁêÜÂå∫Âüü - ËøôÈáåÂèØËÉΩÊã¶Êà™YouTubeÈìæÊé•ÔºÅ
            console.log('üö® DEBUG: ËøõÂÖ•ÈÄöÁî®URLÂ§ÑÁêÜÂå∫Âüü');
            console.log('üö® DEBUG: ÂΩìÂâçURL:', url);
            console.log('üö® DEBUG: YouTubeÊ£ÄÊµãÁªìÊûú - isYouTube:', isYouTube);
            console.log('üö® DEBUG: Â¶ÇÊûúisYouTube‰∏∫true‰ΩÜ‰ªçËøõÂÖ•Ê≠§Âå∫ÂüüÔºåÂàôËØ¥ÊòéYouTubeÊ£ÄÊµãÊúâÈóÆÈ¢ò');
            
            // Show URL content area with loading state
            const urlContent = document.getElementById('urlContent');
            if (urlContent) {
                urlContent.style.display = 'block';
                urlContent.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
                        <div style="width: 24px; height: 24px; border: 2px solid #3b82f6; border-top: transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                        <span>Fetching content from: ${url}</span>
                    </div>
                `;
            }
            
            try {
                // üîß DEBUG: ÂºÄÂßãÂÜÖÂÆπËé∑Âèñ
                console.log('üîß DEBUG: ÂºÄÂßãÂ∞ùËØïËé∑ÂèñURLÂÜÖÂÆπ');
                
                // Try multiple approaches to fetch URL content
                let content = '';
                let fetchError = null;
                
                // Method 1: Try direct fetch first (may fail due to CORS)
                try {
                    console.log('üîß DEBUG: Â∞ùËØïÁõ¥Êé•fetch');
                    const response = await fetch(url, {
                        method: 'GET',
                        mode: 'cors',
                        headers: {
                            'User-Agent': 'Mozilla/5.0 (compatible; ContentFetcher/1.0)'
                        }
                    });
                    
                    if (response.ok) {
                        content = await response.text();
                        console.log('‚úÖ DEBUG: Áõ¥Êé•fetchÊàêÂäüÔºåÂÜÖÂÆπÈïøÂ∫¶:', content.length);
                        console.log('üîß DEBUG: ÂÜÖÂÆπÈ¢ÑËßà:', content.substring(0, 200));
                    } else {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                } catch (directError) {
                    console.log('‚ùå DEBUG: Áõ¥Êé•fetchÂ§±Ë¥• (CORS):', directError.message);
                    fetchError = directError;
                    
                    // Method 2: Try CORS proxy services
                    const proxyUrls = [
                        `https://corsproxy.io/?${encodeURIComponent(url)}`,
                        `https://cors-anywhere.herokuapp.com/${url}`,
                        `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`
                    ];
                    
                    for (const proxyUrl of proxyUrls) {
                        try {
                            console.log('üîÑ Trying proxy:', proxyUrl);
                            const proxyResponse = await fetch(proxyUrl);
                            
                            if (proxyResponse.ok) {
                                if (proxyUrl.includes('allorigins')) {
                                    const jsonData = await proxyResponse.json();
                                    content = jsonData.contents;
                                } else {
                                    content = await proxyResponse.text();
                                }
                                console.log('‚úÖ Proxy fetch successful');
                                fetchError = null;
                                break;
                            }
                        } catch (proxyError) {
                            console.log('‚ùå Proxy failed:', proxyUrl, proxyError.message);
                            continue;
                        }
                    }
                    
                    // Method 3: If all proxies fail, use a mock content approach
                    if (!content && fetchError) {
                        console.log('üîÑ Using fallback content extraction...');
                        content = await generateMockContentFromUrl(url);
                    }
                }
                if (!content || content.length === 0) {
                    throw new Error('No content could be retrieved from the URL');
                }
                
                console.log('‚úÖ URL content fetched, length:', content.length);
                
                // üö® DEBUG: ÂºÄÂßãHTMLÊñáÊú¨ÊèêÂèñÂíåÂÖÉÊï∞ÊçÆËß£Êûê
                console.log('üö® DEBUG: ÂºÄÂßã‰ªéHTMLÊèêÂèñÁ∫ØÊñáÊú¨ÂÜÖÂÆπ');
                console.log('üö® DEBUG: ÂéüÂßãHTMLÂÜÖÂÆπÈïøÂ∫¶:', content.length);
                console.log('üö® DEBUG: HTMLÂÜÖÂÆπÈ¢ÑËßà:', content.substring(0, 300));
                
                // üî• ‰ªéHTML‰∏≠ÊèêÂèñÁ∫ØÊñáÊú¨ÂÜÖÂÆπ
                const cleanText = extractTextFromHTML(content);
                console.log('üîß HTMLÁ∫ØÊñáÊú¨ÊèêÂèñÂÆåÊàêÔºåÈïøÂ∫¶:', cleanText.length);
                console.log('üö® DEBUG: ÊèêÂèñÁöÑÁ∫ØÊñáÊú¨È¢ÑËßà:', cleanText.substring(0, 200));
                
                // üö® DEBUG: ÂºÄÂßãËß£ÊûêHTMLÂÖÉÊï∞ÊçÆ
                console.log('üö® DEBUG: ÂºÄÂßãËß£ÊûêHTMLÂÖÉÊï∞ÊçÆ');
                
                // Extract basic information from HTML
                const parser = new DOMParser();
                const doc = parser.parseFromString(content, 'text/html');
                const title = doc.querySelector('title')?.textContent || new URL(url).hostname;
                const description = doc.querySelector('meta[name="description"]')?.content || 
                                   doc.querySelector('meta[property="og:description"]')?.content || 
                                   'Web content analysis';
                
                console.log('üö® DEBUG: Ëß£ÊûêÁöÑÊ†áÈ¢ò:', title);
                console.log('üö® DEBUG: Ëß£ÊûêÁöÑÊèèËø∞:', description);
                console.log('üö® DEBUG: Â¶ÇÊûúËøôÊòØYouTube URLÔºåÊ†áÈ¢òÂ∫îËØ•ÂåÖÂê´ËßÜÈ¢ë‰ø°ÊÅØÔºåËÄå‰∏çÊòØÈÄöÁî®È°µÈù¢Ê†áÈ¢ò');
                
                // üö® DEBUG: FileÂØπË±°ÂàõÂª∫ËøáÁ®ãËøΩË∏™
                console.log('üö® DEBUG: ======= ÂÖ≥ÈîÆÈóÆÈ¢òÁÇπÔºöFileÂØπË±°ÂàõÂª∫ =======');
                console.log('üö® DEBUG: Âç≥Â∞ÜÂàõÂª∫FileÂØπË±°ÔºåËøôÈáåÂèØËÉΩÂ∞±ÊòØYouTube URLË¢´ÈîôËØØÂ§ÑÁêÜÁöÑÂú∞Êñπ');
                console.log('üö® DEBUG: cleanTextÂÜÖÂÆπÈïøÂ∫¶:', cleanText.length);
                console.log('üö® DEBUG: cleanTextÂÜÖÂÆπÈ¢ÑËßàÔºàÂâç100Â≠óÁ¨¶Ôºâ:', cleanText.substring(0, 100));
                console.log('üö® DEBUG: Êñá‰ª∂ÂêçÂ∞ÜËÆæ‰∏∫:', `${title}.html`);
                console.log('üö® DEBUG: Êñá‰ª∂Á±ªÂûãÂ∞ÜËÆæ‰∏∫: text/html');
                console.log('üö® DEBUG: ‚ö†Ô∏è  Â¶ÇÊûúËøôÊòØYouTube URLÔºåËøôÈáåÂ∫îËØ•Ê£ÄÊµãÂà∞ËßÜÈ¢ëÂÜÖÂÆπËÄå‰∏çÊòØÈÄöÁî®HTMLÔºÅ');
                
                // Create a virtual file object for processing (‰ΩøÁî®ÊèêÂèñÁöÑÁ∫ØÊñáÊú¨)
                const urlFile = new File(
                    [cleanText], 
                    `${title}.html`, 
                    { type: 'text/html' }
                );
                
                console.log('üö® DEBUG: FileÂØπË±°Â∑≤ÂàõÂª∫');
                console.log('üö® DEBUG: ÂàõÂª∫ÁöÑFileÂØπË±°Â§ßÂ∞è:', urlFile.size, 'Â≠óËäÇ');
                console.log('üö® DEBUG: ÂàõÂª∫ÁöÑFileÂØπË±°ÂêçÁß∞:', urlFile.name);
                console.log('üö® DEBUG: ÂàõÂª∫ÁöÑFileÂØπË±°Á±ªÂûã:', urlFile.type);
                
                // Add URL metadata
                urlFile.sourceUrl = url;
                urlFile.title = title;
                urlFile.description = description;
                
                console.log('üö® DEBUG: ÂÖÉÊï∞ÊçÆÂ∑≤Ê∑ªÂä†Âà∞FileÂØπË±°');
                console.log('üö® DEBUG: sourceUrl:', urlFile.sourceUrl);
                console.log('üö® DEBUG: ======= FileÂØπË±°ÂàõÂª∫ÂÆåÊàêÔºåÂç≥Â∞ÜÂèëÈÄÅÂà∞ÂêéÁ´Ø =======');
                
                console.log('üîÑ Starting GraphRAG analysis for URL content...');
                
                // Show success message and start analysis
                if (urlContent) {
                    urlContent.innerHTML = `
                        <h4 style="margin: 0 0 12px 0; color: #374151;">üîó ${title}</h4>
                        <p style="color: #6b7280; margin: 0 0 8px 0;">URL: ${url}</p>
                        <p style="color: #6b7280; margin: 0 0 16px 0;">${description}</p>
                        <div style="display: flex; align-items: center; gap: 8px; color: #3b82f6;">
                            <div style="width: 16px; height: 16px; border: 2px solid #3b82f6; border-top: transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                            <span>Analyzing content with GraphRAG...</span>
                        </div>
                    `;
                }
                
                // üö® DEBUG: ÂêéÁ´ØÂàÜÊûêÊúçÂä°Ë∞ÉÁî®ËøΩË∏™
                console.log('üö® DEBUG: ======= Âç≥Â∞ÜÂèëÈÄÅÂà∞GraphRAGÂêéÁ´ØÂàÜÊûê =======');
                console.log('üö® DEBUG: ÂáÜÂ§áË∞ÉÁî® graphRAGService.analyzeFileOnUpload()');
                console.log('üö® DEBUG: ‰º†ÈÄíÁöÑurlFileÂØπË±°ËØ¶ÊÉÖ:');
                console.log('üö® DEBUG: - FileÂêçÁß∞:', urlFile.name);
                console.log('üö® DEBUG: - FileÂ§ßÂ∞è:', urlFile.size, 'Â≠óËäÇ');
                console.log('üö® DEBUG: - FileÁ±ªÂûã:', urlFile.type);
                console.log('üö® DEBUG: - sourceUrl:', urlFile.sourceUrl);
                console.log('üö® DEBUG: - title:', urlFile.title);
                console.log('üö® DEBUG: ‚ö†Ô∏è  ÂÖ≥ÈîÆÈóÆÈ¢òÔºöÂ¶ÇÊûúËøôÊòØYouTube URLÔºåÂêéÁ´ØÂ∫îËØ•Ê£ÄÊµãÂà∞ËßÜÈ¢ëÂÜÖÂÆπÔºÅ');
                console.log('üö® DEBUG: ‚ö†Ô∏è  ÊúüÊúõÁªìÊûúÔºö2694Â≠óÁ¨¶ÁöÑËßÜÈ¢ëËΩ¨ÂΩïÔºåËÄå‰∏çÊòØ98Â≠óÁ¨¶ÁöÑHTMLÈ°µÈù¢ÔºÅ');
                console.log('üö® DEBUG: Ê≠£Âú®ÂèëÈÄÅÂà∞ÂêéÁ´Ø...');
                
                // Use GraphRAG service to analyze the content
                const analysisResult = await graphRAGService.analyzeFileOnUpload(urlFile);
                
                console.log('üö® DEBUG: ======= ÂêéÁ´ØÂàÜÊûêÁªìÊûúËøîÂõû =======');
                console.log('üö® DEBUG: ÂàÜÊûêÁªìÊûúÁä∂ÊÄÅ:', analysisResult?.status);
                console.log('üö® DEBUG: ËøîÂõûÂÜÖÂÆπÈïøÂ∫¶:', analysisResult?.analysis?.content?.length);
                console.log('üö® DEBUG: ÂÜÖÂÆπÈ¢ÑËßàÔºàÂâç100Â≠óÁ¨¶Ôºâ:', analysisResult?.analysis?.content?.substring(0, 100));
                console.log('üö® DEBUG: ÊèêÂèñÊñπÊ≥ï:', analysisResult?.extraction_method);
                console.log('üö® DEBUG: Âπ≥Âè∞Ê£ÄÊµã:', analysisResult?.platform);
                console.log('üö® DEBUG: ‚ö†Ô∏è  Ê£ÄÊü•ÔºöÂ¶ÇÊûúÊòØYouTubeÔºåÂ∫îËØ•ÊòæÁ§∫"YouTube"Âπ≥Âè∞ÂíåËßÜÈ¢ëÂÜÖÂÆπÔºÅ');
                console.log('üö® DEBUG: ======= ÂêéÁ´ØÂàÜÊûêÂÆåÊàê =======');
                
                // Save to knowledge tree automatically
                console.log('üéØ URL analysis completed, auto-saving to knowledge tree');
                await autoSaveToKnowledgeTree(urlFile, analysisResult);
                
                // Update display with success
                if (urlContent) {
                    urlContent.innerHTML = `
                        <h4 style="margin: 0 0 12px 0; color: #374151;">‚úÖ ${title}</h4>
                        <p style="color: #6b7280; margin: 0 0 8px 0;">URL: ${url}</p>
                        <p style="color: #6b7280; margin: 0 0 16px 0;">${description}</p>
                        <div style="background: #dcfce7; border: 1px solid #bbf7d0; border-radius: 8px; padding: 12px; color: #166534;">
                            ‚úÖ Content analyzed and saved to knowledge tree
                        </div>
                    `;
                }
                
                showNotification('üîó URL content analyzed and saved to knowledge base!');
                
                // Clear the input after successful processing
                setTimeout(() => {
                    clearUploadArea();
                }, 3000);
                
            } catch (error) {
                console.error('‚ùå URL fetching failed:', error);
                
                // Show error message
                if (urlContent) {
                    urlContent.innerHTML = `
                        <h4 style="margin: 0 0 12px 0; color: #dc2626;">‚ùå Failed to fetch URL</h4>
                        <p style="color: #6b7280; margin: 0 0 8px 0;">URL: ${url}</p>
                        <div style="background: #fef2f2; border: 1px solid #fecaca; border-radius: 8px; padding: 12px; color: #dc2626;">
                            Error: ${error.message}
                            <br><br>
                            <strong>CORS Solutions:</strong>
                            <br>‚Ä¢ Try copying and pasting the content manually
                            <br>‚Ä¢ Use a browser extension like "CORS Unblock"
                            <br>‚Ä¢ For GitHub: Try the raw file URL instead
                            <br>‚Ä¢ Consider using a local server with CORS proxy
                            <br><br>
                            <button onclick="retryUrlWithFallback('${url}')" style="
                                background: #dc2626; color: white; border: none; padding: 8px 16px;
                                border-radius: 4px; cursor: pointer; font-size: 12px;
                            ">üîÑ Retry with Fallback</button>
                        </div>
                    `;
                }
                
                showNotification('‚ùå Failed to fetch URL content. Please check the URL or try manual content input.');
            }
        };

        // Retry URL fetch with fallback approach
        window.retryUrlWithFallback = async function(url) {
            console.log('üîÑ Retrying URL with fallback approach:', url);
            
            const urlContent = document.getElementById('urlContent');
            if (urlContent) {
                urlContent.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
                        <div style="width: 24px; height: 24px; border: 2px solid #3b82f6; border-top: transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                        <span>Retrying with fallback approach...</span>
                    </div>
                `;
            }
            
            try {
                // Force use fallback approach
                const content = await generateMockContentFromUrl(url);
                
                // Extract information
                const parser = new DOMParser();
                const doc = parser.parseFromString(content, 'text/html');
                const title = doc.querySelector('title')?.textContent || new URL(url).hostname;
                const description = doc.querySelector('meta[name="description"]')?.content || 'Web content analysis';
                
                // Create virtual file
                const urlFile = new File([content], `${title}.html`, { type: 'text/html' });
                urlFile.sourceUrl = url;
                urlFile.title = title;
                urlFile.description = description;
                
                // Analyze with GraphRAG
                const analysisResult = await graphRAGService.analyzeFileOnUpload(urlFile);
                await autoSaveToKnowledgeTree(urlFile, analysisResult);
                
                // Show success
                if (urlContent) {
                    urlContent.innerHTML = `
                        <h4 style="margin: 0 0 12px 0; color: #374151;">‚úÖ ${title} (Fallback)</h4>
                        <p style="color: #6b7280; margin: 0 0 8px 0;">URL: ${url}</p>
                        <p style="color: #6b7280; margin: 0 0 16px 0;">${description}</p>
                        <div style="background: #dcfce7; border: 1px solid #bbf7d0; border-radius: 8px; padding: 12px; color: #166534;">
                            ‚úÖ Content analyzed using fallback method and saved to knowledge tree
                            <br><small>Note: Used structured content extraction due to CORS restrictions</small>
                        </div>
                    `;
                }
                
                showNotification('üîó URL processed with fallback method and saved to knowledge base!');
                setTimeout(() => clearUploadArea(), 3000);
                
            } catch (error) {
                console.error('‚ùå Fallback retry failed:', error);
                if (urlContent) {
                    urlContent.innerHTML = `
                        <h4 style="margin: 0 0 12px 0; color: #dc2626;">‚ùå Retry Failed</h4>
                        <p style="color: #6b7280; margin: 0 0 8px 0;">URL: ${url}</p>
                        <div style="background: #fef2f2; border: 1px solid #fecaca; border-radius: 8px; padding: 12px; color: #dc2626;">
                            Unable to process URL even with fallback methods.
                            <br>Please try copying and pasting the content manually into the text area.
                        </div>
                    `;
                }
            }
        };

        // Generate mock content from URL when direct fetching fails
        window.generateMockContentFromUrl = async function(url) {
            console.log('üîÑ Generating mock content for URL:', url);
            
            try {
                const urlObj = new URL(url);
                const domain = urlObj.hostname;
                const path = urlObj.pathname;
                
                // Extract potential information from URL structure
                const pathParts = path.split('/').filter(part => part.length > 0);
                const title = pathParts.length > 0 ? pathParts[pathParts.length - 1].replace(/[-_]/g, ' ') : domain;
                
                // Generate structured mock content based on domain patterns
                let mockContent = '';
                
                if (domain.includes('github.com')) {
                    const [user, repo] = pathParts;
                    mockContent = `
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <title>${user}/${repo || 'repository'} - GitHub</title>
                            <meta name="description" content="GitHub repository for ${user}/${repo || 'software project'}">
                        </head>
                        <body>
                            <h1>${user}/${repo || 'Repository'}</h1>
                            <p>This is a GitHub repository containing source code and documentation.</p>
                            <div>
                                <h2>About</h2>
                                <p>GitHub repository: ${url}</p>
                                <p>This appears to be a software development project hosted on GitHub.</p>
                                <p>Repository owner: ${user}</p>
                                ${repo ? `<p>Repository name: ${repo}</p>` : ''}
                            </div>
                            <div>
                                <h2>Content Type</h2>
                                <p>Source code repository, documentation, software project</p>
                            </div>
                        </body>
                        </html>
                    `;
                } else if (domain.includes('medium.com') || domain.includes('blog')) {
                    mockContent = `
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <title>${title} - Article</title>
                            <meta name="description" content="Article or blog post from ${domain}">
                        </head>
                        <body>
                            <h1>${title}</h1>
                            <p>This appears to be an article or blog post.</p>
                            <div>
                                <h2>Source</h2>
                                <p>URL: ${url}</p>
                                <p>Domain: ${domain}</p>
                                <p>Content Type: Article/Blog Post</p>
                            </div>
                        </body>
                        </html>
                    `;
                } else {
                    // Generic web content
                    mockContent = `
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <title>${title || domain} - Web Content</title>
                            <meta name="description" content="Web content from ${domain}">
                        </head>
                        <body>
                            <h1>${title || domain}</h1>
                            <p>Web content from: ${url}</p>
                            <div>
                                <h2>Content Information</h2>
                                <p>URL: ${url}</p>
                                <p>Domain: ${domain}</p>
                                <p>Path: ${path}</p>
                                <p>Content Type: Web Page</p>
                                <p>Note: This content was generated as a fallback due to CORS restrictions.</p>
                                <p>For full content analysis, consider using a browser extension or server-side solution.</p>
                            </div>
                        </body>
                        </html>
                    `;
                }
                
                console.log('‚úÖ Mock content generated');
                return mockContent;
                
            } catch (error) {
                console.error('‚ùå Failed to generate mock content:', error);
                // Return minimal content as last resort
                return `
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>Web Content - ${url}</title>
                        <meta name="description" content="Web content analysis">
                    </head>
                    <body>
                        <h1>Web Content Analysis</h1>
                        <p>URL: ${url}</p>
                        <p>This URL was processed for content analysis.</p>
                        <p>Due to CORS restrictions, detailed content extraction was not possible.</p>
                    </body>
                    </html>
                `;
            }
        };

        // File drag and drop handling (renamed to avoid conflict)
        window.handleFileDragOver = function(e) {
            console.log('üîç File drag over detected');
            e.preventDefault();
            e.stopPropagation();
            const container = e.target.closest('.multimodal-input-container');
            if (container) {
                console.log('‚úÖ Adding dragover to container');
                container.classList.add('dragover');
            }
            const dropZone = e.target.closest('.file-drop-zone');
            if (dropZone) {
                console.log('‚úÖ Adding dragover to dropzone');
                dropZone.classList.add('dragover');
            }
        }

        window.handleFileDragLeave = function(e) {
            e.preventDefault();
            e.stopPropagation();
            const container = e.target.closest('.multimodal-input-container');
            if (container) {
                container.classList.remove('dragover');
            }
            const dropZone = e.target.closest('.file-drop-zone');
            if (dropZone) {
                dropZone.classList.remove('dragover');
            }
        }

        window.handleFileDrop = function(e) {
            console.log('üîç File drop detected!');
            e.preventDefault();
            e.stopPropagation();
            const container = e.target.closest('.multimodal-input-container');
            if (container) {
                container.classList.remove('dragover');
            }
            const dropZone = e.target.closest('.file-drop-zone');
            if (dropZone) {
                dropZone.classList.remove('dragover');
            }
            
            const files = e.dataTransfer.files;
            console.log('üìÅ Files dropped:', files.length);
            console.log('üî• GLOBAL handleFileDrop - Ë∑≥ËøáÂ§ÑÁêÜÔºåËÆ©‰∏ìÈó®ÁöÑfileDropZoneÂ§ÑÁêÜ');
            // üî• ‰∏çÂú®ÂÖ®Â±ÄÂ§ÑÁêÜÊñá‰ª∂ÔºåËÆ©‰∏ìÈó®ÁöÑfileDropZoneÂ§ÑÁêÜ‰ª•ÈÅøÂÖçÈáçÂ§ç
        }

        // Process uploaded files - ÁÆÄÂåñÁâàÊú¨
        async function processUploadedFiles(files) {
            console.log('üìÅ Processing', files.length, 'files');
            const container = document.getElementById('uploadedFiles');
            
            if (!container) {
                console.error('‚ùå uploadedFiles container not found!');
                return;
            }
            
            container.innerHTML = '';
            
            // ÁÆÄÂçïÁöÑÈáçÂ§çÊ£ÄÊü•
            if (window.isProcessingFiles) {
                console.log('‚ö†Ô∏è Already processing files, skipping');
                return;
            }
            
            window.isProcessingFiles = true;
            
            try {
                // Â≠òÂÇ®ÂΩìÂâç‰∏ä‰º†ÁöÑÊñá‰ª∂‰æõÂêéÁª≠‰ΩøÁî®
                window.currentUploadedFiles = Array.from(files);
                
                // üî• ‰∏≤Ë°åÂ§ÑÁêÜÊñá‰ª∂ÔºåÈÅøÂÖçÂπ∂ÂèëÈóÆÈ¢ò
                for (let index = 0; index < files.length; index++) {
                    const file = files[index];
                    console.log(`üöÄ Starting immediate analysis for file ${index + 1}:`, file.name);
                    
                    // ÂàõÂª∫Êñá‰ª∂Â§ÑÁêÜÂç°Áâá
                    const fileCard = await createIntelligentFileCard(file, index);
                    container.appendChild(fileCard);
                    
                    // Á´ãÂç≥ÂºÄÂßãÊô∫ËÉΩÂàÜÊûê
                    try {
                        const analysisResult = await graphRAGService.analyzeFileOnUpload(file);
                        
                        // üî• Â≠òÂÇ®ÂàÜÊûêÁªìÊûúÂà∞ÂÖ®Â±ÄÂèòÈáè‰æõÂêéÁª≠‰ΩøÁî®
                        if (!window.currentAnalysisResults) {
                            window.currentAnalysisResults = {};
                        }
                        window.currentAnalysisResults[file.name] = analysisResult;
                        console.log('üíæ Stored analysis result for:', file.name);
                        
                        // Êõ¥Êñ∞Êñá‰ª∂Âç°ÁâáÊòæÁ§∫ÂàÜÊûêÁªìÊûú
                        await updateFileCardWithAnalysis(fileCard, file, analysisResult);
                        
                        // üî• Êô∫ËÉΩÂàÜÊûêÂÆåÊàêÂêéÁõ¥Êé•Ëá™Âä®‰øùÂ≠òÂà∞Áü•ËØÜÊ†ë
                        console.log('üéØ AIÂàÜÊûêÂÆåÊàêÔºåËá™Âä®‰øùÂ≠òÂà∞Áü•ËØÜÊ†ë');
                        await autoSaveToKnowledgeTree(file, analysisResult);
                        
                        console.log('‚úÖ File analysis and auto-save completed for:', file.name);
                        
                    } catch (error) {
                        console.error('‚ùå File analysis failed for:', file.name, error);
                        updateFileCardWithError(fileCard, file, error);
                    }
                }
                
            } finally {
                // üî• Á°Æ‰øùÊó†ËÆ∫Â¶Ç‰ΩïÈÉΩÈáçÁΩÆÂ§ÑÁêÜÊ†áÂøó
                window.isProcessingFiles = false;
                console.log('‚úÖ File processing completed, processing flag reset');
                
                // üßπ Êñá‰ª∂Â§ÑÁêÜÂÆåÊàêÂêéÂª∂ËøüÊ∏ÖÁêÜ‰∏ä‰º†Âå∫Âüü
                setTimeout(() => {
                    clearUploadArea();
                    console.log('üßπ Upload area cleared after successful processing');
                }, 2000);
            }
            // Âª∂ËøüÊ∏ÖÁêÜÊñá‰ª∂Á≠æÂêçÔºåÂÖÅËÆ∏Áõ∏ÂêåÊñá‰ª∂Âú®5ÁßíÂêéÈáçÊñ∞‰∏ä‰º†
            setTimeout(() => {
                window.lastProcessedSignature = null;
            }, 5000);
            console.log('‚úÖ All files processed, reset processing flag');
            
            showNotification(`üìÅ ${files.length} file(s) uploaded successfully!`);
        }
        
        // üìÑ ÊòæÁ§∫Êñá‰ª∂ÊñáÊú¨ÂÜÖÂÆπ
        function showFileTextContent(fileName, textContent) {
            console.log('üìÑ ÊòæÁ§∫Êñá‰ª∂ÊñáÊú¨ÂÜÖÂÆπ:', fileName);
            
            // ÂàõÂª∫ÂÜÖÂÆπÊòæÁ§∫Ê®°ÊÄÅÊ°Ü
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.6); z-index: 5000; display: flex; 
                align-items: center; justify-content: center;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white; padding: 32px; border-radius: 16px; 
                width: 800px; max-width: 90vw; max-height: 80vh; overflow-y: auto;
                box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            `;
            
            modalContent.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 24px;">
                    <h2 style="margin: 0; color: #1f2937; display: flex; align-items: center; gap: 12px;">
                        üìÑ ${fileName}
                    </h2>
                    <button id="closeContent" style="
                        background: #f3f4f6; border: none; width: 32px; height: 32px; 
                        border-radius: 50%; cursor: pointer; font-size: 16px;
                    ">‚úï</button>
                </div>
                <div style="
                    background: #f9fafb; border-radius: 12px; padding: 24px; 
                    line-height: 1.6; font-size: 15px; color: #374151; white-space: pre-wrap;
                    max-height: 400px; overflow-y: auto;
                ">
                    ${textContent.replace(/\n/g, '<br>').replace(/\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;')}
                </div>
                <div style="margin-top: 24px; text-align: right;">
                    <button id="closeContentBtn" style="
                        padding: 10px 20px; background: linear-gradient(135deg, #6b7280, #4b5563); 
                        color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500;
                    ">Close</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Ê∑ªÂä†ÂÖ≥Èó≠‰∫ã‰ª∂
            const closeBtn = modalContent.querySelector('#closeContent');
            const closeContentBtn = modalContent.querySelector('#closeContentBtn');
            
            const closeModal = () => {
                document.body.removeChild(modal);
            };
            
            closeBtn.addEventListener('click', closeModal);
            closeContentBtn.addEventListener('click', closeModal);
            
            // ÁÇπÂáªËÉåÊôØÂÖ≥Èó≠
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeModal();
                }
            });
        }
        
        // üß† ÁÆÄÂåñ‰∏îÂèØÈù†ÁöÑÊñá‰ª∂È¢ÑËßàÊ®°ÊÄÅÊ°Ü
        function showIntelligentFileModal(fileName, fileData) {
            console.log('üß† ÊòæÁ§∫ÊñáÊ°£È¢ÑËßàÁ™óÂè£:', fileName);
            
            // Ê∏ÖÁêÜÁé∞ÊúâÊ®°ÊÄÅÊ°Ü
            document.querySelectorAll('[style*="position: fixed"]').forEach(modal => {
                if (modal.style.zIndex >= '5000') {
                    modal.remove();
                }
            });
            console.log('üîç Êñá‰ª∂Êï∞ÊçÆÁªìÊûÑ:', {
                name: fileData.name,
                type: fileData.type,
                size: fileData.size,
                hasTextContent: !!fileData.textContent,
                textContentLength: fileData.textContent?.length || 0,
                hasLocalContent: !!fileData.hasLocalContent,
                dataLength: fileData.data?.length || 0,
                savedAt: fileData.savedAt,
                lastModified: fileData.lastModified
            });
            
            // üîç ËØ¶ÁªÜÊ£ÄÊü•ÊñáÊú¨ÂÜÖÂÆπ
            if (fileData.textContent) {
                console.log('üìù ÊñáÊú¨ÂÜÖÂÆπÂ≠òÂú®ÔºåÈïøÂ∫¶:', fileData.textContent.length);
                console.log('üìù ÊñáÊú¨ÂÜÖÂÆπÈ¢ÑËßà(Ââç200Â≠óÁ¨¶):', fileData.textContent.substring(0, 200));
            } else {
                console.log('‚ö†Ô∏è ÊñáÊú¨ÂÜÖÂÆπ‰∏çÂ≠òÂú®ÔºåÊ£ÄÊü•ÂéüÂõ†...');
            }
            
            // üîç Ê£ÄÊü•GraphRAGÂàÜÊûêÊï∞ÊçÆ
            const analysisDB = JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}');
            
            // üî• ‰øÆÂ§çÔºöÊü•ÊâæÂåÖÂê´Êñá‰ª∂ÂêçÁöÑÈîÆÔºàÂõ†‰∏∫ÈîÆÂåÖÂê´Êó∂Èó¥Êà≥Ôºâ
            const matchingKey = Object.keys(analysisDB).find(key => key.includes(fileName));
            const fileAnalysis = matchingKey ? analysisDB[matchingKey] : null;
            
            console.log('üß† GraphRAGÂàÜÊûêÊï∞ÊçÆ:', fileAnalysis ? 'Â≠òÂú®' : '‰∏çÂ≠òÂú®');
            console.log('üîë ÂåπÈÖçÁöÑÈîÆÂêç:', matchingKey || 'Êú™ÊâæÂà∞');
            if (fileAnalysis) {
                console.log('üìä ÂàÜÊûêÂÜÖÂÆπÈïøÂ∫¶:', fileAnalysis.extractedContent?.length || 0);
                if (fileAnalysis.extractedContent) {
                    console.log('üìä ÂàÜÊûêÂÜÖÂÆπÈ¢ÑËßà:', fileAnalysis.extractedContent.substring(0, 200));
                }
            }
            
            // ÂàõÂª∫Ê®°ÊÄÅÊ°Ü
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.7); z-index: 6000; display: flex; 
                align-items: center; justify-content: center;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white; border-radius: 20px; 
                width: 1200px; max-width: 95vw; max-height: 95vh; overflow-y: auto;
                box-shadow: 0 25px 80px rgba(0,0,0,0.4); animation: modalSlideIn 0.3s ease;
                display: flex; flex-direction: column;
            `;
            
            // üìä Êñá‰ª∂‰ø°ÊÅØÂàÜÊûê
            const hasTextContent = fileData.textContent && fileData.textContent.length > 0;
            const hasFullContent = fileData.hasLocalContent && fileData.data;
            const fileSize = fileData.size ? (fileData.size / 1024 / 1024).toFixed(2) + 'MB' : 'Unknown';
            const fileIcon = getFileTypeIcon(fileData.type, fileName);
            
            // üß† ‰∏çÂÜçÂú®ËøôÈáåÊòæÁ§∫ÊëòË¶ÅÔºåÈÅøÂÖçÈáçÂ§ç
            let graphragSummary = '';
            
            // Ëé∑ÂèñÊñá‰ª∂ÂÜÖÂÆπÁî®‰∫éÁîüÊàêÊñáÊ°£ÁªìÊûÑ - ‰ºòÂÖà‰ΩøÁî®GraphRAGÂàÜÊûêÁªìÊûú
            let content;
            if (fileAnalysis && fileAnalysis.extractedContent) {
                console.log('üöÄ ‰ΩøÁî®GraphRAGÂ¢ûÂº∫ÂÜÖÂÆπÁîüÊàêÊñáÊ°£ÁªìÊûÑ');
                content = fileAnalysis.extractedContent;
            } else {
                console.log('‚ö†Ô∏è GraphRAGÂÜÖÂÆπ‰∏çÂèØÁî®Ôºå‰ΩøÁî®ÂéüÂßãÊñáÊú¨ÂÜÖÂÆπ');
                content = fileData.textContent || `ÊñáÊ°£: ${fileName}\nÁ±ªÂûã: ${fileData.type}\nÂ§ßÂ∞è: ${(fileData.size / 1024 / 1024).toFixed(2)}MB`;
            }
            
            modalContent.innerHTML = `
                <!-- Â§¥ÈÉ® -->
                <div style="padding: 20px 30px; border-bottom: 1px solid #e5e7eb; display: flex; justify-content: space-between; align-items: center;">
                    <div style="display: flex; align-items: center; gap: 16px;">
                        <div style="font-size: 36px;">${fileIcon}</div>
                        <div>
                            <h2 style="margin: 0 0 4px 0; color: #1f2937; font-size: 20px;">${fileName}</h2>
                            <div style="color: #6b7280; font-size: 14px;">${fileData.type || 'Unknown type'} ‚Ä¢ ${fileSize}</div>
                        </div>
                    </div>
                    <button id="closeFileModal" style="
                        background: #f3f4f6; border: none; width: 36px; height: 36px; 
                        border-radius: 50%; cursor: pointer; font-size: 18px; color: #6b7280;
                        display: flex; align-items: center; justify-content: center;
                    ">‚úï</button>
                </div>
                
                <!-- Â∑•ÂÖ∑Ê†è -->
                <div style="padding: 15px 30px; border-bottom: 1px solid #e5e7eb; display: flex; justify-content: flex-end;">
                    <button onclick="console.log('üîß ÁºñËæëÊåâÈíÆÁÇπÂáª'); openDocumentEditor('${fileName}')" style="
                        background: #3b82f6; color: white; border: none; 
                        padding: 10px 20px; border-radius: 8px; cursor: pointer; 
                        font-size: 14px; display: flex; align-items: center; gap: 8px; font-weight: 500;
                    ">
                        ‚úèÔ∏è Edit Document
                    </button>
                </div>
                
                <!-- ‰∏ªË¶ÅÂÜÖÂÆπÂå∫Âüü -->
                <div style="flex: 1; display: grid; grid-template-columns: 400px 1fr; gap: 20px; padding: 20px 30px; overflow: hidden;">
                    <!-- Â∑¶‰æßÔºöÊñáÊ°£ÁõÆÂΩï -->
                    <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 12px; overflow: hidden; display: flex; flex-direction: column;">
                        <div style="background: #e2e8f0; padding: 12px 16px; border-bottom: 1px solid #d1d5db;">
                            <h4 style="margin: 0; color: #1f2937; font-size: 14px; font-weight: 600;">üìã Document Outline</h4>
                        </div>
                        <div style="flex: 1; padding: 12px; overflow-y: auto;" id="documentStructure">
                            <div style="text-align: center; padding: 40px 20px; color: #6b7280;">
                                <div style="font-size: 24px; margin-bottom: 12px;">üìã</div>
                                <p style="margin: 0; font-size: 14px;">Loading document structure...</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Âè≥‰æßÔºöÂÜÖÂÆπÈ¢ÑËßà -->
                    <div style="background: white; border: 1px solid #e2e8f0; border-radius: 12px; overflow: hidden; display: flex; flex-direction: column;">
                        <div style="background: #f8fafc; padding: 12px 16px; border-bottom: 1px solid #e2e8f0;">
                            <h4 style="margin: 0; color: #1f2937; font-size: 14px; font-weight: 600;">üëÅÔ∏è Content Preview</h4>
                        </div>
                        <div id="documentPreviewContent" style="
                            flex: 1; padding: 20px; overflow-y: auto;
                            line-height: 1.6; color: #374151; font-size: 15px;
                        ">
                            <div style="text-align: center; padding: 60px 20px; color: #9ca3af;">
                                <div style="font-size: 48px; margin-bottom: 16px;">üìñ</div>
                                <h3 style="margin: 0 0 8px 0; color: #6b7280;">Select a section to view content</h3>
                                <p style="margin: 0; font-size: 14px;">Click on any section in the left outline to view its content here</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Â∫ïÈÉ®ÊåâÈíÆ -->
                <div style="padding: 15px 30px; border-top: 1px solid #e5e7eb; display: flex; justify-content: flex-end;">
                    <button id="closeModalBtn" style="
                        padding: 8px 16px; background: #f3f4f6; color: #374151; border: none; 
                        border-radius: 6px; cursor: pointer; font-size: 14px;
                    ">Close</button>
                </div>
            `;
            
            // Ê∑ªÂä†Ê®°ÊÄÅÁ™óÂè£Âà∞È°µÈù¢
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // üî• ÈáçË¶ÅÔºöÁ°Æ‰øùÊ®°ÊÄÅÊ°ÜDOMÂÆåÂÖ®Ê∏≤ÊüìÂêéÂÜçÈáçÊñ∞ÁîüÊàêÊñáÊ°£ÁªìÊûÑ  
            setTimeout(() => {
                const structureContainer = document.getElementById('documentStructure');
                if (structureContainer) {
                    try {
                        structureContainer.innerHTML = generateDocumentStructure(content, fileName);
                        console.log('üéØ Ê®°ÊÄÅÊ°ÜDOMÂÆåÂÖ®Ê∏≤ÊüìÂêéÈáçÊñ∞ÁîüÊàêÊñáÊ°£ÁªìÊûÑ');
                    } catch (error) {
                        console.error('ÈáçÊñ∞ÁîüÊàêÊñáÊ°£ÁªìÊûÑÂ§±Ë¥•:', error);
                        structureContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #6b7280;">ÊñáÊ°£ÁªìÊûÑÁîüÊàêÂ§±Ë¥•</div>';
                    }
                }
            }, 50);
            
            // ‰∫ã‰ª∂Â§ÑÁêÜ
            const closeModal = () => {
                if (document.body.contains(modal)) {
                    document.body.removeChild(modal);
                }
            };
            
            // ÁªëÂÆöÂÖ≥Èó≠‰∫ã‰ª∂
            modalContent.querySelector('#closeFileModal')?.addEventListener('click', closeModal);
            modalContent.querySelector('#closeModalBtn')?.addEventListener('click', closeModal);
            
            // ÁÇπÂáªËÉåÊôØÂÖ≥Èó≠
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeModal();
            });
        }
        
        // üìÅ Ëé∑ÂèñÊñá‰ª∂Á±ªÂûãÂõæÊ†á
        function getFileTypeIcon(mimeType, fileName) {
            if (mimeType?.includes('pdf') || fileName?.endsWith('.pdf')) return 'üìÑ';
            if (mimeType?.includes('word') || fileName?.endsWith('.doc') || fileName?.endsWith('.docx')) return 'üìù';
            if (mimeType?.includes('excel') || fileName?.endsWith('.xls') || fileName?.endsWith('.xlsx')) return 'üìä';
            if (mimeType?.includes('image')) return 'üñºÔ∏è';
            if (mimeType?.includes('text') || fileName?.endsWith('.txt') || fileName?.endsWith('.md')) return 'üìÉ';
            if (fileName?.endsWith('.json')) return 'üîß';
            if (fileName?.endsWith('.csv')) return 'üìã';
            return 'üìÑ';
        }
        
        // ÂàõÂª∫Êô∫ËÉΩÊñá‰ª∂Âç°Áâá
        async function createIntelligentFileCard(file, index) {
            const fileCard = document.createElement('div');
            fileCard.id = `file-card-${index}`;
            fileCard.style.cssText = `
                background: white; border: 2px solid #e2e8f0; border-radius: 12px;
                padding: 16px; margin-bottom: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                animation: slideInUp 0.5s ease ${index * 0.1}s both; position: relative;
            `;
            
            const fileInfo = getFileIcon(file.type) + ' ' + file.name + ' (' + formatFileSize(file.size) + ')';
            
            fileCard.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                    <span style="font-size: 14px; color: #374151; font-weight: 500;">${fileInfo}</span>
                    <button onclick="removeFile(this)" style="
                        background: #ef4444; color: white; border: none; 
                        padding: 6px 10px; border-radius: 6px; cursor: pointer; font-size: 12px;
                    ">Remove</button>
                </div>
                
                <!-- Processing Status -->
                <div id="processing-status-${index}" style="
                    background: linear-gradient(135deg, #667eea, #764ba2);
                    color: white; padding: 12px; border-radius: 8px; margin-bottom: 8px;
                ">
                    <div style="display: flex; align-items: center;">
                        <div class="spinner" style="
                            width: 16px; height: 16px; border: 2px solid rgba(255,255,255,0.3);
                            border-top: 2px solid white; border-radius: 50%; 
                            animation: spin 1s linear infinite; margin-right: 8px;
                        "></div>
                        <span style="font-size: 12px;">üöÄ Ê≠£Âú®ÂêØÂä®Êô∫ËÉΩÂàÜÊûê...</span>
                    </div>
                    <div style="
                        background: rgba(255,255,255,0.2); height: 4px; border-radius: 2px; 
                        margin-top: 8px; overflow: hidden;
                    ">
                        <div id="progress-bar-${index}" style="
                            background: white; height: 100%; width: 10%; border-radius: 2px;
                            transition: width 0.3s ease;
                        "></div>
                    </div>
                </div>
                
                <!-- Analysis Results (initially hidden) -->
                <div id="analysis-results-${index}" style="display: none;"></div>
                
                <!-- Knowledge Tree Suggestion (initially hidden) -->
                <div id="tree-suggestion-${index}" style="display: none;"></div>
            `;
            
            return fileCard;
        }
        
        // Êõ¥Êñ∞Êñá‰ª∂Âç°ÁâáÊòæÁ§∫ÂàÜÊûêÁªìÊûú
        async function updateFileCardWithAnalysis(fileCard, file, analysisResult) {
            const index = fileCard.id.split('-')[2];
            const statusDiv = document.getElementById(`processing-status-${index}`);
            const resultsDiv = document.getElementById(`analysis-results-${index}`);
            
            // ÈöêËóèÂ§ÑÁêÜÁä∂ÊÄÅ
            statusDiv.style.display = 'none';
            
            // ÊòæÁ§∫ÂàÜÊûêÁªìÊûú
            resultsDiv.style.display = 'block';
            resultsDiv.innerHTML = `
                <div style="background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 8px; padding: 12px; margin-bottom: 8px;">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                        <h4 style="margin: 0; color: #0c4a6e; font-size: 14px;">
                            üß† Êô∫ËÉΩÂàÜÊûêÂÆåÊàê
                        </h4>
                        <div style="
                            background: ${analysisResult.processingStage === 'completed' ? '#10b981' : '#f59e0b'};
                            color: white; padding: 4px 8px; border-radius: 4px; font-size: 10px;
                        ">
                            ${analysisResult.processingStage === 'completed' ? '‚úÖ ÂÆåÊàê' : '‚ö†Ô∏è ÈÉ®ÂàÜÂÆåÊàê'}
                        </div>
                    </div>
                    
                    <!-- ÊñáÊ°£Á±ªÂûã -->
                    <div style="margin-bottom: 8px;">
                        <span style="font-size: 12px; color: #0369a1;">
                            üìÑ ÊñáÊ°£Á±ªÂûã: <strong>${analysisResult.documentAnalysis?.fileType?.supportedFormat || 'Unknown'}</strong>
                        </span>
                    </div>
                    
                    <!-- ÊèêÂèñÁöÑÂÆû‰Ωì -->
                    ${analysisResult.entityAnalysis?.entities?.length > 0 ? `
                    <div style="margin-bottom: 8px;">
                        <div style="font-size: 12px; color: #0369a1; margin-bottom: 4px;">üîç ËØÜÂà´ÂÆû‰Ωì:</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 4px;">
                            ${analysisResult.entityAnalysis.entities.slice(0, 6).map(entity => `
                                <span style="
                                    background: #ddd6fe; color: #5b21b6; padding: 2px 6px; 
                                    border-radius: 10px; font-size: 10px;
                                ">
                                    ${typeof entity === 'string' ? entity : entity.value || entity.label}
                                </span>
                            `).join('')}
                            ${analysisResult.entityAnalysis.entities.length > 6 ? `
                                <span style="color: #6b7280; font-size: 10px;">+${analysisResult.entityAnalysis.entities.length - 6} more</span>
                            ` : ''}
                        </div>
                    </div>
                    ` : ''}
                    
                    <!-- Á§æÂå∫Ê£ÄÊµã -->
                    ${analysisResult.communityAnalysis?.totalCommunities > 0 ? `
                    <div style="margin-bottom: 8px;">
                        <span style="font-size: 12px; color: #0369a1;">
                            üèòÔ∏è Ê¶ÇÂøµÁ§æÂå∫: <strong>${analysisResult.communityAnalysis.totalCommunities}</strong>
                        </span>
                    </div>
                    ` : ''}
                    
                    <!-- Â§ÑÁêÜÊó∂Èó¥ -->
                    <div style="text-align: right; margin-top: 8px;">
                        <span style="font-size: 10px; color: #6b7280;">
                            ‚è±Ô∏è ÂàÜÊûêËÄóÊó∂: ${analysisResult.processingTime || 0}ms
                        </span>
                    </div>
                </div>
            `;
        }
        
        // ÊòæÁ§∫Áü•ËØÜÊ†ë‰ΩçÁΩÆÂª∫ËÆÆ
        async function showKnowledgeTreeSuggestion(file, analysisResult, fileIndex) {
            const suggestionDiv = document.getElementById(`tree-suggestion-${fileIndex}`);
            if (!suggestionDiv) return;
            
            if (!analysisResult.positionSuggestion) return;
            
            suggestionDiv.style.display = 'block';
            suggestionDiv.innerHTML = `
                <div style="
                    background: linear-gradient(135deg, #10b981, #059669);
                    color: white; padding: 12px; border-radius: 8px; margin-bottom: 8px;
                ">
                    <h4 style="margin: 0 0 8px 0; font-size: 14px; display: flex; align-items: center;">
                        üå≥ Áü•ËØÜÊ†ë‰ΩçÁΩÆÂª∫ËÆÆ
                        <div style="
                            background: rgba(255,255,255,0.2); padding: 2px 6px; border-radius: 4px; 
                            font-size: 10px; margin-left: 8px;
                        ">
                            ${safePercent(analysisResult.positionSuggestion.confidence)}% ÁΩÆ‰ø°Â∫¶
                        </div>
                    </h4>
                    
                    <div style="background: rgba(255,255,255,0.1); padding: 8px; border-radius: 6px; margin-bottom: 8px;">
                        <div style="font-size: 12px; margin-bottom: 4px;">üìç Êé®Ëçê‰ΩçÁΩÆ:</div>
                        <div style="font-weight: 600; font-size: 14px;">
                            ${analysisResult.positionSuggestion.primarySuggestion?.path || 'ÂÖ∂‰ªñ/Êú™ÂàÜÁ±ª'}
                        </div>
                    </div>
                    
                    ${analysisResult.positionSuggestion.reasoning ? `
                    <div style="font-size: 11px; opacity: 0.9; margin-bottom: 8px;">
                        üí° ${analysisResult.positionSuggestion.reasoning}
                    </div>
                    ` : ''}
                    
                    <div style="
                        background: rgba(255,255,255,0.1); color: rgba(255,255,255,0.9); 
                        padding: 8px 12px; border-radius: 6px; margin-top: 8px;
                        font-size: 11px; text-align: center; border: 1px solid rgba(255,255,255,0.2);
                    ">
                        ‚úÖ Â∑≤Ëá™Âä®‰øùÂ≠òÂà∞Áü•ËØÜÊ†ë
                    </div>
                </div>
            `;
        }
        
        // Êõ¥Êñ∞Â§ÑÁêÜËøõÂ∫¶
        function updateProcessingProgress(index, stage, progress) {
            const progressBar = document.getElementById(`progress-bar-${index}`);
            const statusText = document.querySelector(`#processing-status-${index} span`);
            
            if (progressBar && statusText) {
                progressBar.style.width = `${progress}%`;
                
                const stageMessages = {
                    'document_processing': 'üìÑ Â§ÑÁêÜÊñáÊ°£Ê†ºÂºè...',
                    'entity_extraction': 'ü§ñ ÊèêÂèñÂÆû‰ΩìÂÖ≥Á≥ª...',
                    'community_detection': 'üèòÔ∏è Ê£ÄÊµãÊ¶ÇÂøµÁ§æÂå∫...',
                    'position_suggestion': 'üå≥ ÁîüÊàê‰ΩçÁΩÆÂª∫ËÆÆ...',
                    'completed': '‚úÖ ÂàÜÊûêÂÆåÊàê!'
                };
                
                statusText.textContent = stageMessages[stage] || 'üîÑ Â§ÑÁêÜ‰∏≠...';
            }
        }
        
        // Â§ÑÁêÜÊñá‰ª∂Âç°ÁâáÈîôËØØ
        function updateFileCardWithError(fileCard, file, error) {
            const index = fileCard.id.split('-')[2];
            const statusDiv = document.getElementById(`processing-status-${index}`);
            const resultsDiv = document.getElementById(`analysis-results-${index}`);
            
            statusDiv.style.display = 'none';
            resultsDiv.style.display = 'block';
            resultsDiv.innerHTML = `
                <div style="background: #fef2f2; border: 1px solid #ef4444; border-radius: 8px; padding: 12px;">
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <span style="color: #dc2626; font-size: 14px;">‚ùå ÂàÜÊûêÂ§±Ë¥•</span>
                    </div>
                    <div style="font-size: 12px; color: #7f1d1d; margin-bottom: 8px;">
                        ${error.message || 'Êú™Áü•ÈîôËØØ'}
                    </div>
                    <button onclick="retryAnalysis('${file.name}', ${index})" style="
                        background: #ef4444; color: white; border: none;
                        padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 11px;
                    ">
                        üîÑ ÈáçËØïÂàÜÊûê
                    </button>
                </div>
            `;
        }
        
        // üî• Ëá™Âä®‰øùÂ≠òÂà∞Áü•ËØÜÊ†ëÔºàÊó†ÈúÄÁî®Êà∑Á°ÆËÆ§Ôºâ
        async function autoSaveToKnowledgeTree(file, analysisResult) {
            console.log('ü§ñ Ê†πÊçÆAIÂàÜÊûêÁªìÊûúËá™Âä®‰øùÂ≠òÊñá‰ª∂:', file.name);
            
            try {
                // üîç Ê£ÄÊü•ÂÜÖÂÆπÈáçÂ§ç - Âü∫‰∫éURLÊàñÂÜÖÂÆπÂìàÂ∏å
                const isDuplicate = await checkContentDuplicate(file, analysisResult);
                if (isDuplicate.found) {
                    console.log('‚ö†Ô∏è Ê£ÄÊµãÂà∞ÈáçÂ§çÂÜÖÂÆπÔºåË∑≥Ëøá‰øùÂ≠ò:', isDuplicate.reason);
                    showNotification(`‚ö†Ô∏è ÂÜÖÂÆπÂ∑≤Â≠òÂú®Ôºö${isDuplicate.existingFile} (${isDuplicate.reason})`, 'warning');
                    
                    // Áõ¥Êé•ÂØºËà™Âà∞Â∑≤Â≠òÂú®ÁöÑÊñá‰ª∂
                    setTimeout(() => {
                        openKnowledgePanel();
                        navigateToKnowledgeTree(isDuplicate.category, isDuplicate.existingFile);
                    }, 1000);
                    return;
                }
                
                // üéØ ÊîπËøõÂàÜÁ±ªÂáÜÁ°ÆÊÄß - Âü∫‰∫éÂÜÖÂÆπÁ±ªÂûãÂíåÊù•Ê∫ê
                const improvedPath = improveClassificationAccuracy(file, analysisResult);
                console.log('üìç ÂéüAIË∑ØÂæÑ:', analysisResult.positionSuggestion?.primarySuggestion?.path || 'Êô∫ËÉΩÂàÜÁ±ª/AIÂàÜÊûê');
                console.log('üìç ‰ºòÂåñÂêéË∑ØÂæÑ:', improvedPath);
                
                // üî• ‰øùÂ≠òÂéüÂßãÊñá‰ª∂Âà∞Êú¨Âú∞ÔºàÁî®‰∫éÂêéÁª≠Áî®Êú¨Âú∞Â∑•ÂÖ∑ÊâìÂºÄÔºâ
                const fileStorageKey = await saveFileLocally(file);
                
                // üî• Â≠òÂÇ®GraphRAGÂàÜÊûêÊï∞ÊçÆÔºàÁî®‰∫éÁü•ËØÜÂõæË∞±ÊûÑÂª∫Ôºâ
                await storeGraphRAGAnalysis(file.name, analysisResult);
                
                // üî• Ëá™Âä®Ê∑ªÂä†Âà∞Áü•ËØÜÊ†ëÔºå‰ΩøÁî®‰ºòÂåñÁöÑË∑ØÂæÑÂíåÂ≠òÂÇ®ÈîÆ
                await addFileWithAIGuidanceAndStorage(file.name, improvedPath, analysisResult, file, fileStorageKey);
                
                // ÊòæÁ§∫ÊàêÂäüÈÄöÁü•ÔºàÂè™ÊòæÁ§∫‰∏ªË¶ÅÂàÜÁ±ªÔºâ
                const mainCategory = improvedPath.split(/[/>]/).filter(p => p.trim())[0] || 'Êô∫ËÉΩÂàÜÁ±ª';
                showNotification(`üéØ AIÂ∑≤Ëá™Âä®Â∞Ü "${file.name}" ÂàÜÁ±ªÂà∞ "${mainCategory}"`, 'success');
                
                // üîÑ Ëá™Âä®Ë∑≥ËΩ¨Âà∞Áü•ËØÜÂ∫ìÊòæÁ§∫ÁªìÊûú
                setTimeout(() => {
                    openKnowledgePanel();
                    navigateToKnowledgeTree(mainCategory, file.name);
                }, 1000);
                
                console.log('‚úÖ Êñá‰ª∂Â∑≤Ëá™Âä®‰øùÂ≠òÂà∞Áü•ËØÜÊ†ë');
                
            } catch (error) {
                console.error('‚ùå Ëá™Âä®‰øùÂ≠òÂ§±Ë¥•:', error);
                showNotification(`‚ùå Ëá™Âä®‰øùÂ≠òÂ§±Ë¥•: ${error.message}`, 'error');
            }
        }
        
        // üîç Ê£ÄÊü•ÂÜÖÂÆπÈáçÂ§ç - Âü∫‰∫éURL„ÄÅÂÜÖÂÆπÂìàÂ∏åÊàñÁõ∏‰ººÊÄßÊ£ÄÊµã
        async function checkContentDuplicate(file, analysisResult) {
            console.log('üîç ÂºÄÂßãÊ£ÄÊü•ÂÜÖÂÆπÈáçÂ§ç:', file.name);
            
            try {
                const knowledgeTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
                
                // 1. Ê£ÄÊü•URLÈáçÂ§çÔºàÂØπ‰∫éÁΩëÈ°µÂÜÖÂÆπÔºâ
                if (file.sourceUrl) {
                    for (const [categoryName, categoryData] of Object.entries(knowledgeTree)) {
                        if (categoryData.files) {
                            for (const existingFile of categoryData.files) {
                                // Ê£ÄÊü•ÊòØÂê¶ÊòØÂêå‰∏Ä‰∏™URL
                                const storedFileData = localStorage.getItem(existingFile.storageKey);
                                if (storedFileData) {
                                    const fileData = JSON.parse(storedFileData);
                                    if (fileData.sourceUrl === file.sourceUrl) {
                                        return {
                                            found: true,
                                            reason: 'Áõ∏ÂêåURL',
                                            existingFile: existingFile.name,
                                            category: categoryName,
                                            url: file.sourceUrl
                                        };
                                    }
                                }
                            }
                        }
                    }
                }
                
                // 2. Ê£ÄÊü•ÂÜÖÂÆπÂìàÂ∏åÈáçÂ§çÔºàÂØπ‰∫éÊñá‰ª∂ÂÜÖÂÆπÔºâ
                const currentContent = analysisResult.analysis?.content || analysisResult.content || '';
                if (currentContent.length > 100) {
                    // ÁîüÊàêÂÜÖÂÆπÂìàÂ∏å
                    const contentHash = await generateContentHash(currentContent);
                    
                    for (const [categoryName, categoryData] of Object.entries(knowledgeTree)) {
                        if (categoryData.files) {
                            for (const existingFile of categoryData.files) {
                                // Ê£ÄÊü•Áé∞ÊúâÊñá‰ª∂ÁöÑÂÜÖÂÆπÂìàÂ∏å
                                const storedFileData = localStorage.getItem(existingFile.storageKey);
                                if (storedFileData) {
                                    const fileData = JSON.parse(storedFileData);
                                    const existingContent = fileData.textContent || '';
                                    
                                    if (existingContent.length > 100) {
                                        const existingHash = await generateContentHash(existingContent);
                                        if (contentHash === existingHash) {
                                            return {
                                                found: true,
                                                reason: 'ÂÜÖÂÆπÂÆåÂÖ®Áõ∏Âêå',
                                                existingFile: existingFile.name,
                                                category: categoryName,
                                                similarity: 1.0
                                            };
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                // 3. Ê£ÄÊü•ÂÜÖÂÆπÁõ∏‰ººÊÄßÔºàÊ†áÈ¢òÁõ∏‰ººÂ∫¶Ê£ÄÊµãÔºâ
                const currentTitle = analysisResult.analysis?.fileInfo?.filename || file.name;
                for (const [categoryName, categoryData] of Object.entries(knowledgeTree)) {
                    if (categoryData.files) {
                        for (const existingFile of categoryData.files) {
                            const similarity = calculateStringSimilarity(currentTitle, existingFile.name);
                            if (similarity > 0.85) { // 85%‰ª•‰∏äÁõ∏‰ººÂ∫¶ËÆ§‰∏∫ÂèØËÉΩÈáçÂ§ç
                                // Ëøõ‰∏ÄÊ≠•Ê£ÄÊü•ÂÜÖÂÆπÁõ∏‰ººÊÄß
                                const storedFileData = localStorage.getItem(existingFile.storageKey);
                                if (storedFileData) {
                                    const fileData = JSON.parse(storedFileData);
                                    const existingContent = fileData.textContent || '';
                                    const currentContent = analysisResult.analysis?.content || analysisResult.content || '';
                                    
                                    const contentSimilarity = calculateContentSimilarity(currentContent, existingContent);
                                    if (contentSimilarity > 0.8) { // 80%‰ª•‰∏äÂÜÖÂÆπÁõ∏‰ººÂ∫¶
                                        return {
                                            found: true,
                                            reason: `È´òÂ∫¶Áõ∏‰ºº (${Math.round(similarity * 100)}%Ê†áÈ¢òÁõ∏‰ºº, ${Math.round(contentSimilarity * 100)}%ÂÜÖÂÆπÁõ∏‰ºº)`,
                                            existingFile: existingFile.name,
                                            category: categoryName,
                                            similarity: Math.max(similarity, contentSimilarity)
                                        };
                                    }
                                }
                            }
                        }
                    }
                }
                
                console.log('‚úÖ Êú™ÂèëÁé∞ÈáçÂ§çÂÜÖÂÆπ');
                return { found: false };
                
            } catch (error) {
                console.error('‚ùå Ê£ÄÊü•ÈáçÂ§çÂÜÖÂÆπÂ§±Ë¥•:', error);
                return { found: false };
            }
        }
        
        // üéØ ÊîπËøõÂàÜÁ±ªÂáÜÁ°ÆÊÄß - Âü∫‰∫éÂÜÖÂÆπÁ±ªÂûã„ÄÅÊù•Ê∫êÂíåÂÆûÈôÖÂÜÖÂÆπÂàÜÊûê
        function improveClassificationAccuracy(file, analysisResult) {
            console.log('üéØ ÂºÄÂßãÊîπËøõÂàÜÁ±ªÂáÜÁ°ÆÊÄß');
            
            try {
                // Ëé∑ÂèñÂéüÂßãAIÂª∫ËÆÆË∑ØÂæÑ
                const originalPath = analysisResult.positionSuggestion?.primarySuggestion?.path || 'Êô∫ËÉΩÂàÜÁ±ª/AIÂàÜÊûê';
                
                // 1. Âü∫‰∫éÊñá‰ª∂Êù•Ê∫êÁöÑÂàÜÁ±ª‰ºòÂåñ
                if (file.sourceUrl) {
                    const url = new URL(file.sourceUrl);
                    const hostname = url.hostname.toLowerCase();
                    
                    // YouTubeËßÜÈ¢ëÂàÜÁ±ª
                    if (hostname.includes('youtube.com') || hostname.includes('youtu.be')) {
                        const title = analysisResult.analysis?.fileInfo?.filename || file.name;
                        
                        // Èü≥‰πêÁ±ªÂÜÖÂÆπ
                        if (title.match(/(music|song|album|artist|mv|official|video)/i) ||
                            analysisResult.analysis?.content?.match(/‚ô™|‚ô´|lyrics|Ê≠åËØç/g)) {
                            return 'Â§öÂ™í‰ΩìÂÜÖÂÆπ/YouTube/Èü≥‰πêËßÜÈ¢ë';
                        }
                        
                        // ÊïôËÇ≤Á±ªÂÜÖÂÆπ
                        if (title.match(/(tutorial|course|lesson|education|learn|how to)/i) ||
                            analysisResult.analysis?.concepts?.some(c => 
                                c.match(/(ÊïôÁ®ã|ËØæÁ®ã|Â≠¶‰π†|ÊïôËÇ≤|ÂüπËÆ≠)/i))) {
                            return 'Â≠¶‰π†ËµÑÊñô/Âú®Á∫øÊïôÁ®ã/YouTubeÊïôÂ≠¶';
                        }
                        
                        // ÊäÄÊúØÁ±ªÂÜÖÂÆπ
                        if (analysisResult.analysis?.concepts?.some(c => 
                            c.match(/(ÊäÄÊúØ|ÁºñÁ®ã|ÂºÄÂèë|coding|programming|tech)/i))) {
                            return 'ÊäÄÊúØËµÑÊñô/ËßÜÈ¢ëÊïôÁ®ã/YouTubeÊäÄÊúØ';
                        }
                        
                        // ÈªòËÆ§YouTubeÂàÜÁ±ª
                        return 'Â§öÂ™í‰ΩìÂÜÖÂÆπ/YouTube/ËßÜÈ¢ëÂÜÖÂÆπ';
                    }
                    
                    // GitHubÈ°πÁõÆÂàÜÁ±ª
                    if (hostname.includes('github.com')) {
                        // Ê£ÄÊµãÁºñÁ®ãËØ≠Ë®Ä
                        const content = analysisResult.analysis?.content || '';
                        if (content.includes('package.json') || content.includes('node_modules')) {
                            return 'ÊäÄÊúØËµÑÊñô/ÂºÄÊ∫êÈ°πÁõÆ/JavaScriptÈ°πÁõÆ';
                        }
                        if (content.includes('requirements.txt') || content.includes('setup.py')) {
                            return 'ÊäÄÊúØËµÑÊñô/ÂºÄÊ∫êÈ°πÁõÆ/PythonÈ°πÁõÆ';
                        }
                        if (content.includes('Cargo.toml') || content.includes('.rs')) {
                            return 'ÊäÄÊúØËµÑÊñô/ÂºÄÊ∫êÈ°πÁõÆ/RustÈ°πÁõÆ';
                        }
                        if (content.includes('pom.xml') || content.includes('.java')) {
                            return 'ÊäÄÊúØËµÑÊñô/ÂºÄÊ∫êÈ°πÁõÆ/JavaÈ°πÁõÆ';
                        }
                        return 'ÊäÄÊúØËµÑÊñô/ÂºÄÊ∫êÈ°πÁõÆ/‰ª£Á†Å‰ªìÂ∫ì';
                    }
                    
                    // ÂÖ∂‰ªñÁΩëÁ´ôÂàÜÁ±ª
                    return `ÁΩëÈ°µÂÜÖÂÆπ/${hostname.replace('www.', '')}/ÁΩëÈ°µËµÑÊñô`;
                }
                
                // 2. Âü∫‰∫éÊñá‰ª∂Á±ªÂûãÁöÑÂàÜÁ±ª‰ºòÂåñ
                const fileExtension = file.name.split('.').pop()?.toLowerCase();
                if (fileExtension) {
                    const documentTypes = ['pdf', 'doc', 'docx', 'txt', 'md', 'rtf'];
                    const imageTypes = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'webp'];
                    const codeTypes = ['js', 'ts', 'py', 'java', 'cpp', 'c', 'rs', 'go', 'php'];
                    const dataTypes = ['json', 'csv', 'xml', 'yaml', 'yml'];
                    
                    if (documentTypes.includes(fileExtension)) {
                        // Âü∫‰∫éÂÜÖÂÆπËøõ‰∏ÄÊ≠•ÂàÜÁ±ªÊñáÊ°£
                        const concepts = analysisResult.analysis?.concepts || [];
                        if (concepts.some(c => c.match(/(ÊäÄÊúØ|ÁºñÁ®ã|ÂºÄÂèë|API|‰ª£Á†Å)/i))) {
                            return `ÊñáÊ°£ËµÑÊñô/ÊäÄÊúØÊñáÊ°£/${fileExtension.toUpperCase()}Êñá‰ª∂`;
                        }
                        if (concepts.some(c => c.match(/(ÂïÜ‰∏ö|‰∏öÂä°|ÁÆ°ÁêÜ|Êä•Âëä)/i))) {
                            return `ÊñáÊ°£ËµÑÊñô/ÂïÜ‰∏öÊñáÊ°£/${fileExtension.toUpperCase()}Êñá‰ª∂`;
                        }
                        return `ÊñáÊ°£ËµÑÊñô/‰∏ÄËà¨ÊñáÊ°£/${fileExtension.toUpperCase()}Êñá‰ª∂`;
                    }
                    
                    if (imageTypes.includes(fileExtension)) {
                        return `Â§öÂ™í‰ΩìÂÜÖÂÆπ/ÂõæÁâáÊñá‰ª∂/${fileExtension.toUpperCase()}ÂõæÁâá`;
                    }
                    
                    if (codeTypes.includes(fileExtension)) {
                        return `ÊäÄÊúØËµÑÊñô/Ê∫ê‰ª£Á†Å/${fileExtension.toUpperCase()}‰ª£Á†Å`;
                    }
                    
                    if (dataTypes.includes(fileExtension)) {
                        return `Êï∞ÊçÆÊñá‰ª∂/ÁªìÊûÑÂåñÊï∞ÊçÆ/${fileExtension.toUpperCase()}Êï∞ÊçÆ`;
                    }
                }
                
                // 3. Âü∫‰∫éÂÜÖÂÆπÊ¶ÇÂøµÁöÑÂàÜÁ±ª‰ºòÂåñ
                const concepts = analysisResult.analysis?.concepts || [];
                const entities = analysisResult.analysis?.entities || [];
                const allTerms = [...concepts, ...entities].join(' ').toLowerCase();
                
                // ÊäÄÊúØÁõ∏ÂÖ≥ÂÜÖÂÆπ
                if (allTerms.match(/(ÊäÄÊúØ|ÂºÄÂèë|ÁºñÁ®ã|‰ª£Á†Å|api|Á≥ªÁªü|Êû∂ÊûÑ|framework|Â∫ì)/)) {
                    return 'ÊäÄÊúØËµÑÊñô/ÂºÄÂèëÊñáÊ°£/ÊäÄÊúØÂàÜÊûê';
                }
                
                // Â≠¶‰π†Áõ∏ÂÖ≥ÂÜÖÂÆπ
                if (allTerms.match(/(Â≠¶‰π†|ÊïôËÇ≤|ËØæÁ®ã|ÊïôÁ®ã|ÂüπËÆ≠|Áü•ËØÜ|Â≠¶Áßë)/)) {
                    return 'Â≠¶‰π†ËµÑÊñô/ÊïôËÇ≤ÂÜÖÂÆπ/Áü•ËØÜÊñáÊ°£';
                }
                
                // ÂïÜ‰∏öÁõ∏ÂÖ≥ÂÜÖÂÆπ
                if (allTerms.match(/(ÂïÜ‰∏ö|‰∏öÂä°|ÁÆ°ÁêÜ|Â∏ÇÂú∫|Ëê•ÈîÄ|Á≠ñÁï•|ÊñπÊ°à)/)) {
                    return 'ÂïÜ‰∏öËµÑÊñô/‰∏öÂä°ÊñáÊ°£/ÁÆ°ÁêÜËµÑÊñô';
                }
                
                // 4. ‰ΩøÁî®ÂéüÂßãAIË∑ØÂæÑ‰ΩÜÊîπËøõ‰∏ªË¶ÅÂàÜÁ±ª
                const pathParts = originalPath.split(/[/>]/).filter(p => p.trim());
                if (pathParts.length > 0) {
                    const mainCategory = pathParts[0];
                    
                    // ÊîπËøõ‰∏ªË¶ÅÂàÜÁ±ªÁöÑÂáÜÁ°ÆÊÄß
                    const improvedMainCategory = improveMainCategoryName(mainCategory, allTerms);
                    
                    // ÈáçÊûÑË∑ØÂæÑ
                    if (improvedMainCategory !== mainCategory) {
                        return `${improvedMainCategory}/${pathParts.slice(1).join('/')}`;
                    }
                }
                
                console.log('üìç ‰ΩøÁî®ÂéüÂßãAIË∑ØÂæÑ:', originalPath);
                return originalPath;
                
            } catch (error) {
                console.error('‚ùå ÊîπËøõÂàÜÁ±ªÂáÜÁ°ÆÊÄßÂ§±Ë¥•:', error);
                return analysisResult.positionSuggestion?.primarySuggestion?.path || 'Êô∫ËÉΩÂàÜÁ±ª/AIÂàÜÊûê';
            }
        }
        
        // üîß ËæÖÂä©ÂáΩÊï∞ÔºöÊîπËøõ‰∏ªË¶ÅÂàÜÁ±ªÂêçÁß∞
        function improveMainCategoryName(categoryName, contentTerms) {
            const categoryLower = categoryName.toLowerCase();
            
            // ÊäÄÊúØÁ±ªÂà´Êò†Â∞Ñ
            if (categoryLower.match(/(tech|ÊäÄÊúØ|ÂºÄÂèë|‰ª£Á†Å|programming)/)) {
                return 'ÊäÄÊúØËµÑÊñô';
            }
            
            // Â≠¶‰π†Á±ªÂà´Êò†Â∞Ñ
            if (categoryLower.match(/(learn|Â≠¶‰π†|ÊïôËÇ≤|course|tutorial)/)) {
                return 'Â≠¶‰π†ËµÑÊñô';
            }
            
            // ÊñáÊ°£Á±ªÂà´Êò†Â∞Ñ
            if (categoryLower.match(/(document|ÊñáÊ°£|doc|ËµÑÊñô)/)) {
                if (contentTerms.match(/(ÊäÄÊúØ|ÂºÄÂèë|api|‰ª£Á†Å)/)) {
                    return 'ÊäÄÊúØËµÑÊñô';
                }
                if (contentTerms.match(/(ÂïÜ‰∏ö|‰∏öÂä°|ÁÆ°ÁêÜ)/)) {
                    return 'ÂïÜ‰∏öËµÑÊñô';
                }
                return 'ÊñáÊ°£ËµÑÊñô';
            }
            
            // Â§öÂ™í‰ΩìÁ±ªÂà´Êò†Â∞Ñ
            if (categoryLower.match(/(media|Â§öÂ™í‰Ωì|ËßÜÈ¢ë|Èü≥È¢ë|ÂõæÁâá)/)) {
                return 'Â§öÂ™í‰ΩìÂÜÖÂÆπ';
            }
            
            return categoryName; // Â¶ÇÊûúÊ≤°ÊúâÂåπÈÖçÔºå‰øùÊåÅÂéüÂêç
        }
        
        // üî® ËæÖÂä©ÂáΩÊï∞ÔºöÁîüÊàêÂÜÖÂÆπÂìàÂ∏å
        async function generateContentHash(content) {
            // ÁÆÄÂåñÁöÑÂìàÂ∏åÂáΩÊï∞ÔºàÂü∫‰∫éÂÜÖÂÆπÁöÑÂâç1000Â≠óÁ¨¶Ôºâ
            const normalizedContent = content.trim().substring(0, 1000).replace(/\s+/g, ' ');
            let hash = 0;
            for (let i = 0; i < normalizedContent.length; i++) {
                const char = normalizedContent.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // ËΩ¨‰∏∫32‰ΩçÊï¥Êï∞
            }
            return hash.toString();
        }
        
        // üî® ËæÖÂä©ÂáΩÊï∞ÔºöËÆ°ÁÆóÂ≠óÁ¨¶‰∏≤Áõ∏‰ººÂ∫¶
        function calculateStringSimilarity(str1, str2) {
            if (!str1 || !str2) return 0;
            
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;
            
            if (longer.length === 0) return 1.0;
            
            const distance = levenshteinDistance(longer, shorter);
            return (longer.length - distance) / longer.length;
        }
        
        // üî® ËæÖÂä©ÂáΩÊï∞ÔºöËÆ°ÁÆóÂÜÖÂÆπÁõ∏‰ººÂ∫¶
        function calculateContentSimilarity(content1, content2) {
            if (!content1 || !content2) return 0;
            
            // Âü∫‰∫éÂÖ≥ÈîÆËØçÈáçÂè†Â∫¶ËÆ°ÁÆóÁõ∏‰ººÊÄß
            const words1 = content1.toLowerCase().split(/\s+/).filter(w => w.length > 3);
            const words2 = content2.toLowerCase().split(/\s+/).filter(w => w.length > 3);
            
            if (words1.length === 0 || words2.length === 0) return 0;
            
            const uniqueWords1 = new Set(words1);
            const uniqueWords2 = new Set(words2);
            
            const intersection = new Set([...uniqueWords1].filter(w => uniqueWords2.has(w)));
            const union = new Set([...uniqueWords1, ...uniqueWords2]);
            
            return union.size > 0 ? intersection.size / union.size : 0;
        }
        
        // üî® ËæÖÂä©ÂáΩÊï∞ÔºöÁºñËæëË∑ùÁ¶ªÁÆóÊ≥ï
        function levenshteinDistance(str1, str2) {
            const matrix = [];
            
            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }
            
            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }
            
            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            
            return matrix[str2.length][str1.length];
        }
        
        // üíæ Êô∫ËÉΩÂ≠òÂÇ®ÁÆ°ÁêÜÂô®
        const StorageManager = {
            // Â≠òÂÇ®Á≠ñÁï•ÈÖçÁΩÆ
            config: {
                localStorageLimit: 100 * 1024 * 1024, // Â¢ûÂä†Âà∞100MBÈôêÂà∂
                maxFileSize: 10 * 1024 * 1024, // 10MB‰ª•‰∏ãÂ≠òÂÇ®ÂÆåÊï¥ÂÜÖÂÆπ
                textContentLimit: 500 * 1024, // Â¢ûÂä†Âà∞500KBÊñáÊú¨ÂÜÖÂÆπÈôêÂà∂
                cleanupThreshold: 0.6, // 60%Êó∂ÂºÄÂßãÊ∏ÖÁêÜ
                maxFiles: 500, // ÊúÄÂ§öÂ≠òÂÇ®500‰∏™Êñá‰ª∂
                compressionEnabled: true, // ÂêØÁî®ÂéãÁº©
                cloudStorageEnabled: false // Êú™Êù•Êâ©Â±ï
            },
            
            // Ê£ÄÊü•Â≠òÂÇ®Á©∫Èó¥
            checkStorage() {
                const usedSpace = new Blob(Object.values(localStorage)).size;
                const remainingSpace = this.config.localStorageLimit - usedSpace;
                
                console.log('üíæ Â≠òÂÇ®‰ΩøÁî®ÊÉÖÂÜµ:', {
                    used: (usedSpace / 1024 / 1024).toFixed(2) + 'MB',
                    remaining: (remainingSpace / 1024 / 1024).toFixed(2) + 'MB',
                    utilization: Math.round((usedSpace / this.config.localStorageLimit) * 100) + '%'
                });
                
                return { usedSpace, remainingSpace };
            },
            
            // Êô∫ËÉΩÂ≠òÂÇ®Á≠ñÁï•
            async saveFile(file) {
                console.log('üíæ ÂºÄÂßãÊô∫ËÉΩÊñá‰ª∂Â≠òÂÇ®:', file.name);
                
                try {
                    const { remainingSpace } = this.checkStorage();
                    
                    // Âº∫Âà∂Ê∏ÖÁêÜÂ≠òÂÇ®Á©∫Èó¥
                    console.log('üßπ ÊâßË°åÂº∫Âà∂Â≠òÂÇ®Ê∏ÖÁêÜ...');
                    await this.forceStorageCleanup();
                    
                    // ÈáçÊñ∞Ê£ÄÊü•Á©∫Èó¥
                    const newCheck = this.checkStorage();
                    console.log('üîç Ê∏ÖÁêÜÂêéÂ≠òÂÇ®Áä∂ÊÄÅ:', {
                        used: (newCheck.usedSpace / 1024 / 1024).toFixed(2) + 'MB',
                        remaining: (newCheck.remainingSpace / 1024 / 1024).toFixed(2) + 'MB'
                    });
                    
                    // ÂàõÂª∫‰ºòÂåñÁöÑÊñá‰ª∂Êï∞ÊçÆÁªìÊûÑ
                    const fileData = await this.createOptimizedFileData(file);
                    
                    // ÁîüÊàêÂ≠òÂÇ®ÈîÆ
                    const storageKey = `file_${file.name}_${Date.now()}`;
                    
                    // Â∞ùËØïÂ≠òÂÇ®ÔºåÂ¶ÇÊûúÂ§±Ë¥•ÂàôÂÖàÊ∏ÖÁêÜÂÜçÈáçËØï
                    try {
                        localStorage.setItem(storageKey, JSON.stringify(fileData));
                        console.log('‚úÖ Êñá‰ª∂Â≠òÂÇ®ÊàêÂäü:', storageKey);
                        return storageKey;
                    } catch (quotaError) {
                        console.log('‚ö†Ô∏è Â≠òÂÇ®ÈÖçÈ¢ù‰∏çË∂≥ÔºåÊâßË°åËá™Âä®Ê∏ÖÁêÜ...');
                        
                        // ÊâßË°åÊô∫ËÉΩÊ∏ÖÁêÜ
                        await this.smartCleanup();
                        
                        // Ê∏ÖÁêÜÂêéÈáçËØïÂ≠òÂÇ®
                        try {
                            localStorage.setItem(storageKey, JSON.stringify(fileData));
                            console.log('‚úÖ Ê∏ÖÁêÜÂêéÂ≠òÂÇ®ÊàêÂäü:', storageKey);
                            return storageKey;
                        } catch (retryError) {
                            console.log('‚ö†Ô∏è Ê∏ÖÁêÜÂêé‰ªçÊó†Ê≥ïÂ≠òÂÇ®ÔºåÂéãÁº©ÂÜÖÂÆπ...');
                            
                            // ÂéãÁº©ÂÜÖÂÆπÔºöÂè™‰øùÁïôÂâç50000Â≠óÁ¨¶
                            if (fileData.textContent.length > 50000) {
                                fileData.textContent = fileData.textContent.substring(0, 50000) + '\n\n... (ÂÜÖÂÆπÂ∑≤Êà™Êñ≠ÔºåËäÇÁúÅÂ≠òÂÇ®Á©∫Èó¥)';
                                fileData.storageMode = 'compressed';
                            }
                            
                            try {
                                localStorage.setItem(storageKey, JSON.stringify(fileData));
                                console.log('‚úÖ ÂéãÁº©ÂêéÂ≠òÂÇ®ÊàêÂäü:', storageKey);
                                return storageKey;
                            } catch (finalError) {
                                console.log('‚ö†Ô∏è ÊúÄÁªà‰ΩøÁî®ÊûÅÁÆÄÊ®°Âºè...');
                                const minimalData = this.createMinimalFileData(file);
                                localStorage.setItem(storageKey, JSON.stringify(minimalData));
                                console.log('‚úÖ ÊûÅÁÆÄÊ®°ÂºèÂ≠òÂÇ®ÊàêÂäü:', storageKey);
                                return storageKey;
                            }
                        }
                    }
                    
                } catch (error) {
                    console.error('‚ùå Êñá‰ª∂Â≠òÂÇ®Â§±Ë¥•:', error);
                    // ÊòæÁ§∫Áî®Êà∑ÂèãÂ•ΩÁöÑÈîôËØØ‰ø°ÊÅØ
                    this.showStorageUpgradePrompt();
                    throw error;
                }
            },
            
            // ÂàõÂª∫‰ºòÂåñÁöÑÊñá‰ª∂Êï∞ÊçÆ
            async createOptimizedFileData(file) {
                const fileData = {
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    lastModified: file.lastModified,
                    savedAt: new Date().toISOString(),
                    hasLocalContent: false,
                    textContent: null,
                    storageMode: 'optimized'
                };
                
                // Âè™ÂØπÂ∞èÊñá‰ª∂Â≠òÂÇ®ÂÆåÊï¥ÂÜÖÂÆπ
                if (file.size <= this.config.maxFileSize && !file.type.includes('pdf')) {
                    const arrayBuffer = await file.arrayBuffer();
                    fileData.data = Array.from(new Uint8Array(arrayBuffer));
                    fileData.hasLocalContent = true;
                    console.log('üìÑ Â∞èÊñá‰ª∂ÔºåÂ≠òÂÇ®ÂÆåÊï¥ÂÜÖÂÆπ');
                } else {
                    console.log('üìÑ Â§ßÊñá‰ª∂Ôºå‰ªÖÂ≠òÂÇ®ÂÖÉÊï∞ÊçÆÂíåÊñáÊú¨');
                }
                
                // ÊèêÂèñÂπ∂ÈôêÂà∂ÊñáÊú¨ÂÜÖÂÆπ
                try {
                    let text = await extractTextFromFile(file);
                    if (text.length > this.config.textContentLimit) {
                        text = text.substring(0, this.config.textContentLimit) + '\n\nüìã ÂÜÖÂÆπÂ∑≤‰ºòÂåñÊà™Êñ≠ÔºåÂÆåÊï¥ÂÜÖÂÆπËØ∑‰ΩøÁî®Êú¨Âú∞Â∑•ÂÖ∑ÊâìÂºÄÊàñÂçáÁ∫ßÂ≠òÂÇ®Á©∫Èó¥';
                    }
                    fileData.textContent = text;
                } catch (error) {
                    fileData.textContent = `üìÑ ${file.name}\nÂ≠òÂÇ®Á©∫Èó¥‰ºòÂåñÊ®°Âºè\nÂÆåÊï¥ÂÜÖÂÆπÂàÜÊûêËØ∑ÂçáÁ∫ßÂ≠òÂÇ®ÊñπÊ°à`;
                }
                
                return fileData;
            },
            
            // ÂàõÂª∫ÊûÅÁÆÄÊñá‰ª∂Êï∞ÊçÆÔºàÁ¥ßÊÄ•ÊÉÖÂÜµÔºâ
            createMinimalFileData(file) {
                return {
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    savedAt: new Date().toISOString(),
                    storageMode: 'minimal',
                    textContent: `üìÑ ${file.name}\n\n‚ö†Ô∏è Â≠òÂÇ®Á©∫Èó¥Â∑≤Êª°\nËøôÊòØÊûÅÁÆÄÂ≠òÂÇ®Ê®°ÂºèÔºå‰ªÖ‰øùÂ≠òÂü∫Êú¨‰ø°ÊÅØ„ÄÇ\n\nüí° Âª∫ËÆÆÔºö\n‚Ä¢ Ê∏ÖÁêÜÊóßÊñá‰ª∂ÈáäÊîæÁ©∫Èó¥\n‚Ä¢ ÂçáÁ∫ßÂà∞‰∫ëÂ≠òÂÇ®ÊñπÊ°à\n‚Ä¢ ‰ΩøÁî®Êú¨Âú∞Â∑•ÂÖ∑ÊâìÂºÄÂÆåÊï¥Êñá‰ª∂`,
                    hasLocalContent: false
                };
            },
            
            // Êô∫ËÉΩÊ∏ÖÁêÜÁ≠ñÁï•
            async smartCleanup() {
                console.log('üßπ ÂºÄÂßãÊô∫ËÉΩÊ∏ÖÁêÜ...');
                
                const keys = Object.keys(localStorage);
                const fileKeys = keys.filter(key => key.startsWith('file_'));
                
                if (fileKeys.length === 0) {
                    console.log('üßπ Ê≤°ÊúâÊñá‰ª∂ÈúÄË¶ÅÊ∏ÖÁêÜ');
                    return;
                }
                
                console.log(`üßπ ÂèëÁé∞ ${fileKeys.length} ‰∏™Êñá‰ª∂ÔºåÂºÄÂßãÊ∏ÖÁêÜ...`);
                
                // ÊåâÊó∂Èó¥ÊéíÂ∫èÔºå‰ºòÂÖàÂà†Èô§ÊúÄÊóßÁöÑ
                const sortedKeys = fileKeys.sort((a, b) => {
                    const timeA = parseInt(a.split('_').pop()) || 0;
                    const timeB = parseInt(b.split('_').pop()) || 0;
                    return timeA - timeB;
                });
                
                // Êõ¥ÊøÄËøõÁöÑÊ∏ÖÁêÜÁ≠ñÁï•ÔºöÂà†Èô§ÊúÄÊóßÁöÑ50%Êñá‰ª∂
                const deleteCount = Math.max(1, Math.floor(sortedKeys.length * 0.5));
                
                for (let i = 0; i < deleteCount; i++) {
                    const key = sortedKeys[i];
                    try {
                        localStorage.removeItem(key);
                        console.log('üóëÔ∏è Ê∏ÖÁêÜÊóßÊñá‰ª∂:', key);
                    } catch (error) {
                        console.error('‚ùå Ê∏ÖÁêÜÊñá‰ª∂Â§±Ë¥•:', key, error);
                    }
                }
                
                // È¢ùÂ§ñÊ∏ÖÁêÜÔºöÂà†Èô§ÊâÄÊúâÊûÅÁÆÄÊ®°ÂºèÁöÑÊñá‰ª∂
                const remainingKeys = Object.keys(localStorage).filter(key => key.startsWith('file_'));
                let minimalCleared = 0;
                
                for (const key of remainingKeys) {
                    try {
                        const data = JSON.parse(localStorage.getItem(key) || '{}');
                        if (data.storageMode === 'minimal') {
                            localStorage.removeItem(key);
                            minimalCleared++;
                            console.log('üóëÔ∏è Ê∏ÖÁêÜÊûÅÁÆÄÊ®°ÂºèÊñá‰ª∂:', key);
                        }
                    } catch (error) {
                        // ÊçüÂùèÁöÑÊï∞ÊçÆ‰πüÂà†Èô§
                        localStorage.removeItem(key);
                        console.log('üóëÔ∏è Ê∏ÖÁêÜÊçüÂùèÊñá‰ª∂:', key);
                    }
                }
                
                console.log(`‚úÖ Êô∫ËÉΩÊ∏ÖÁêÜÂÆåÊàêÔºåÈáäÊîæ‰∫Ü ${deleteCount + minimalCleared} ‰∏™Êñá‰ª∂ÁöÑÁ©∫Èó¥`);
            },
            
            // ‰∏ªÂä®Â≠òÂÇ®Áª¥Êä§
            async proactiveMaintenance() {
                const keys = Object.keys(localStorage);
                const fileKeys = keys.filter(key => key.startsWith('file_'));
                
                // Â¶ÇÊûúÊñá‰ª∂Êï∞ÈáèË∂ÖËøá10‰∏™ÔºåËá™Âä®Ê∏ÖÁêÜ
                if (fileKeys.length > 10) {
                    console.log(`üîß Ê£ÄÊµãÂà∞ ${fileKeys.length} ‰∏™Â≠òÂÇ®Êñá‰ª∂ÔºåÊâßË°å‰∏ªÂä®Áª¥Êä§`);
                    await this.smartCleanup();
                }
                
                // Ê£ÄÊü•Â≠òÂÇ®‰ΩøÁî®ÊÉÖÂÜµ
                const storageSize = JSON.stringify(localStorage).length;
                const maxSize = 5 * 1024 * 1024; // 5MB‰º∞ËÆ°ÈôêÂà∂
                
                if (storageSize > maxSize * 0.8) {
                    console.log('üîß Â≠òÂÇ®‰ΩøÁî®ÁéáËøáÈ´òÔºåÊâßË°åÈ¢ÑÈò≤ÊÄßÊ∏ÖÁêÜ');
                    await this.smartCleanup();
                }
            },
            
            // ÊòæÁ§∫Â≠òÂÇ®ÂçáÁ∫ßÊèêÁ§∫
            showStorageUpgradePrompt() {
                const message = `
üîÑ Â≠òÂÇ®Á©∫Èó¥‰ºòÂåñÂª∫ËÆÆ

ÂΩìÂâç‰ΩøÁî®Êú¨Âú∞Â≠òÂÇ®Â∑≤Êé•Ëøë‰∏äÈôê„ÄÇÂª∫ËÆÆÔºö

üí° Á´ãÂç≥ÂèØÂÅöÔºö
‚Ä¢ Âà†Èô§‰∏çÈúÄË¶ÅÁöÑÊóßÊñá‰ª∂
‚Ä¢ Á≥ªÁªü‰ºöËá™Âä®Ê∏ÖÁêÜÊúÄÊóßÁöÑÊñá‰ª∂

üöÄ ÂçáÁ∫ßÊñπÊ°àÔºö
‚Ä¢ ‰∫ëÂ≠òÂÇ®Á©∫Èó¥ÔºöÊó†ÈôêÈáèÊñá‰ª∂Â≠òÂÇ®
‚Ä¢ Ë∑®ËÆæÂ§áÂêåÊ≠•ÔºöÊâãÊú∫„ÄÅÁîµËÑëÊó†ÁºùÂàáÊç¢  
‚Ä¢ È´òÁ∫ßAIÂàÜÊûêÔºöÊõ¥Ê∑±Â∫¶ÁöÑÂÜÖÂÆπÊ¥ûÂØü
‚Ä¢ Êï∞ÊçÆÂÆâÂÖ®Ôºö‰∏ì‰∏öÁ∫ßÂä†ÂØÜ‰øùÊä§

ÊòØÂê¶ÈúÄË¶Å‰∫ÜËß£‰∫ëÂ≠òÂÇ®ÂçáÁ∫ßÊñπÊ°àÔºü
                `;
                
                console.log(message);
                this.showStorageStatusModal();
            },
            
            // ÊòæÁ§∫Â≠òÂÇ®Áä∂ÊÄÅÊ®°ÊÄÅÊ°Ü
            showStorageStatusModal() {
                const { usedSpace, remainingSpace } = this.checkStorage();
                const utilizationPercent = Math.round((usedSpace / this.config.localStorageLimit) * 100);
                
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                    background: rgba(0,0,0,0.7); z-index: 10000; display: flex; 
                    align-items: center; justify-content: center;
                `;
                
                modal.innerHTML = `
                    <div style="
                        background: white; border-radius: 20px; padding: 30px; 
                        width: 500px; max-width: 90vw; box-shadow: 0 25px 80px rgba(0,0,0,0.3);
                    ">
                        <div style="text-align: center; margin-bottom: 24px;">
                            <div style="font-size: 48px; margin-bottom: 12px;">üíæ</div>
                            <h2 style="margin: 0; color: #1f2937;">Â≠òÂÇ®Á©∫Èó¥ÁÆ°ÁêÜ</h2>
                        </div>
                        
                        <div style="background: #f8fafc; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                                <span style="font-weight: 600; color: #374151;">Êú¨Âú∞Â≠òÂÇ®‰ΩøÁî®ÊÉÖÂÜµ</span>
                                <span style="color: ${utilizationPercent > 80 ? '#ef4444' : '#10b981'}; font-weight: 600;">
                                    ${utilizationPercent}%
                                </span>
                            </div>
                            <div style="
                                background: #e5e7eb; height: 12px; border-radius: 6px; overflow: hidden;
                            ">
                                <div style="
                                    background: ${utilizationPercent > 80 ? '#ef4444' : '#10b981'}; 
                                    height: 100%; width: ${utilizationPercent}%; 
                                    border-radius: 6px; transition: width 0.3s ease;
                                "></div>
                            </div>
                            <div style="
                                display: flex; justify-content: space-between; 
                                margin-top: 8px; font-size: 14px; color: #6b7280;
                            ">
                                <span>Â∑≤Áî®: ${(usedSpace / 1024 / 1024).toFixed(2)}MB</span>
                                <span>Ââ©‰Ωô: ${(remainingSpace / 1024 / 1024).toFixed(2)}MB</span>
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 24px;">
                            <h3 style="margin: 0 0 12px 0; color: #1f2937;">üí° ‰ºòÂåñÂª∫ËÆÆ</h3>
                            <div style="color: #4b5563; line-height: 1.6;">
                                ${utilizationPercent > 90 ? 
                                    `‚ö†Ô∏è Â≠òÂÇ®Á©∫Èó¥‰∏•Èáç‰∏çË∂≥ÔºåÁ≥ªÁªüÂ∑≤ÂêØÁî®ÊûÅÁÆÄÊ®°Âºè<br>
                                     ‚Ä¢ Ëá™Âä®Ê∏ÖÁêÜÊúÄÊóßÁöÑÊñá‰ª∂<br>
                                     ‚Ä¢ ‰ªÖ‰øùÂ≠òÊñá‰ª∂Âü∫Êú¨‰ø°ÊÅØ<br>
                                     ‚Ä¢ Âª∫ËÆÆÁ´ãÂç≥ÂçáÁ∫ßÂ≠òÂÇ®ÊñπÊ°à` :
                                utilizationPercent > 70 ?
                                    `üîÑ Â≠òÂÇ®Á©∫Èó¥Á¥ßÂº†ÔºåÂ∑≤ÂêØÁî®‰ºòÂåñÊ®°Âºè<br>
                                     ‚Ä¢ ÈôêÂà∂ÊñáÊú¨ÂÜÖÂÆπÈïøÂ∫¶<br>
                                     ‚Ä¢ Â§ßÊñá‰ª∂‰∏çÂ≠òÂÇ®ÂÆåÊï¥ÂÜÖÂÆπ<br>
                                     ‚Ä¢ Âª∫ËÆÆËÄÉËôëÂçáÁ∫ßÂ≠òÂÇ®` :
                                    `‚úÖ Â≠òÂÇ®Á©∫Èó¥ÂÖÖË∂≥<br>
                                     ‚Ä¢ Á≥ªÁªüËøêË°åÊ≠£Â∏∏<br>
                                     ‚Ä¢ Êñá‰ª∂ÂÆåÊï¥Â≠òÂÇ®<br>
                                     ‚Ä¢ ÁªßÁª≠‰∫´ÂèóÊô∫ËÉΩÂ∑•‰ΩúÊµÅ`
                                }
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 24px; padding: 16px; background: #dbeafe; border-radius: 8px;">
                            <h4 style="margin: 0 0 8px 0; color: #1e40af;">üöÄ ‰∫ëÂ≠òÂÇ®ÂçáÁ∫ßÊñπÊ°à</h4>
                            <div style="color: #1e40af; font-size: 14px; line-height: 1.5;">
                                ‚Ä¢ <strong>Êó†ÈôêÂ≠òÂÇ®Á©∫Èó¥</strong>ÔºöÊîØÊåÅÂ§ßÈáèÊñá‰ª∂‰∏ä‰º†<br>
                                ‚Ä¢ <strong>Ë∑®ËÆæÂ§áÂêåÊ≠•</strong>ÔºöÊâãÊú∫„ÄÅÂπ≥Êùø„ÄÅÁîµËÑëÊó†ÁºùËÆøÈóÆ<br>
                                ‚Ä¢ <strong>Êï∞ÊçÆÂÆâÂÖ®‰øùÊä§</strong>Ôºö‰ºÅ‰∏öÁ∫ßÂä†ÂØÜÂíåÂ§á‰ªΩ<br>
                                ‚Ä¢ <strong>È´òÁ∫ßAIÂàÜÊûê</strong>ÔºöÊõ¥Ê∑±Â∫¶ÁöÑÂÜÖÂÆπÊ¥ûÂØü
                            </div>
                        </div>
                        
                        <div style="display: flex; gap: 12px; justify-content: center; margin-bottom: 16px;">
                            <button onclick="StorageManager.performQuickCleanup(); this.parentElement.parentElement.parentElement.remove();" style="
                                background: #10b981; border: none; padding: 12px 24px; 
                                border-radius: 8px; cursor: pointer; color: white; font-weight: 600;
                            ">üßπ Á´ãÂç≥Ê∏ÖÁêÜ</button>
                            <button onclick="StorageManager.clearOldAnalysisData(); this.parentElement.parentElement.parentElement.remove();" style="
                                background: #f59e0b; border: none; padding: 12px 24px; 
                                border-radius: 8px; cursor: pointer; color: white; font-weight: 600;
                            ">üóëÔ∏è Ê∏ÖÁêÜÊóßÊï∞ÊçÆ</button>
                        </div>
                        
                        <div style="display: flex; gap: 12px; justify-content: flex-end;">
                            <button onclick="this.parentElement.parentElement.parentElement.remove()" style="
                                background: #f3f4f6; border: none; padding: 8px 16px; 
                                border-radius: 6px; cursor: pointer; color: #374151; font-size: 14px;
                            ">Á®çÂêéÊèêÈÜí</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // ÁÇπÂáªËÉåÊôØÂÖ≥Èó≠
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            },
            
            // Âø´ÈÄüÊ∏ÖÁêÜÂáΩÊï∞
            performQuickCleanup() {
                console.log('üßπ ÂºÄÂßãÂø´ÈÄüÂ≠òÂÇ®Ê∏ÖÁêÜ...');
                try {
                    // Ê∏ÖÁêÜ‰∏¥Êó∂Á´†ËäÇÊï∞ÊçÆ
                    let sectionsCleared = 0;
                    Object.keys(window).filter(key => key.startsWith('sections_')).forEach(key => {
                        delete window[key];
                        sectionsCleared++;
                    });
                    
                    // Ê∏ÖÁêÜÁü•ËØÜÊ†ë‰∏≠ÁöÑÂ§ßÊñá‰ª∂Êï∞ÊçÆÔºå‰øùÁïôÊñáÊú¨ÊëòË¶Å
                    const knowledgeTreeData = JSON.parse(localStorage.getItem('knowledgeTreeData') || '{}');
                    let fileDataCleared = 0;
                    Object.keys(knowledgeTreeData).forEach(key => {
                        const item = knowledgeTreeData[key];
                        if (item.data && item.data.length > 100000) { // Ê∏ÖÁêÜÂ§ß‰∫é100KBÁöÑÊï∞ÊçÆ
                            item.data = null;
                            fileDataCleared++;
                        }
                    });
                    
                    if (fileDataCleared > 0) {
                        localStorage.setItem('knowledgeTreeData', JSON.stringify(knowledgeTreeData));
                    }
                    
                    showNotification(`üßπ Âø´ÈÄüÊ∏ÖÁêÜÂÆåÊàêÔºÅÊ∏ÖÁêÜ‰∫Ü${sectionsCleared}‰∏™‰∏¥Êó∂Êï∞ÊçÆÂíå${fileDataCleared}‰∏™Â§ßÊñá‰ª∂`);
                    console.log('‚úÖ Âø´ÈÄüÊ∏ÖÁêÜÂÆåÊàê');
                    
                } catch (error) {
                    console.error('‚ùå Âø´ÈÄüÊ∏ÖÁêÜÂ§±Ë¥•:', error);
                    showNotification('‚ùå Ê∏ÖÁêÜÂ§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï');
                }
            },
            
            // Âº∫Âà∂Ê∏ÖÁêÜÂ≠òÂÇ®Á©∫Èó¥
            async forceStorageCleanup() {
                console.log('üßπ ÂºÄÂßãÂº∫Âà∂Â≠òÂÇ®Ê∏ÖÁêÜ...');
                try {
                    // 1. Á´ãÂç≥Ê∏ÖÁêÜÊâÄÊúâ‰∏¥Êó∂Êï∞ÊçÆ
                    Object.keys(window).filter(key => key.startsWith('sections_')).forEach(key => {
                        delete window[key];
                    });
                    console.log('‚úÖ Ê∏ÖÁêÜ‰∫ÜÊâÄÊúâ‰∏¥Êó∂Á´†ËäÇÊï∞ÊçÆ');
                    
                    // 2. Â§ßÂπÖÁÆÄÂåñGraphRAGÂàÜÊûêÊï∞ÊçÆÂ∫ìÔºåÂè™‰øùÁïôÊúÄÊñ∞5‰∏™
                    const analysisDB = JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}');
                    const keys = Object.keys(analysisDB);
                    if (keys.length > 5) {
                        const sortedKeys = keys.sort((a, b) => {
                            const timestampA = a.split('_').pop() || '0';
                            const timestampB = b.split('_').pop() || '0';
                            return parseInt(timestampB) - parseInt(timestampA);
                        });
                        const keysToKeep = sortedKeys.slice(0, 5);
                        const cleanedDB = {};
                        keysToKeep.forEach(key => {
                            // Âè™‰øùÁïôÊ†∏ÂøÉ‰ø°ÊÅØÔºåÂéªÊéâÂ§ßÁöÑÂÜÖÂÆπ
                            const item = analysisDB[key];
                            cleanedDB[key] = {
                                fileName: item.fileName,
                                extractedContent: item.extractedContent || '', // ‰øùÁïôÂÆåÊï¥ÂÜÖÂÆπ
                                entities: item.entities || [],
                                timestamp: item.timestamp
                            };
                        });
                        localStorage.setItem('graphRAGAnalysisDB', JSON.stringify(cleanedDB));
                        console.log('‚úÖ Ê∏ÖÁêÜ‰∫Ü', keys.length - 5, '‰∏™ÂàÜÊûêÊï∞ÊçÆÔºåÂéãÁº©‰∫ÜÂÜÖÂÆπ');
                    }
                    
                    // 3. Ê∏ÖÁêÜÁü•ËØÜÊ†ë‰∏≠ÁöÑÊâÄÊúâÊñá‰ª∂Êï∞ÊçÆÔºåÂè™‰øùÁïôÂü∫Êú¨‰ø°ÊÅØ
                    const knowledgeTreeData = JSON.parse(localStorage.getItem('knowledgeTreeData') || '{}');
                    let cleaned = 0;
                    Object.keys(knowledgeTreeData).forEach(key => {
                        const item = knowledgeTreeData[key];
                        if (item.data) {
                            item.data = null; // ÂÆåÂÖ®Ê∏ÖÁêÜÊñá‰ª∂Êï∞ÊçÆ
                            cleaned++;
                        }
                        if (item.textContent && item.textContent.length > 50000) {
                            // Âè™Âú®ÂÜÖÂÆπË∂ÖËøá50KBÊó∂ÊâçÊà™Êñ≠
                            item.textContent = item.textContent.substring(0, 50000) + '\n\n[‰∏∫ËäÇÁúÅÂ≠òÂÇ®Á©∫Èó¥ÔºåÂÜÖÂÆπÂ∑≤Êà™Êñ≠]';
                        }
                    });
                    if (cleaned > 0) {
                        localStorage.setItem('knowledgeTreeData', JSON.stringify(knowledgeTreeData));
                        console.log('‚úÖ Ê∏ÖÁêÜ‰∫Ü', cleaned, '‰∏™Êñá‰ª∂ÁöÑÂ≠òÂÇ®Êï∞ÊçÆ');
                    }
                    
                    // 4. Ê∏ÖÁêÜÂÖ∂‰ªñÂèØËÉΩÁöÑÂ§ßÊï∞ÊçÆ
                    ['fileProcessingResults', 'uploadHistory', 'analysisCache'].forEach(key => {
                        if (localStorage.getItem(key)) {
                            localStorage.removeItem(key);
                            console.log('‚úÖ Ê∏ÖÁêÜ‰∫Ü', key);
                        }
                    });
                    
                    console.log('‚úÖ Âº∫Âà∂Ê∏ÖÁêÜÂÆåÊàê');
                    return true;
                    
                } catch (error) {
                    console.error('‚ùå Âº∫Âà∂Ê∏ÖÁêÜÂ§±Ë¥•:', error);
                    return false;
                }
            },
            
            // Ê∏ÖÁêÜÊóßÂàÜÊûêÊï∞ÊçÆ
            clearOldAnalysisData() {
                console.log('üóëÔ∏è ÂºÄÂßãÊ∏ÖÁêÜÊóßÂàÜÊûêÊï∞ÊçÆ...');
                try {
                    const analysisDB = JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}');
                    const keys = Object.keys(analysisDB);
                    
                    if (keys.length > 10) {
                        // Âè™‰øùÁïôÊúÄÊñ∞ÁöÑ10‰∏™ÂàÜÊûêÁªìÊûú
                        const sortedKeys = keys.sort((a, b) => {
                            const timestampA = a.split('_').pop() || '0';
                            const timestampB = b.split('_').pop() || '0';
                            return parseInt(timestampB) - parseInt(timestampA);
                        });
                        
                        const keysToKeep = sortedKeys.slice(0, 10);
                        const cleanedDB = {};
                        keysToKeep.forEach(key => {
                            cleanedDB[key] = analysisDB[key];
                        });
                        
                        localStorage.setItem('graphRAGAnalysisDB', JSON.stringify(cleanedDB));
                        
                        const deletedCount = keys.length - keysToKeep.length;
                        showNotification(`üóëÔ∏è Ê∏ÖÁêÜÂÆåÊàêÔºÅÂà†Èô§‰∫Ü${deletedCount}‰∏™ÊóßÂàÜÊûêÊï∞ÊçÆÔºåÈáäÊîæ‰∫ÜÂ≠òÂÇ®Á©∫Èó¥`);
                        console.log('‚úÖ Ê∏ÖÁêÜ‰∫Ü', deletedCount, '‰∏™ÊóßÂàÜÊûêÊï∞ÊçÆ');
                    } else {
                        showNotification('üí° ÂΩìÂâçÂàÜÊûêÊï∞ÊçÆ‰∏çÂ§öÔºåÊó†ÈúÄÊ∏ÖÁêÜ');
                    }
                    
                } catch (error) {
                    console.error('‚ùå Ê∏ÖÁêÜÂàÜÊûêÊï∞ÊçÆÂ§±Ë¥•:', error);
                    showNotification('‚ùå Ê∏ÖÁêÜÂ§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï');
                }
            }
        };
        
        // üíæ ‰øùÂ≠òÊñá‰ª∂ÂÖÉÊï∞ÊçÆÔºà‰ΩøÁî®Êô∫ËÉΩÂ≠òÂÇ®ÁÆ°ÁêÜÂô®Ôºâ
        async function saveFileLocally(file) {
            return await StorageManager.saveFile(file);
        }
        
        // üßπ È°µÈù¢Âä†ËΩΩÊó∂ÊâßË°å‰∏ÄÊ¨°Â≠òÂÇ®Ê∏ÖÁêÜ
        window.addEventListener('DOMContentLoaded', function() {
            setTimeout(async () => {
                try {
                    console.log('üßπ ÊâßË°åÂêØÂä®Êó∂Â≠òÂÇ®Ê£ÄÊü•ÂíåÊ∏ÖÁêÜ...');
                    
                    // ÊâßË°å‰∏ªÂä®Â≠òÂÇ®Áª¥Êä§
                    await StorageManager.proactiveMaintenance();
                    
                    const { usedSpace } = StorageManager.checkStorage();
                    
                    // Â¶ÇÊûú‰ΩøÁî®Ë∂ÖËøá50MBÔºåÁ´ãÂç≥Ê∏ÖÁêÜ
                    if (usedSpace > 50 * 1024 * 1024) {
                        console.log('‚ö†Ô∏è Â≠òÂÇ®‰ΩøÁî®ÈáèËøáÂ§ßÔºåÊâßË°åËá™Âä®Ê∏ÖÁêÜ');
                        await StorageManager.forceStorageCleanup();
                        showNotification('üßπ Â∑≤Ëá™Âä®Ê∏ÖÁêÜÂ≠òÂÇ®Á©∫Èó¥ÔºåÂèØ‰ª•Ê≠£Â∏∏‰ΩøÁî®‰∫Ü');
                    } else {
                        console.log('‚úÖ Â≠òÂÇ®Á©∫Èó¥ÂÅ•Â∫∑ÔºåÂΩìÂâç‰ΩøÁî®:', (usedSpace / (1024 * 1024)).toFixed(2) + 'MB');
                    }
                } catch (error) {
                    console.error('‚ùå ÂêØÂä®Ê∏ÖÁêÜÂ§±Ë¥•:', error);
                }
            }, 2000);
        });
        
        // ÂàõÂª∫Â§áÁî®ÊñáÊ°£ÁªìÊûÑ
        function createFallbackStructure(fileName, originalContent = '') {
            console.log('üìã ÂàõÂª∫Â§áÁî®ÊñáÊ°£ÁªìÊûÑ:', fileName);
            console.log('üìã ÂéüÂßãÂÜÖÂÆπÈïøÂ∫¶:', originalContent.length);
            
            const displayContent = originalContent || 'ÊñáÊ°£ÂÜÖÂÆπÂä†ËΩΩ‰∏≠ÊàñÂÜÖÂÆπ‰∏∫Á©∫„ÄÇËØ∑Â∞ùËØïÈáçÊñ∞‰∏ä‰º†Êñá‰ª∂ÊàñÊ£ÄÊü•Êñá‰ª∂ÂÜÖÂÆπ„ÄÇ';
            const sections = [{
                id: 'section_0',
                title: 'üìÑ ÊñáÊ°£ÂÜÖÂÆπ',
                preview: displayContent.length > 60 ? displayContent.substring(0, 60) + '...' : displayContent,
                content: displayContent,
                wordCount: displayContent.split(/\s+/).length
            }];
            
            // Â≠òÂÇ®Â§áÁî®Á´†ËäÇÊï∞ÊçÆ
            window[`sections_${fileName.replace(/[^a-zA-Z0-9]/g, '_')}`] = sections;
            
            return `
                <div style="margin-bottom: 16px;">
                    <div style="
                        background: #fef3c7; color: #92400e; padding: 12px; 
                        border-radius: 8px; font-size: 13px; text-align: center;
                    ">
                        üìÑ 1 section ‚Ä¢ Content loading...
                    </div>
                </div>
                <div onclick="showSectionInModal('section_0', '${fileName}')" style="
                    padding: 12px; margin-bottom: 8px; border-radius: 8px; 
                    background: white; border: 1px solid #e2e8f0; cursor: pointer;
                    transition: all 0.2s ease;
                " onmouseover="this.style.backgroundColor='#f0f9ff'; this.style.borderColor='#3b82f6'" 
                   onmouseout="this.style.backgroundColor='white'; this.style.borderColor='#e2e8f0'">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 6px;">
                        <span style="font-weight: 600; color: #1f2937; font-size: 13px;">üìÑ ÊñáÊ°£ÂÜÖÂÆπ</span>
                        <span style="font-size: 11px; color: #6b7280;">0 words</span>
                    </div>
                    <div style="color: #4b5563; font-size: 12px; line-height: 1.4;">
                        ÁÇπÂáªÊü•ÁúãÂÆåÊï¥ÊñáÊ°£ÂÜÖÂÆπ...
                    </div>
                </div>
            `;
        }

        // üìã ÁîüÊàêÊñáÊ°£ÁªìÊûÑÁõÆÂΩï
        function generateDocumentStructure(content, fileName) {
            console.log('üìã ÁîüÊàêÊñáÊ°£ÁªìÊûÑÁõÆÂΩï:', fileName);
            console.log('üìã ÂÜÖÂÆπÈïøÂ∫¶:', content.length);
            console.log('üìã ÂÜÖÂÆπÁ±ªÂûã:', typeof content);
            console.log('üìã ÂÜÖÂÆπÂâç200Â≠óÁ¨¶:', content.substring(0, 200));
            
            // Âº∫Âà∂Â§ÑÁêÜÁ©∫ÊàñÊó†ÊïàÂÜÖÂÆπ
            if (!content || content.length < 10) {
                console.warn('‚ö†Ô∏è ÂÜÖÂÆπ‰∏∫Á©∫ÊàñÂ§™Áü≠Ôºå‰ΩøÁî®Â§áÁî®ÁªìÊûÑ');
                return createFallbackStructure(fileName, content);
            }
            
            try {
                // Â§öÁßçÊñπÂºèÂàÜÂâ≤ÂÜÖÂÆπ‰ª•Ëé∑ÂæóÊõ¥Â•ΩÁöÑÁªìÊûÑ
                let paragraphs = [];
                
                // Êô∫ËÉΩÂàÜÊÆµÔºö‰ºòÂÖà‰ΩøÁî®ÊúâÊÑè‰πâÁöÑÂàÜÂâ≤ÁÇπ
                paragraphs = [];
                
                // ÊñπÊ≥ï1: ÊåâÂèåÊç¢Ë°åÂàÜÂâ≤ÔºàÊúÄÁêÜÊÉ≥ÁöÑÊÆµËêΩÂàÜÈöîÔºâ
                let tempParagraphs = content.split(/\n\s*\n/).filter(p => p.trim().length > 30);
                console.log('üìã ÊåâÂèåÊç¢Ë°åÂàÜÂâ≤ÊâæÂà∞ÊÆµËêΩÊï∞:', tempParagraphs.length);
                
                if (tempParagraphs.length >= 2 && tempParagraphs.length <= 50) {
                    paragraphs = tempParagraphs;
                    console.log('üìã ‰ΩøÁî®ÂèåÊç¢Ë°åÂàÜÂâ≤ÁªìÊûú');
                } else {
                    // ÊñπÊ≥ï2: ÊåâÂè•Âè∑ÂíåÈóÆÂè∑ÂàÜÂâ≤ÔºàÈÄÇÂêàÈïøÊñáÊú¨Ôºâ
                    tempParagraphs = content.split(/[.„ÄÇÔºÅ!Ôºü?]\s+/).filter(p => p.trim().length > 50);
                    console.log('üìã ÊåâÂè•Âè∑ÂàÜÂâ≤ÊâæÂà∞ÊÆµËêΩÊï∞:', tempParagraphs.length);
                    
                    if (tempParagraphs.length >= 2 && tempParagraphs.length <= 100) {
                        paragraphs = tempParagraphs;
                        console.log('üìã ‰ΩøÁî®Âè•Âè∑ÂàÜÂâ≤ÁªìÊûú');
                    } else {
                        // ÊñπÊ≥ï3: Âõ∫ÂÆöÈïøÂ∫¶ÂàÜÂâ≤ÔºàÊúÄÂêéÁöÑÈÄâÊã©Ôºâ
                        console.log('üìã ‰ΩøÁî®Âõ∫ÂÆöÈïøÂ∫¶ÂàÜÂâ≤');
                        const chunkSize = Math.max(200, Math.min(800, Math.floor(content.length / 10)));
                        paragraphs = [];
                        for (let i = 0; i < content.length; i += chunkSize) {
                            const chunk = content.slice(i, i + chunkSize).trim();
                            if (chunk.length > 50) {
                                paragraphs.push(chunk);
                            }
                        }
                        console.log('üìã Âõ∫ÂÆöÈïøÂ∫¶ÂàÜÂâ≤ÂêéÊÆµËêΩÊï∞:', paragraphs.length);
                    }
                }
                
                // ÊúÄÁªàÊ£ÄÊü•ÔºöÁ°Æ‰øùÂÜÖÂÆπ‰∏ç‰∏∫Á©∫
                if (paragraphs.length === 0) {
                    paragraphs = [content.trim()];
                    console.log('üìã Êó†Ê≥ïÂàÜÊÆµÔºå‰ΩøÁî®ÂÆåÊï¥ÂÜÖÂÆπ');
                }
                
                const finalParagraphs = paragraphs;
                
                // ÁîüÊàêÁ´†ËäÇÁªìÊûÑ
                const sections = finalParagraphs.map((paragraph, index) => {
                    const trimmed = paragraph.trim();
                    const preview = trimmed.substring(0, 60) + (trimmed.length > 60 ? '...' : '');
                    // ÂØπ‰∏≠ÊñáÊñáÊú¨‰ΩøÁî®Â≠óÁ¨¶Êï∞ÔºåÂØπËã±Êñá‰ΩøÁî®ÂçïËØçÊï∞
                    const wordCount = trimmed.length > 100 && /[\u4e00-\u9fff]/.test(trimmed) 
                        ? trimmed.length 
                        : trimmed.split(/\s+/).length;
                    
                    // ÂØπ‰∫éAIÂàÜÊûêÂÜÖÂÆπÔºå‰ΩøÁî®Êõ¥ÂêàÈÄÇÁöÑÊ†áÈ¢ò
                    let title;
                    if (finalParagraphs.length === 1 && content.length < 500) {
                        title = 'üß† AIÂàÜÊûêÊëòË¶Å';
                    } else {
                        title = `Á¨¨ ${index + 1} ÊÆµ`;
                    }
                    
                    const sectionData = {
                        id: `section_${index}`,
                        title: title,
                        preview: preview,
                        content: trimmed,
                        wordCount: wordCount
                    };
                    
                    console.log(`üìãüî• ÁîüÊàêÁ´†ËäÇ ${index}:`, {
                        id: sectionData.id,
                        title: sectionData.title,
                        contentLength: sectionData.content.length,
                        preview: sectionData.preview
                    });
                    
                    return sectionData;
                });
                
                console.log('üìãüî• ÁîüÊàêÁöÑÁ´†ËäÇÊï∞:', sections.length);
                console.log('üìãüî• ÊâÄÊúâÁ´†ËäÇID:', sections.map(s => s.id));
                
                // ÁîüÊàêÁõÆÂΩïHTML
                let structureHtml = `
                    <div style="margin-bottom: 16px;">
                        <div style="
                            background: #e0f2fe; color: #0c4a6e; padding: 12px; 
                            border-radius: 8px; font-size: 13px; text-align: center;
                        ">
                            üìä ${sections.length} sections ‚Ä¢ ${/[\u4e00-\u9fff]/.test(content) ? content.length + ' characters' : content.split(/\s+/).length + ' words'}
                        </div>
                    </div>
                `;
                
                sections.forEach((section, index) => {
                    structureHtml += `
                        <div onclick="console.log('üìãüî• Ê®°ÊÄÅÊ°ÜÁõÆÂΩïÈ°πË¢´ÁÇπÂáª:', '${section.id}', '${fileName}'); event.preventDefault(); event.stopPropagation(); window.showSectionInModal('${section.id}', '${fileName}'); return false;" style="
                            padding: 12px; margin-bottom: 8px; border-radius: 8px; 
                            background: white; border: 1px solid #e2e8f0; cursor: pointer;
                            transition: all 0.2s ease; hover:bg-blue-50;
                        " onmouseover="this.style.backgroundColor='#f0f9ff'; this.style.borderColor='#3b82f6'" 
                           onmouseout="this.style.backgroundColor='white'; this.style.borderColor='#e2e8f0'">
                            <div style="
                                display: flex; justify-content: space-between; align-items: flex-start; 
                                margin-bottom: 6px;
                            ">
                                <span style="
                                    font-weight: 600; color: #1f2937; font-size: 13px;
                                ">${section.title}</span>
                                <span style="
                                    font-size: 11px; color: #6b7280; margin-left: auto;
                                ">${section.wordCount} ${/[\u4e00-\u9fff]/.test(section.content) ? 'characters' : 'words'}</span>
                            </div>
                            <div style="
                                color: #4b5563; font-size: 12px; line-height: 1.4;
                            ">${section.preview}</div>
                        </div>
                    `;
                });
                
                // Â≠òÂÇ®Á´†ËäÇÊï∞ÊçÆ‰ª•‰æõÂêéÁª≠‰ΩøÁî®
                const sectionsKey = `sections_${fileName.replace(/[^a-zA-Z0-9]/g, '_')}`;
                window[sectionsKey] = sections;
                
                console.log('üíæ Â≠òÂÇ®Á´†ËäÇÊï∞ÊçÆÔºåÈîÆÂêç:', sectionsKey);
                console.log('üíæ Â≠òÂÇ®ÁöÑÁ´†ËäÇÊï∞Èáè:', sections.length);
                console.log('üíæ È™åËØÅÂ≠òÂÇ®ÊàêÂäü:', !!window[sectionsKey]);
                console.log('üíæ Â≠òÂÇ®ÂêéÁ´ãÂç≥Ê£ÄÊü•Êï∞ÊçÆ:', window[sectionsKey] ? window[sectionsKey].length : 'Êú™ÊâæÂà∞');
                
                console.log('üìã ÊúÄÁªàÁîüÊàêÁöÑHTMLÈïøÂ∫¶:', structureHtml.length);
                console.log('üìã HTMLÈ¢ÑËßà:', structureHtml.substring(0, 300));
                
                return structureHtml;
                
            } catch (error) {
                console.error('‚ùå ÁîüÊàêÊñáÊ°£ÁªìÊûÑÂ§±Ë¥•:', error);
                return `
                    <div style="text-align: center; padding: 20px; color: #6b7280;">
                        <div style="font-size: 24px; margin-bottom: 8px;">üìÑ</div>
                        <p>ÊñáÊ°£ÁªìÊûÑÁîüÊàê‰∏≠...</p>
                    </div>
                `;
            }
        }
        
        // üîç ÊµãËØïÂáΩÊï∞ÔºöÁõ¥Êé•ÊòæÁ§∫ÂÜÖÂÆπÂà∞Âè≥‰æßÂå∫Âüü
        window.testContentDisplay = function(text) {
            const container = document.getElementById('documentPreviewContent');
            if (container) {
                container.innerHTML = `<div style="padding: 20px;"><h3>ÊµãËØïÂÜÖÂÆπ</h3><p>${text}</p></div>`;
                console.log('‚úÖ ÊµãËØïÂÜÖÂÆπÂ∑≤ÊòæÁ§∫');
            } else {
                console.log('‚ùå Êâæ‰∏çÂà∞ÂÆπÂô® documentPreviewContent');
            }
        };
        
        // üîß Âº∫Âà∂‰øÆÂ§çÂè≥‰æßÈ¢ÑËßàÂå∫Âüü
        window.forceFixPreview = function() {
            console.log('üîß ÂºÄÂßãÂº∫Âà∂‰øÆÂ§çÂè≥‰æßÈ¢ÑËßàÂå∫Âüü...');
            
            // Êü•ÊâæÊâÄÊúâÂèØËÉΩÁöÑÂè≥‰æßÂå∫Âüü
            const allDivs = document.querySelectorAll('div');
            let found = false;
            
            allDivs.forEach((div, index) => {
                const text = div.textContent || '';
                const style = div.style.cssText || '';
                
                // ÂØªÊâæÂåÖÂê´ "Content Preview" ÊñáÊú¨ÊàñÁõ∏ÂÖ≥Ê†∑ÂºèÁöÑÂÖÉÁ¥†
                if (text.includes('Content Preview') || text.includes('Select a section')) {
                    console.log('üéØ ÊâæÂà∞ÂèØËÉΩÁöÑÈ¢ÑËßàÂå∫Âüü:', div);
                    div.id = 'documentPreviewContent'; // Âº∫Âà∂ËÆæÁΩÆID
                    div.innerHTML = `
                        <div style="padding: 20px; text-align: center; color: #6b7280;">
                            <h3>‚úÖ È¢ÑËßàÂå∫ÂüüÂ∑≤‰øÆÂ§ç</h3>
                            <p>Áé∞Âú®ÂèØ‰ª•ÁÇπÂáªÂ∑¶‰æßÁõÆÂΩïÊü•ÁúãÂÜÖÂÆπ‰∫Ü</p>
                        </div>
                    `;
                    found = true;
                    return;
                }
                
                // ÂØªÊâæÂè≥‰æßÁöÑÁ©∫ÁôΩÂå∫ÂüüÔºàÂèØËÉΩÊòØÈ¢ÑËßàÂÆπÂô®Ôºâ
                if (style.includes('background: white') && 
                    style.includes('border-radius: 16px') &&
                    div.children.length === 0) {
                    console.log('üéØ ÊâæÂà∞ÂèØËÉΩÁöÑÁ©∫ÁôΩÈ¢ÑËßàÂÆπÂô®:', div);
                    div.id = 'documentPreviewContent';
                    div.innerHTML = `
                        <div style="padding: 20px; text-align: center; color: #6b7280;">
                            <h3>üîß È¢ÑËßàÂÆπÂô®Â∑≤ÊøÄÊ¥ª</h3>
                            <p>ÁÇπÂáªÂ∑¶‰æßÊñáÊ°£ÁõÆÂΩïÊü•ÁúãÂÖ∑‰ΩìÂÜÖÂÆπ</p>
                        </div>
                    `;
                    found = true;
                    return;
                }
            });
            
            if (!found) {
                console.log('‚ùå Êú™ÊâæÂà∞È¢ÑËßàÂÆπÂô®ÔºåÂàõÂª∫Êñ∞ÁöÑ');
                showNotification('‚ùå È¢ÑËßàÂå∫Âüü‰∏¢Â§±ÔºåËØ∑Âà∑Êñ∞È°µÈù¢');
            } else {
                console.log('‚úÖ È¢ÑËßàÂå∫Âüü‰øÆÂ§çÂÆåÊàê');
                showNotification('‚úÖ È¢ÑËßàÂå∫ÂüüÂ∑≤‰øÆÂ§çÔºåÂèØ‰ª•ÁÇπÂáªÁõÆÂΩïÊü•ÁúãÂÜÖÂÆπ‰∫Ü');
            }
        };
        
        // üßπ Ê∏ÖÁêÜ‰∏çÂøÖË¶ÅÁöÑÂºπÁ™ó
        window.cleanupPopups = function() {
            console.log('üßπ Ê∏ÖÁêÜÈ°µÈù¢‰∏≠ÁöÑÂºπÁ™ó...');
            
            // Ê∏ÖÁêÜÊâÄÊúâÂèØËÉΩÁöÑ‰∏¥Êó∂ÂºπÁ™ó
            const popups = document.querySelectorAll('[id*="temp"], [id*="Temp"], [style*="position: fixed"]');
            let cleanedCount = 0;
            
            popups.forEach(popup => {
                if (popup.style.zIndex > '7000' || 
                    popup.id.includes('temp') || 
                    popup.id.includes('Temp') ||
                    (popup.style.position === 'fixed' && popup.style.transform && popup.style.transform.includes('translate'))) {
                    console.log('üóëÔ∏è ÁßªÈô§ÂºπÁ™ó:', popup.id || popup.className);
                    popup.remove();
                    cleanedCount++;
                }
            });
            
            console.log(`‚úÖ Ê∏ÖÁêÜÂÆåÊàêÔºåÁßªÈô§‰∫Ü ${cleanedCount} ‰∏™ÂºπÁ™ó`);
            
            if (cleanedCount > 0) {
                showNotification(`üßπ Â∑≤Ê∏ÖÁêÜ ${cleanedCount} ‰∏™ÂºπÁ™ó`);
            }
        };
        
        // üìå Ê∑ªÂä†Âø´Êç∑ÈîÆÊ∏ÖÁêÜÂºπÁ™ó (Ctrl+Shift+C)
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                e.preventDefault();
                window.cleanupPopups();
                console.log('‚å®Ô∏è ‰ΩøÁî®Âø´Êç∑ÈîÆÊ∏ÖÁêÜÂºπÁ™ó');
            }
        });

        // üìñ Âú®Ê®°ÊÄÅÊ°ÜÂÜÖÊòæÁ§∫Á´†ËäÇÂÜÖÂÆπ
        window.showSectionInModal = function showSectionInModal(sectionId, fileName) {
            console.log('üìñüî• Âú®Ê®°ÊÄÅÊ°ÜÂÜÖÊòæÁ§∫Á´†ËäÇÂÜÖÂÆπ:', sectionId, fileName);
            
            // ÈòªÊ≠¢‰∫ã‰ª∂ÂÜíÊ≥°
            event && event.preventDefault();
            event && event.stopPropagation();
            
            try {
                // È¶ñÂÖàÊ£ÄÊü•Ê®°ÊÄÅÊ°ÜÈ¢ÑËßàÂÆπÂô®ÊòØÂê¶Â≠òÂú®
                const modalPreviewContainer = document.getElementById('documentPreviewContent');
                console.log('üîç Ê£ÄÊü•Ê®°ÊÄÅÊ°ÜÈ¢ÑËßàÂÆπÂô®:', !!modalPreviewContainer);
                
                if (!modalPreviewContainer) {
                    console.error('‚ùå Ê®°ÊÄÅÊ°ÜÈ¢ÑËßàÂÆπÂô®‰∏çÂ≠òÂú®ÔºåÁ≠âÂæÖDOMÊ∏≤Êüì...');
                    setTimeout(() => showSectionInModal(sectionId, fileName), 100);
                    return;
                }
                
                const sectionsKey = `sections_${fileName.replace(/[^a-zA-Z0-9]/g, '_')}`;
                console.log('üîë ËÆ°ÁÆóÁöÑÁ´†ËäÇÈîÆÂêç:', sectionsKey);
                
                const sections = window[sectionsKey];
                console.log('üîç Êü•ÊâæÁ´†ËäÇÊï∞ÊçÆÔºåÈîÆÂêç:', sectionsKey);
                console.log('üîç Á´†ËäÇÊï∞ÊçÆÂ≠òÂú®:', !!sections);
                console.log('üîç Á´†ËäÇÊï∞Èáè:', sections ? sections.length : 0);
                
                // Ë∞ÉËØïÊâÄÊúâÂèØËÉΩÁöÑÈîÆÂêç
                const allWindowKeys = Object.keys(window).filter(key => key.startsWith('sections_'));
                console.log('üîç ÊâÄÊúâÁ´†ËäÇÈîÆÂêç:', allWindowKeys);
                
                if (!sections) {
                    console.error('‚ùå Êâæ‰∏çÂà∞Á´†ËäÇÊï∞ÊçÆÔºåÂ∞ùËØïÊòæÁ§∫ÈîôËØØ‰ø°ÊÅØ');
                    
                    // Âú®Ê®°ÊÄÅÊ°ÜÂÜÖÊòæÁ§∫ÈîôËØØ‰ø°ÊÅØ
                    const modalPreviewContainer = document.getElementById('documentPreviewContent');
                    if (modalPreviewContainer) {
                        modalPreviewContainer.innerHTML = `
                            <div style="text-align: center; padding: 60px 20px; color: #ef4444;">
                                <div style="font-size: 48px; margin-bottom: 16px;">‚ùå</div>
                                <h3 style="margin: 0 0 8px 0; color: #dc2626;">Á´†ËäÇÊï∞ÊçÆÊú™ÊâæÂà∞</h3>
                                <p style="margin: 0; font-size: 14px;">ÈîÆÂêç: ${sectionsKey}</p>
                                <p style="margin: 8px 0 0 0; font-size: 14px;">ÂèØÁî®ÈîÆÂêç: ${allWindowKeys.join(', ')}</p>
                            </div>
                        `;
                    }
                    return;
                }
                
                console.log('üìã ÊâÄÊúâÁ´†ËäÇ:', sections.map(s => ({ id: s.id, title: s.title, contentLength: s.content?.length })));
                
                const section = sections.find(s => s.id === sectionId);
                if (!section) {
                    console.error('‚ùå Êâæ‰∏çÂà∞ÊåáÂÆöÁ´†ËäÇ:', sectionId);
                    console.log('üìã ÂèØÁî®Á´†ËäÇID:', sections.map(s => s.id));
                    
                    // Âú®Ê®°ÊÄÅÊ°ÜÂÜÖÊòæÁ§∫ÈîôËØØ‰ø°ÊÅØ
                    const modalPreviewContainer = document.getElementById('documentPreviewContent');
                    if (modalPreviewContainer) {
                        modalPreviewContainer.innerHTML = `
                            <div style="text-align: center; padding: 60px 20px; color: #ef4444;">
                                <div style="font-size: 48px; margin-bottom: 16px;">‚ùå</div>
                                <h3 style="margin: 0 0 8px 0; color: #dc2626;">Á´†ËäÇÊú™ÊâæÂà∞</h3>
                                <p style="margin: 0; font-size: 14px;">Êü•ÊâæÁ´†ËäÇ: ${sectionId}</p>
                                <p style="margin: 8px 0 0 0; font-size: 14px;">ÂèØÁî®Á´†ËäÇ: ${sections.map(s => s.id).join(', ')}</p>
                            </div>
                        `;
                    }
                    return;
                }
                
                console.log('‚úÖ ÊâæÂà∞Á´†ËäÇ:', section.title, 'ÂÜÖÂÆπÈïøÂ∫¶:', section.content?.length);
                
                // Á°ÆËÆ§Ê®°ÊÄÅÊ°ÜÈ¢ÑËßàÂÆπÂô®‰ªçÁÑ∂Â≠òÂú®
                console.log('üîç ÂÜçÊ¨°Á°ÆËÆ§Ê®°ÊÄÅÊ°ÜÈ¢ÑËßàÂÆπÂô®:', !!modalPreviewContainer);
                
                if (!modalPreviewContainer) {
                    console.error('‚ùå Ê®°ÊÄÅÊ°ÜÈ¢ÑËßàÂÆπÂô®Â∑≤‰∏çÂ≠òÂú®');
                    return;
                }
                
                // ÊòæÁ§∫ÂÜÖÂÆπ
                displaySectionContent(modalPreviewContainer, section);
            
                
            } catch (error) {
                console.error('‚ùå ÊòæÁ§∫Ê®°ÊÄÅÊ°ÜÁ´†ËäÇÂÜÖÂÆπÂ§±Ë¥•:', error);
                console.error('‚ùå ÈîôËØØÂ†ÜÊ†à:', error.stack);
                
                // Âú®Ê®°ÊÄÅÊ°ÜÂÜÖÊòæÁ§∫ÈîôËØØ‰ø°ÊÅØ
                const modalPreviewContainer = document.getElementById('documentPreviewContent');
                if (modalPreviewContainer) {
                    modalPreviewContainer.innerHTML = `
                        <div style="text-align: center; padding: 60px 20px; color: #ef4444;">
                            <div style="font-size: 48px; margin-bottom: 16px;">üí•</div>
                            <h3 style="margin: 0 0 8px 0; color: #dc2626;">ÊòæÁ§∫Á´†ËäÇÊó∂Âá∫Èîô</h3>
                            <p style="margin: 0; font-size: 14px;">${error.message}</p>
                        </div>
                    `;
                }
            }
        };

        // üìñ ÊòæÁ§∫Á´†ËäÇÂÜÖÂÆπÁöÑËæÖÂä©ÂáΩÊï∞
        function displaySectionContent(container, section) {
            console.log('üé® ÂºÄÂßãÊòæÁ§∫Á´†ËäÇÂÜÖÂÆπ:', section.title);
            console.log('üé® ÂÆπÂô®ÂÖÉÁ¥†:', container);
            console.log('üé® Á´†ËäÇÊï∞ÊçÆ:', section);
            
            if (!container) {
                console.error('‚ùå ÂÆπÂô®ÂÖÉÁ¥†‰∏∫Á©∫ÔºÅ');
                return;
            }
            
            if (!section) {
                console.error('‚ùå Á´†ËäÇÊï∞ÊçÆ‰∏∫Á©∫ÔºÅ');
                return;
            }
            
            // Âú®Ê®°ÊÄÅÊ°ÜÂÜÖÊòæÁ§∫Á´†ËäÇÂÜÖÂÆπ
            const displayContent = section.content || 'Á´†ËäÇÂÜÖÂÆπ‰∏∫Á©∫';
            console.log('üé® Ë¶ÅÊòæÁ§∫ÁöÑÂÜÖÂÆπÈïøÂ∫¶:', displayContent.length);
            console.log('üé® ÂÜÖÂÆπÈ¢ÑËßà:', displayContent.substring(0, 200));
            
            // üî• ‰∏¥Êó∂ÊµãËØïÔºöÂº∫Âà∂ÊòæÁ§∫‰∏Ä‰∫õÂÜÖÂÆπ
            const testContent = displayContent.length > 0 ? displayContent : 'ÊµãËØïÂÜÖÂÆπ - Â¶ÇÊûú‰Ω†ÁúãÂà∞Ëøô‰∏™ÔºåËØ¥ÊòéÊòæÁ§∫ÂäüËÉΩÊ≠£Â∏∏';
            console.log('üî• ÊµãËØïÂÜÖÂÆπÈïøÂ∫¶:', testContent.length);
            
            const htmlContent = `
                <div style="margin-bottom: 20px;">
                    <h3 style="margin: 0 0 12px 0; color: #1f2937; font-size: 18px; font-weight: 600;">
                        ${section.title}
                    </h3>
                    <div style="color: #6b7280; font-size: 14px; margin-bottom: 16px;">
                        ${section.wordCount || 'Êú™Áü•'} ${/[\u4e00-\u9fff]/.test(testContent) ? 'characters' : 'words'}
                    </div>
                </div>
                <div style="
                    line-height: 1.8; color: #374151; font-size: 15px;
                    white-space: pre-wrap; word-wrap: break-word; background: #f9f9f9; padding: 15px; border-radius: 8px;
                ">
                    ${testContent}
                </div>
                <div style="margin-top: 15px; padding: 10px; background: #e3f2fd; border-radius: 8px; font-size: 12px; color: #1565c0;">
                    üîç Ë∞ÉËØï‰ø°ÊÅØ: ÂéüÂßãÂÜÖÂÆπÈïøÂ∫¶ ${displayContent.length}, ÊòæÁ§∫ÂÜÖÂÆπÈïøÂ∫¶ ${testContent.length}
                </div>
            `;
            
            console.log('üé® ÁîüÊàêÁöÑHTMLÈïøÂ∫¶:', htmlContent.length);
            console.log('üé® Â∞ÜË¶ÅËÆæÁΩÆÁöÑHTMLÂÜÖÂÆπÈ¢ÑËßà:', htmlContent.substring(0, 500));
            
            container.innerHTML = htmlContent;
            
            console.log('‚úÖ Ê®°ÊÄÅÊ°ÜÂÜÖÁ´†ËäÇÂÜÖÂÆπÊòæÁ§∫ÂÆåÊàê');
            console.log('üîç ÂÆπÂô®Êõ¥Êñ∞ÂêéÁöÑinnerHTMLÈïøÂ∫¶:', container.innerHTML.length);
            console.log('üîç ÂÆπÂô®Êõ¥Êñ∞ÂêéÁöÑinnerHTMLÈ¢ÑËßà:', container.innerHTML.substring(0, 500));
            console.log('üîç ÂÆπÂô®ÁöÑÂèØËßÅÊÄß:', window.getComputedStyle(container).display);
            console.log('üîç ÂÆπÂô®ÁöÑÈ´òÂ∫¶:', container.offsetHeight, 'px');
            console.log('üîç ÂÆπÂô®ÁöÑÁà∂ÂÖÉÁ¥†:', container.parentElement);
        }

        // üìñ ÊòæÁ§∫Á´†ËäÇÂÜÖÂÆπ (‰øÆÂ§çÁâàÊú¨)
        window.showSectionContent = function showSectionContent(sectionId, fileName) {
            console.log('üìñ ÊòæÁ§∫Á´†ËäÇÂÜÖÂÆπ:', sectionId, fileName);
            
            // ÈòªÊ≠¢‰ªª‰ΩïÂºπÁ™óË°å‰∏∫
            event && event.preventDefault();
            event && event.stopPropagation();
            
            // È¶ñÂÖàÊ∏ÖÁêÜ‰∏çÂøÖË¶ÅÁöÑÂºπÁ™ó
            window.cleanupPopups();
            
            try {
                const sectionsKey = `sections_${fileName.replace(/[^a-zA-Z0-9]/g, '_')}`;
                const sections = window[sectionsKey];
                
                console.log('üîç Êü•ÊâæÁ´†ËäÇÊï∞ÊçÆÔºåÈîÆÂêç:', sectionsKey);
                console.log('üîç Á´†ËäÇÊï∞ÊçÆÂ≠òÂú®:', !!sections);
                console.log('üîç Á´†ËäÇÊï∞Èáè:', sections ? sections.length : 0);
                
                if (!sections) {
                    console.error('‚ùå Êâæ‰∏çÂà∞Á´†ËäÇÊï∞ÊçÆÔºåÊòæÁ§∫ÈîôËØØÊèêÁ§∫');
                    showNotification('‚ùå Á´†ËäÇÊï∞ÊçÆ‰∏¢Â§±ÔºåËØ∑ÈáçÊñ∞ÊâìÂºÄÊñáÊ°£');
                    return false; // ÈòªÊ≠¢ÂºπÁ™ó
                }
                
                const section = sections.find(s => s.id === sectionId);
                if (!section) {
                    console.error('‚ùå Êâæ‰∏çÂà∞ÊåáÂÆöÁ´†ËäÇ:', sectionId);
                    showNotification(`‚ùå Êâæ‰∏çÂà∞Á´†ËäÇ: ${sectionId}`);
                    return false; // ÈòªÊ≠¢ÂºπÁ™ó
                }
                
                console.log('‚úÖ ÊâæÂà∞Á´†ËäÇ:', section.title);
                console.log('üìñ Á´†ËäÇÂÜÖÂÆπÈïøÂ∫¶:', section.content.length);
                
                // Ëé∑ÂèñÁü•ËØÜÂ∫ìÈù¢ÊùøÂè≥‰æßÁöÑÈ¢ÑËßàÂÆπÂô®
                let previewContainer = document.getElementById('contentPreview');
                console.log('üîç Êü•ÊâæÁü•ËØÜÂ∫ìÈ¢ÑËßàÂÆπÂô®:', !!previewContainer);
                
                // Â¶ÇÊûúÊâæ‰∏çÂà∞È¢ÑËßàÂÆπÂô®Ôºå‰∏çË¶ÅÊòæÁ§∫ÂºπÁ™óÔºåËÄåÊòØÊòæÁ§∫ÈÄöÁü•
                if (!previewContainer) {
                    console.error('‚ùå Êó†Ê≥ïÊâæÂà∞È¢ÑËßàÂÆπÂô®ÔºåÊòæÁ§∫ÈÄöÁü•ËÄå‰∏çÊòØÂºπÁ™ó');
                    showNotification('‚ùå È¢ÑËßàÂå∫Âüü‰∏çÂèØÁî®ÔºåËØ∑ÈáçÊñ∞ÊâìÂºÄÊñáÊ°£Á™óÂè£', 'error');
                    return false; // ÈòªÊ≠¢ÂºπÁ™ó
                }
                
                console.log('‚úÖ ÊâæÂà∞È¢ÑËßàÂÆπÂô®ÔºåÂºÄÂßãÊõ¥Êñ∞ÂÜÖÂÆπ');
                console.log('üìñ Á´†ËäÇÂÜÖÂÆπ:', section.content.substring(0, 100) + '...');
                
                // ÊòæÁ§∫ÂÖ≥Èó≠ÊåâÈíÆ
                const closePreviewBtn = document.getElementById('closePreview');
                if (closePreviewBtn) {
                    closePreviewBtn.style.display = 'block';
                }
                
                previewContainer.innerHTML = `
                    <div style="padding: 20px;">
                        <div style="margin-bottom: 20px; border-bottom: 2px solid #e2e8f0; padding-bottom: 15px;">
                            <h2 style="margin: 0; color: #1f2937; font-size: 20px;">${section.title}</h2>
                            <p style="margin: 5px 0 0 0; color: #6b7280; font-size: 13px;">
                                ${section.wordCount} words ‚Ä¢ ${Math.ceil(section.wordCount / 200)} min read
                            </p>
                        </div>
                        
                        <div style="
                            line-height: 1.6; font-size: 15px; color: #374151;
                            white-space: pre-wrap; padding: 15px; background: #f8f9fa;
                            border-radius: 8px; border-left: 3px solid #3b82f6;
                        ">
                            ${section.content}
                        </div>
                        
                        <div style="
                            margin-top: 15px; padding: 12px; background: #f0f9ff; 
                            border-radius: 6px; font-size: 12px; color: #1e40af;
                        ">
                            üí° <strong>ÊèêÁ§∫Ôºö</strong>ËøôÊòØÊñáÊ°£ÁöÑÁ¨¨${section.id.split('_')[1]}ÈÉ®ÂàÜÂÜÖÂÆπ
                        </div>
                    </div>
                `;
                
                // ÊªöÂä®Âà∞È°∂ÈÉ®
                previewContainer.scrollTop = 0;
                
                console.log('‚úÖ Á´†ËäÇÂÜÖÂÆπÊòæÁ§∫ÊàêÂäü');
                
            } catch (error) {
                console.error('‚ùå ÊòæÁ§∫Á´†ËäÇÂÜÖÂÆπÂ§±Ë¥•:', error);
                console.error('ÈîôËØØËØ¶ÊÉÖ:', error.stack);
                
                // ÊòæÁ§∫ÈîôËØØÈÄöÁü•ËÄå‰∏çÊòØÂºπÁ™ó
                showNotification('‚ùå Á´†ËäÇÂÜÖÂÆπÂä†ËΩΩÂ§±Ë¥•ÔºåËØ∑ÈáçËØï', 'error');
                
                // Â∞ùËØïÂú®È¢ÑËßàÂÆπÂô®‰∏≠ÊòæÁ§∫ÈîôËØØ‰ø°ÊÅØ
                const previewContainer = document.getElementById('documentPreviewContent');
                if (previewContainer) {
                    previewContainer.innerHTML = `
                        <div style="text-align: center; padding: 60px 20px; color: #dc2626;">
                            <div style="font-size: 48px; margin-bottom: 16px;">‚ùå</div>
                            <h3 style="margin: 0 0 12px 0; color: #dc2626;">ÂÜÖÂÆπÂä†ËΩΩÈîôËØØ</h3>
                            <p style="margin: 0; font-size: 15px; color: #6b7280;">
                                Á´†ËäÇÂÜÖÂÆπÂä†ËΩΩÂ§±Ë¥•ÔºåËØ∑ÈáçËØïÊàñÈáçÊñ∞ÊâìÂºÄÊñáÊ°£„ÄÇ
                            </p>
                            <button onclick="location.reload()" style="
                                margin-top: 20px; padding: 10px 20px; border: none; 
                                background: #3b82f6; color: white; border-radius: 6px; cursor: pointer;
                            ">Âà∑Êñ∞È°µÈù¢</button>
                        </div>
                    `;
                }
            }
        }
        
        // ‚úèÔ∏è ÊâìÂºÄÊñáÊ°£ÁºñËæëÂô®
        // üìù ÁºñËæëÂô®Â∑•ÂÖ∑ÂáΩÊï∞
        window.formatText = function(type) {
            const textarea = document.querySelector('#documentEditor');
            if (!textarea) return;
            
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const selectedText = textarea.value.substring(start, end);
            
            let formattedText = '';
            switch(type) {
                case 'bold':
                    formattedText = `**${selectedText}**`;
                    break;
                case 'italic':
                    formattedText = `*${selectedText}*`;
                    break;
            }
            
            textarea.value = textarea.value.substring(0, start) + formattedText + textarea.value.substring(end);
            textarea.focus();
            textarea.setSelectionRange(start + formattedText.length, start + formattedText.length);
        };
        
        window.insertText = function(text) {
            const textarea = document.querySelector('#documentEditor');
            if (!textarea) return;
            
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            
            textarea.value = textarea.value.substring(0, start) + text + textarea.value.substring(end);
            textarea.focus();
            textarea.setSelectionRange(start + text.length, start + text.length);
        };
        
        window.closeDocumentEditor = function() {
            console.log('ÂÖ≥Èó≠ÊñáÊ°£ÁºñËæëÂô®');
            const modal = document.querySelector('[style*="position: fixed"][style*="z-index: 10000"]');
            if (modal) {
                modal.remove();
                console.log('ÁºñËæëÂô®Â∑≤ÂÖ≥Èó≠');
            } else {
                console.log('Êú™ÊâæÂà∞ÁºñËæëÂô®Ê®°ÊÄÅÊ°Ü');
            }
        };
        
        window.openDocumentEditor = function openDocumentEditor(fileName, sectionId = null) {
            console.log('‚úèÔ∏è ÊâìÂºÄÊñáÊ°£ÁºñËæëÂô®:', fileName, sectionId);
            
            // Ëé∑ÂèñÊñá‰ª∂ÂÜÖÂÆπ
            const analysisDB = JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}');
            const matchingKey = Object.keys(analysisDB).find(key => key.includes(fileName));
            const fileAnalysis = matchingKey ? analysisDB[matchingKey] : null;
            
            if (!fileAnalysis || !fileAnalysis.extractedContent) {
                alert('Unable to find file content, please re-upload the file');
                return;
            }
            
            let editContent = fileAnalysis.extractedContent;
            let editTitle = `Edit Document: ${fileName}`;
            
            // Â¶ÇÊûúÊåáÂÆö‰∫ÜÁ´†ËäÇÔºåÂè™ÁºñËæëËØ•Á´†ËäÇ
            if (sectionId) {
                const sectionsKey = `sections_${fileName.replace(/[^a-zA-Z0-9]/g, '_')}`;
                const sections = window[sectionsKey];
                const section = sections?.find(s => s.id === sectionId);
                
                if (section) {
                    editContent = section.content;
                    editTitle = `Edit ${section.title} - ${fileName}`;
                }
            }
            
            // ÂàõÂª∫ÁºñËæëÂô®Ê®°ÊÄÅÊ°Ü
            showDocumentEditorModal(fileName, editContent, editTitle, sectionId);
        }
        
        // üìù ÊòæÁ§∫ÊñáÊ°£ÁºñËæëÂô®Ê®°ÊÄÅÊ°Ü
        function showDocumentEditorModal(fileName, content, title, sectionId = null) {
            console.log('üìù ÊòæÁ§∫ÊñáÊ°£ÁºñËæëÂô®Ê®°ÊÄÅÊ°Ü');
            
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.8); z-index: 10000; display: flex; 
                align-items: center; justify-content: center;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white; border-radius: 16px; 
                    width: 90vw; max-width: 1000px; height: 85vh; 
                    box-shadow: 0 25px 80px rgba(0,0,0,0.4); 
                    display: flex; flex-direction: column; overflow: hidden;
                ">
                    <!-- ÁºñËæëÂô®Â§¥ÈÉ® -->
                    <div style="
                        background: linear-gradient(135deg, #3b82f6, #1d4ed8); 
                        color: white; padding: 20px 30px; display: flex; 
                        align-items: center; justify-content: space-between;
                    ">
                        <div>
                            <h2 style="margin: 0; font-size: 20px; font-weight: 600;">${title}</h2>
                            <p style="margin: 6px 0 0 0; opacity: 0.9; font-size: 14px;">
                                Real-time editing ‚Ä¢ Auto-save ‚Ä¢ ${new Date().toLocaleString()}
                            </p>
                        </div>
                        <button onclick="closeDocumentEditor()" style="
                            background: rgba(255,255,255,0.2); border: none; 
                            width: 40px; height: 40px; border-radius: 50%; 
                            cursor: pointer; color: white; font-size: 18px;
                            display: flex; align-items: center; justify-content: center;
                            transition: all 0.2s ease;
                        " onmouseover="this.style.background='rgba(255,255,255,0.3)'" 
                           onmouseout="this.style.background='rgba(255,255,255,0.2)'">‚úï</button>
                    </div>
                    
                    <!-- ÁºñËæëÂô®Â∑•ÂÖ∑Ê†è -->
                    <div style="
                        background: #f8fafc; padding: 12px 30px; border-bottom: 1px solid #e2e8f0;
                        display: flex; align-items: center; gap: 12px;
                    ">
                        <button onclick="formatText('bold'); this.style.background='#3b82f6'; this.style.color='white'; setTimeout(() => {this.style.background='#e2e8f0'; this.style.color='#374151';}, 150)" style="
                            background: #e2e8f0; border: none; padding: 8px 12px; 
                            border-radius: 6px; cursor: pointer; font-weight: bold;
                            transition: all 0.15s ease; color: #374151;
                        " onmouseover="this.style.background='#d1d5db'" 
                           onmouseout="this.style.background='#e2e8f0'">B</button>
                        <button onclick="formatText('italic'); this.style.background='#3b82f6'; this.style.color='white'; setTimeout(() => {this.style.background='#e2e8f0'; this.style.color='#374151';}, 150)" style="
                            background: #e2e8f0; border: none; padding: 8px 12px; 
                            border-radius: 6px; cursor: pointer; font-style: italic;
                            transition: all 0.15s ease; color: #374151;
                        " onmouseover="this.style.background='#d1d5db'" 
                           onmouseout="this.style.background='#e2e8f0'">I</button>
                        <div style="width: 1px; height: 24px; background: #d1d5db;"></div>
                        <button onclick="insertText('## '); this.style.background='#3b82f6'; this.style.color='white'; setTimeout(() => {this.style.background='#e2e8f0'; this.style.color='#374151';}, 150)" style="
                            background: #e2e8f0; border: none; padding: 8px 12px; 
                            border-radius: 6px; cursor: pointer; font-size: 12px;
                            transition: all 0.15s ease; color: #374151;
                        " onmouseover="this.style.background='#d1d5db'" 
                           onmouseout="this.style.background='#e2e8f0'">Header</button>
                        <button onclick="insertText('- '); this.style.background='#3b82f6'; this.style.color='white'; setTimeout(() => {this.style.background='#e2e8f0'; this.style.color='#374151';}, 150)" style="
                            background: #e2e8f0; border: none; padding: 8px 12px; 
                            border-radius: 6px; cursor: pointer; font-size: 12px;
                            transition: all 0.15s ease; color: #374151;
                        " onmouseover="this.style.background='#d1d5db'" 
                           onmouseout="this.style.background='#e2e8f0'">List</button>
                        <div style="margin-left: auto; display: flex; align-items: center; gap: 12px;">
                            <span id="documentWordCount" style="color: #6b7280; font-size: 13px;">
                                ${content.split(/\s+/).length} words
                            </span>
                        </div>
                    </div>
                    
                    <!-- ÁºñËæëÂô®‰∏ª‰Ωì -->
                    <div style="flex: 1; display: flex; overflow: hidden;">
                        <!-- ÁºñËæëÂå∫Âüü -->
                        <div style="flex: 1; padding: 0; display: flex; flex-direction: column;">
                            <textarea id="documentEditor" style="
                                flex: 1; border: none; outline: none; padding: 30px; 
                                font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
                                font-size: 15px; line-height: 1.8; color: #374151;
                                background: white; resize: none;
                            " placeholder="Start editing your document...">${content}</textarea>
                        </div>
                        
                        <!-- È¢ÑËßàÂå∫Âüü -->
                        <div id="documentPreview" style="
                            flex: 1; padding: 30px; background: #fafafa; 
                            border-left: 1px solid #e2e8f0; overflow-y: auto;
                            font-size: 15px; line-height: 1.8; color: #374151;
                        ">
                            <div style="color: #6b7280; text-align: center; padding: 40px;">
                                <div style="font-size: 32px; margin-bottom: 12px;">üëÅÔ∏è</div>
                                <p>Real-time preview will appear here</p>
                                <p style="font-size: 13px;">Start editing content on the left to see preview</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- ÁºñËæëÂô®Â∫ïÈÉ® -->
                    <div style="
                        background: #f8fafc; padding: 20px 30px; border-top: 1px solid #e2e8f0;
                        display: flex; align-items: center; justify-content: space-between;
                    ">
                        <div style="display: flex; align-items: center; gap: 16px;">
                            <div style="
                                display: flex; align-items: center; gap: 6px; 
                                color: #10b981; font-size: 13px;
                            ">
                                <span>üíæ</span>
                                <span>Auto-save enabled</span>
                            </div>
                            <div style="
                                display: flex; align-items: center; gap: 6px; 
                                color: #6b7280; font-size: 13px;
                            ">
                                <span>üìù</span>
                                <span>Last saved: just now</span>
                            </div>
                        </div>
                        
                        <div style="display: flex; gap: 12px;">
                            <button onclick="closeDocumentEditor()" style="
                                background: #e5e7eb; border: none; padding: 10px 20px; 
                                border-radius: 8px; cursor: pointer; color: #374151;
                                transition: all 0.2s ease;
                            " onmouseover="this.style.background='#d1d5db'" 
                               onmouseout="this.style.background='#e5e7eb'">Cancel</button>
                            <button onclick="saveDocumentChanges('${fileName}', '${sectionId}')" style="
                                background: #3b82f6; color: white; border: none; 
                                padding: 10px 20px; border-radius: 8px; cursor: pointer;
                                font-weight: 600; display: flex; align-items: center; gap: 6px;
                                transition: all 0.2s ease;
                            " onmouseover="this.style.background='#2563eb'; this.style.transform='translateY(-1px)'" 
                               onmouseout="this.style.background='#3b82f6'; this.style.transform='translateY(0)'">
                                üíæ Save Changes
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // ÂàùÂßãÂåñÁºñËæëÂô®ÂäüËÉΩ
            initializeDocumentEditor();
            
            // ÁÇπÂáªËÉåÊôØÂÖ≥Èó≠
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        
        // üîß ÂàùÂßãÂåñÊñáÊ°£ÁºñËæëÂô®ÂäüËÉΩ
        function initializeDocumentEditor() {
            const editor = document.getElementById('documentEditor');
            const preview = document.getElementById('documentPreview');
            const wordCount = document.getElementById('documentWordCount');
            
            if (!editor || !preview) return;
            
            // ÂÆûÊó∂È¢ÑËßàÊõ¥Êñ∞
            function updatePreview() {
                const content = editor.value;
                const words = content.trim() ? content.trim().split(/\s+/).length : 0;
                
                // Êõ¥Êñ∞Â≠óÊï∞ÁªüËÆ°
                if (wordCount) {
                    wordCount.textContent = `${words} words`;
                }
                
                // ÁÆÄÂçïÁöÑMarkdownÊ∏≤Êüì
                let html = content
                    .replace(/^### (.*$)/gim, '<h3 style="color: #1f2937; margin: 24px 0 12px 0;">$1</h3>')
                    .replace(/^## (.*$)/gim, '<h2 style="color: #1f2937; margin: 28px 0 16px 0;">$1</h2>')
                    .replace(/^# (.*$)/gim, '<h1 style="color: #1f2937; margin: 32px 0 20px 0;">$1</h1>')
                    .replace(/\*\*(.*?)\*\*/g, '<strong style="color: #1f2937;">$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em style="color: #4b5563;">$1</em>')
                    .replace(/^- (.*$)/gim, '<li style="margin-bottom: 4px;">$1</li>')
                    .replace(/\n\n/g, '</p><p style="margin-bottom: 16px;">')
                    .replace(/\n/g, '<br>');
                
                // ÂåÖË£ÖÊÆµËêΩ
                if (html && !html.includes('<h1>') && !html.includes('<h2>')) {
                    html = '<p style="margin-bottom: 16px;">' + html + '</p>';
                }
                
                preview.innerHTML = html || '<div style="color: #6b7280; text-align: center; padding: 40px;"><p>ÂºÄÂßãÁºñËæëÊü•ÁúãÈ¢ÑËßà</p></div>';
            }
            
            // ÁõëÂê¨ËæìÂÖ•
            editor.addEventListener('input', updatePreview);
            
            // ÂàùÂßãÈ¢ÑËßà
            updatePreview();
            
            // Ëá™Âä®‰øùÂ≠ò
            let saveTimer;
            editor.addEventListener('input', () => {
                clearTimeout(saveTimer);
                saveTimer = setTimeout(() => {
                    console.log('üîÑ Ëá™Âä®‰øùÂ≠òÊñáÊ°£Êõ¥Êîπ');
                    // ËøôÈáåÂèØ‰ª•ÂÆûÁé∞Ëá™Âä®‰øùÂ≠òÈÄªËæë
                }, 2000);
            });
        }
        
        // üíæ ‰øùÂ≠òÊñáÊ°£Êõ¥Êîπ
        function saveDocumentChanges(fileName, sectionId = null) {
            console.log('üíæ ‰øùÂ≠òÊñáÊ°£Êõ¥Êîπ:', fileName, sectionId);
            
            const editor = document.getElementById('documentEditor');
            if (!editor) {
                alert('ÁºñËæëÂô®Êú™ÊâæÂà∞');
                return;
            }
            
            const newContent = editor.value;
            
            try {
                // Ëé∑ÂèñÁé∞ÊúâÁöÑÂàÜÊûêÊï∞ÊçÆ
                const analysisDB = JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}');
                const matchingKey = Object.keys(analysisDB).find(key => key.includes(fileName));
                
                if (!matchingKey) {
                    alert('Êú™ÊâæÂà∞Êñá‰ª∂ÂàÜÊûêÊï∞ÊçÆ');
                    return;
                }
                
                // Êõ¥Êñ∞ÂÜÖÂÆπ
                if (sectionId) {
                    // Êõ¥Êñ∞ÁâπÂÆöÁ´†ËäÇ
                    const sectionsKey = `sections_${fileName.replace(/[^a-zA-Z0-9]/g, '_')}`;
                    const sections = window[sectionsKey];
                    if (sections) {
                        const sectionIndex = sections.findIndex(s => s.id === sectionId);
                        if (sectionIndex >= 0) {
                            sections[sectionIndex].content = newContent;
                            sections[sectionIndex].wordCount = newContent.split(/\s+/).length;
                            
                            // ÈáçÊñ∞ÁªÑÂêàÂÆåÊï¥ÂÜÖÂÆπ
                            const fullContent = sections.map(s => s.content).join('\n\n');
                            analysisDB[matchingKey].extractedContent = fullContent;
                        }
                    }
                } else {
                    // Êõ¥Êñ∞Êï¥‰∏™ÊñáÊ°£
                    analysisDB[matchingKey].extractedContent = newContent;
                }
                
                // ‰øùÂ≠òÂà∞localStorage
                localStorage.setItem('graphRAGAnalysisDB', JSON.stringify(analysisDB));
                
                // ÂÖ≥Èó≠ÁºñËæëÂô®
                document.querySelector('[style*="position: fixed"]').remove();
                
                // ÊòæÁ§∫ÊàêÂäüÊ∂àÊÅØ
                showNotification('‚úÖ ÊñáÊ°£Êõ¥ÊîπÂ∑≤‰øùÂ≠ò', 'success');
                
                console.log('‚úÖ ÊñáÊ°£Êõ¥Êîπ‰øùÂ≠òÊàêÂäü');
                
            } catch (error) {
                console.error('‚ùå ‰øùÂ≠òÊñáÊ°£Êõ¥ÊîπÂ§±Ë¥•:', error);
                alert('‰øùÂ≠òÂ§±Ë¥•: ' + error.message);
            }
        }
        
        // üßπ Ê∏ÖÁêÜÊóßÁöÑÊñá‰ª∂Êï∞ÊçÆ‰ª•ÈáäÊîælocalStorageÁ©∫Èó¥
        async function cleanupOldFileData() {
            console.log('üßπ ÂºÄÂßãÊ∏ÖÁêÜlocalStorage‰∏≠ÁöÑÊóßÊñá‰ª∂Êï∞ÊçÆ...');
            
            const keys = Object.keys(localStorage);
            const fileKeys = keys.filter(key => key.startsWith('file_'));
            
            // ÊåâÊó∂Èó¥Êà≥ÊéíÂ∫èÔºåÂà†Èô§ÊúÄÊóßÁöÑÊñá‰ª∂
            const sortedKeys = fileKeys.sort((a, b) => {
                const timeA = parseInt(a.split('_').pop());
                const timeB = parseInt(b.split('_').pop());
                return timeA - timeB; // ÂçáÂ∫èÔºåÊúÄÊóßÁöÑÂú®Ââç
            });
            
            // Âà†Èô§‰∏ÄÂçäÁöÑÊóßÊñá‰ª∂
            const toDelete = Math.min(5, Math.floor(sortedKeys.length / 2));
            for (let i = 0; i < toDelete; i++) {
                const key = sortedKeys[i];
                localStorage.removeItem(key);
                console.log('üóëÔ∏è Âà†Èô§ÊóßÊñá‰ª∂Êï∞ÊçÆ:', key);
            }
            
            console.log(`‚úÖ Ê∏ÖÁêÜÂÆåÊàêÔºåÂà†Èô§‰∫Ü ${toDelete} ‰∏™ÊóßÊñá‰ª∂Êï∞ÊçÆ`);
        }
        
        // üìÑ ÊèêÂèñPDFÊñáÊú¨ÂÜÖÂÆπÔºàÊô∫ËÉΩÁâàÊú¨Ôºâ
        async function extractTextFromPDF(file) {
            console.log('üîç ÂºÄÂßãPDFÂÜÖÂÆπÊèêÂèñ...');
            
            try {
                // Ë∞ÉÁî®GraphRAG APIÊèêÂèñPDFÂÜÖÂÆπ
                const formData = new FormData();
                formData.append('file', file);
                
                const response = await fetch('http://127.0.0.1:8000/api/graphrag/analyze', {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.status === 'success' && result.analysis && result.analysis.content) {
                        console.log('‚úÖ PDFÂÜÖÂÆπÊèêÂèñÊàêÂäüÔºåÈïøÂ∫¶:', result.analysis.content.length);
                        return result.analysis.content;
                    }
                }
                
                // Â¶ÇÊûúAPIË∞ÉÁî®Â§±Ë¥•ÔºåËøîÂõûÂ§áÁî®ÊëòË¶Å
                throw new Error('PDFÂÜÖÂÆπÊèêÂèñÂ§±Ë¥•');
                
            } catch (error) {
                console.log('‚ö†Ô∏è PDFÂÜÖÂÆπÊèêÂèñÂ§±Ë¥•Ôºå‰ΩøÁî®ÊëòË¶ÅÊ®°Âºè:', error);
                
                // Â§áÁî®ÊëòË¶Å
                const documentSummary = `üìÑ ${file.name}

üìä ÊñáÊ°£‰ø°ÊÅØ:
‚Ä¢ Êñá‰ª∂Á±ªÂûã: PDFÊñáÊ°£
‚Ä¢ Êñá‰ª∂Â§ßÂ∞è: ${(file.size / 1024 / 1024).toFixed(2)} MB
‚Ä¢ È¢Ñ‰º∞È°µÊï∞: ${Math.ceil(file.size / 50000)} È°µ
‚Ä¢ ‰∏ä‰º†Êó∂Èó¥: ${new Date().toLocaleString()}

‚ö†Ô∏è ÂÜÖÂÆπÊèêÂèñÁä∂ÊÄÅ:
PDFÂÜÖÂÆπÊèêÂèñÊúçÂä°ÊöÇÊó∂‰∏çÂèØÁî®„ÄÇ

üí° Âª∫ËÆÆ:
‚Ä¢ Ê£ÄÊü•GraphRAGÊúçÂä°ÊòØÂê¶Ê≠£Â∏∏ËøêË°å
‚Ä¢ Á®çÂêéÈáçËØïÊñáÊ°£Â§ÑÁêÜ
‚Ä¢ ‰ΩøÁî®"Áî®Êú¨Âú∞Â∑•ÂÖ∑ÊâìÂºÄ"Êü•ÁúãÂÆåÊï¥ÂÜÖÂÆπ`;

                return documentSummary;
            }
        }
        
        // üìù ‰ªéHTML‰∏≠ÊèêÂèñÁ∫ØÊñáÊú¨ÂÜÖÂÆπ
        function extractTextFromHTML(htmlContent) {
            try {
                console.log('üîß ÂºÄÂßã‰ªéHTMLÊèêÂèñÁ∫ØÊñáÊú¨ÔºåÂéüÂßãÈïøÂ∫¶:', htmlContent.length);
                
                // ÁßªÈô§ËÑöÊú¨ÂíåÊ†∑ÂºèÊ†áÁ≠æÂèäÂÖ∂ÂÜÖÂÆπ
                let cleanText = htmlContent
                    .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
                    .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
                    .replace(/<head[^>]*>[\s\S]*?<\/head>/gi, '');
                
                // ÁßªÈô§ÊâÄÊúâHTMLÊ†áÁ≠æ
                cleanText = cleanText.replace(/<[^>]*>/g, ' ');
                
                // Ëß£Á†ÅHTMLÂÆû‰Ωì
                cleanText = cleanText
                    .replace(/&nbsp;/g, ' ')
                    .replace(/&amp;/g, '&')
                    .replace(/&lt;/g, '<')
                    .replace(/&gt;/g, '>')
                    .replace(/&quot;/g, '"')
                    .replace(/&#39;/g, "'")
                    .replace(/&hellip;/g, '...');
                
                // Ê∏ÖÁêÜÂ§ö‰ΩôÁöÑÁ©∫ÁôΩÂ≠óÁ¨¶
                cleanText = cleanText
                    .replace(/\s+/g, ' ')  // Â§ö‰∏™Á©∫Ê†ºÂèòÊàêÂçï‰∏™Á©∫Ê†º
                    .replace(/\n\s*\n/g, '\n\n')  // ‰øùÁïôÊÆµËêΩÂàÜÈöî
                    .trim();
                
                console.log('‚úÖ HTMLÊñáÊú¨ÊèêÂèñÂÆåÊàêÔºåÊ∏ÖÁêÜÂêéÈïøÂ∫¶:', cleanText.length);
                console.log('üìù ÊèêÂèñÁöÑÊñáÊú¨È¢ÑËßà:', cleanText.substring(0, 300));
                
                return cleanText;
            } catch (error) {
                console.error('‚ùå HTMLÊñáÊú¨ÊèêÂèñÂ§±Ë¥•:', error);
                return htmlContent; // Â§±Ë¥•Êó∂ËøîÂõûÂéüÂßãÂÜÖÂÆπ
            }
        }

        // üìÑ ÊîπËøõÁöÑÊñáÊú¨Êñá‰ª∂Â§ÑÁêÜ
        async function extractTextFromFile(file) {
            console.log('üìù ÊèêÂèñÊñáÊú¨Êñá‰ª∂ÂÜÖÂÆπ:', file.name);
            
            try {
                if (file.type === 'application/pdf') {
                    return await extractTextFromPDF(file);
                }
                
                // Â§ÑÁêÜÊñáÊú¨Á±ªÂûãÊñá‰ª∂
                if (file.type.includes('text') || 
                    file.name.endsWith('.md') || 
                    file.name.endsWith('.txt') || 
                    file.name.endsWith('.json') || 
                    file.name.endsWith('.csv') ||
                    file.name.endsWith('.yaml') ||
                    file.name.endsWith('.yml') ||
                    file.name.endsWith('.html') ||
                    file.name.endsWith('.htm')) {
                    
                    let text = await file.text();
                    
                    // üî• Ê£ÄÊü•ÊòØÂê¶ÊòØHTMLÂÜÖÂÆπÂπ∂ËøõË°åÂ§ÑÁêÜ
                    if (text.includes('<!DOCTYPE html') || text.includes('<html') || file.name.endsWith('.html') || file.name.endsWith('.htm')) {
                        console.log('üîß Ê£ÄÊµãÂà∞HTMLÂÜÖÂÆπÔºåËøõË°åÊñáÊú¨ÊèêÂèñ...');
                        text = extractTextFromHTML(text);
                    }
                    
                    console.log('‚úÖ ÊñáÊú¨ÂÜÖÂÆπÊèêÂèñÊàêÂäüÔºåÈïøÂ∫¶:', text.length);
                    return text;
                }
                
                // ÂØπ‰∫éÂÖ∂‰ªñÊñá‰ª∂Á±ªÂûãÔºåÊèê‰æõÊô∫ËÉΩÊñá‰ª∂‰ø°ÊÅØ
                const fileInfo = `üìÅ ${file.name}

üìä Êñá‰ª∂‰ø°ÊÅØ:
‚Ä¢ Êñá‰ª∂Á±ªÂûã: ${file.type || 'Êú™Áü•Ê†ºÂºè'}
‚Ä¢ Êñá‰ª∂Â§ßÂ∞è: ${(file.size / 1024 / 1024).toFixed(2)} MB
‚Ä¢ ‰∏ä‰º†Êó∂Èó¥: ${new Date().toLocaleString()}

üß† Â§ÑÁêÜÁä∂ÊÄÅ:
ËØ•Êñá‰ª∂Â∑≤‰∏ä‰º†Âπ∂ÂáÜÂ§áËøõË°åAIÂàÜÊûê„ÄÇ
Ê†πÊçÆÊñá‰ª∂Á±ªÂûãÔºåGraphRAGÁ≥ªÁªüÂ∞Ü:
‚Ä¢ ËØÜÂà´Êñá‰ª∂Ê†ºÂºèÂíåÁªìÊûÑ
‚Ä¢ ÊèêÂèñÂèØÁî®ÁöÑÂÜÖÂÆπ‰ø°ÊÅØ
‚Ä¢ ÂàÜÊûêÊñá‰ª∂Âú®Áü•ËØÜ‰ΩìÁ≥ª‰∏≠ÁöÑ‰ΩçÁΩÆ

üí° Êü•ÁúãÂª∫ËÆÆ:
‚Ä¢ Á≠âÂæÖAIÂàÜÊûêÂÆåÊàêÂêéÊü•ÁúãÊô∫ËÉΩÊëòË¶Å
‚Ä¢ ÁÇπÂáª"Áî®Êú¨Âú∞Â∑•ÂÖ∑ÊâìÂºÄ"‰ΩøÁî®Áõ∏Â∫îÁ®ãÂ∫èÊü•Áúã
‚Ä¢ ÈÄöËøáÁü•ËØÜÂõæË∞±Êü•ÁúãÊñá‰ª∂ÂÖ≥ËÅîÂÖ≥Á≥ª

ËØ•Êñá‰ª∂‰ø°ÊÅØÂ∑≤‰øùÂ≠òÂà∞Áü•ËØÜÂ∫ì‰∏≠„ÄÇ`;
                
                return fileInfo;
                
            } catch (error) {
                console.error('‚ùå Êñá‰ª∂ÂÜÖÂÆπÊèêÂèñÂ§±Ë¥•:', error);
                return `Êñá‰ª∂: ${file.name}\nÊèêÂèñÂÜÖÂÆπÂ§±Ë¥•ÔºåËØ∑‰ΩøÁî®Êú¨Âú∞Â∑•ÂÖ∑ÊâìÂºÄ„ÄÇ`;
            }
        }
        
        // üß† Â≠òÂÇ®GraphRAGÂàÜÊûêÊï∞ÊçÆÔºàÁî®‰∫éÁü•ËØÜÂõæË∞±Ôºâ
        async function storeGraphRAGAnalysis(fileName, analysisResult) {
            console.log('üß† Â≠òÂÇ®GraphRAGÂàÜÊûêÊï∞ÊçÆ:', fileName);
            
            try {
                // Ëé∑ÂèñÁé∞ÊúâÁöÑÂàÜÊûêÊï∞ÊçÆÂ∫ì
                let analysisDB = JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}');
                
                // ÂàõÂª∫ÂàÜÊûêÊù°ÁõÆ
                const analysisEntry = {
                    fileName: fileName,
                    timestamp: new Date().toISOString(),
                    concepts: analysisResult.concepts || [],
                    entities: analysisResult.entities || [],
                    relationships: analysisResult.relationships || [],
                    communities: analysisResult.communities || [],
                    extractedContent: analysisResult.extractedContent || '',
                    confidence: analysisResult.confidence || 0,
                    knowledgeTreePath: analysisResult.positionSuggestion?.primarySuggestion?.path || '',
                    graphData: analysisResult.graphData || null,
                    // üî• ‰øùÂ≠òÂÆåÊï¥ÁöÑÂéüÂßãGraphRAGÂìçÂ∫î
                    rawAnalysis: analysisResult
                };
                
                // ‰ΩøÁî®Êñá‰ª∂ÂêçÂíåÊó∂Èó¥Êà≥‰Ωú‰∏∫ÂîØ‰∏ÄÈîÆ
                const entryKey = `${fileName}_${Date.now()}`;
                analysisDB[entryKey] = analysisEntry;
                
                // ‰øùÂ≠òÂà∞localStorage
                localStorage.setItem('graphRAGAnalysisDB', JSON.stringify(analysisDB));
                
                console.log('‚úÖ GraphRAGÂàÜÊûêÊï∞ÊçÆÂ∑≤Â≠òÂÇ®:', entryKey);
                console.log('üìä Êï∞ÊçÆÂ∫ì‰∏≠ÂÖ±Êúâ', Object.keys(analysisDB).length, 'Êù°ÂàÜÊûêËÆ∞ÂΩï');
                
            } catch (error) {
                console.error('‚ùå Â≠òÂÇ®GraphRAGÊï∞ÊçÆÂ§±Ë¥•:', error);
                throw error;
            }
        }
        
        // üî• Áü•ËØÜÂ∫ìÈù¢ÊùøÊéßÂà∂ÂáΩÊï∞Â∑≤Âú®ÂâçÈù¢ÂÆö‰πâÔºåËøôÈáåÂà†Èô§ÈáçÂ§çÂÆö‰πâ

        function closeKnowledgePanel() {
            console.log('üìö Closing knowledge panel...');
            const knowledgePanel = document.getElementById('knowledgePanel');
            const panelOverlay = document.getElementById('panelOverlay');
            
            if (knowledgePanel) {
                knowledgePanel.classList.remove('open');
            }
            
            if (panelOverlay) {
                panelOverlay.classList.remove('show');
            }
        }
        
        // üî• Êô∫ËÉΩÁâàÔºöÁªìÂêàAIÂàÜÊûêÁªìÊûúÂíåÁõ¥Êé•ÂÜÖÂÆπÂ≠òÂÇ®
        async function acceptSuggestion(fileName, suggestedPath) {
            console.log(`‚úÖ Êé•ÂèóAIÂª∫ËÆÆ: ${fileName} -> ${suggestedPath}`);
            
            try {
                // üîç Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â∑≤ÁªèË¢´Ëá™Âä®‰øùÂ≠ò‰∫Ü
                const knowledgeTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
                const pathParts = suggestedPath.split(/[/>]/).filter(p => p.trim());
                const mainCategory = pathParts[0] || 'Êô∫ËÉΩÂàÜÁ±ª';
                
                // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÂ≠òÂú®‰∫éÁü•ËØÜÊ†ë‰∏≠
                if (knowledgeTree[mainCategory] && knowledgeTree[mainCategory].files) {
                    const existingFile = knowledgeTree[mainCategory].files.find(f => f.name === fileName);
                    if (existingFile) {
                        console.log(`‚úÖ Êñá‰ª∂ "${fileName}" Â∑≤ÁªèÂ≠òÂú®‰∫éÁü•ËØÜÊ†ë‰∏≠ÔºåÁõ¥Êé•Ë∑≥ËΩ¨`);
                        showNotification(`‚úÖ Êñá‰ª∂ "${fileName}" Â∑≤Âú®Áü•ËØÜÊ†ë‰∏≠`);
                        
                        // Ë∑≥ËΩ¨Âà∞Áü•ËØÜÂ∫ì
                        setTimeout(() => {
                            openKnowledgePanel();
                            navigateToKnowledgeTree(mainCategory, fileName);
                        }, 500);
                        
                        // Ê∏ÖÁêÜ‰∏ä‰º†Âå∫Âüü
                        clearUploadArea();
                        return;
                    }
                }
                
                // Â¶ÇÊûúÊñá‰ª∂‰∏çÂ≠òÂú®ÔºåÂàôÊâßË°åÊ≠£Â∏∏ÁöÑ‰øùÂ≠òÊµÅÁ®ã
                console.log(`üìÑ Êñá‰ª∂ "${fileName}" ‰∏çÂ≠òÂú®‰∫éÁü•ËØÜÊ†ë‰∏≠ÔºåÊâßË°å‰øùÂ≠ò`);
                
                // üß† Ëé∑ÂèñAIÂàÜÊûêÁªìÊûúÔºàÁî®‰∫é‰ΩçÁΩÆÂÜ≥Á≠ñÂíåÂÜÖÂÆπÁêÜËß£Ôºâ
                const analysisResult = window.currentAnalysisResults?.[fileName];
                if (!analysisResult) {
                    showNotification(`‚ùå Êâæ‰∏çÂà∞AIÂàÜÊûêÁªìÊûú: ${fileName}`);
                    return;
                }
                
                // üìÑ Ëé∑ÂèñÂéüÂßãÊñá‰ª∂ÔºàÁî®‰∫éÂÆåÊï¥ÂÜÖÂÆπÂ≠òÂÇ®Ôºâ
                const fileInput = document.querySelector('input[type="file"]');
                const uploadedFiles = window.currentUploadedFiles || [];
                const originalFile = Array.from(fileInput?.files || []).find(f => f.name === fileName) || 
                                   uploadedFiles.find(f => f.name === fileName);
                
                if (!originalFile) {
                    showNotification(`‚ùå Êâæ‰∏çÂà∞ÂéüÂßãÊñá‰ª∂: ${fileName}`);
                    return;
                }
                
                // üî• ‰øùÂ≠òÂéüÂßãÊñá‰ª∂Âà∞Êú¨Âú∞ÔºàÁî®‰∫éÂêéÁª≠Áî®Êú¨Âú∞Â∑•ÂÖ∑ÊâìÂºÄÔºâ
                const fileStorageKey = await saveFileLocally(originalFile);
                
                // üî• ‰ΩøÁî®Áªü‰∏ÄÁöÑÊñ∞Áâà‰øùÂ≠òÂáΩÊï∞ÔºåÈÅøÂÖçÈáçÂ§çÂàÜÁ±ª
                await addFileWithAIGuidanceAndStorage(fileName, suggestedPath, analysisResult, originalFile, fileStorageKey);
                
                // ÊòæÁ§∫ÊàêÂäüÊ∂àÊÅØ
                showNotification(`‚úÖ AIÂ∑≤Â∞Ü "${fileName}" Êô∫ËÉΩÂàÜÁ±ªÂà∞ "${suggestedPath}"`);
                
                // Ë∑≥ËΩ¨Âà∞Áü•ËØÜÂ∫ì
                setTimeout(() => {
                    openKnowledgePanel();
                    navigateToKnowledgeTree(mainCategory, fileName);
                }, 500);
                
                // Ê∏ÖÁêÜ‰∏ä‰º†Âå∫Âüü
                clearUploadArea();
                
            } catch (error) {
                console.error('‚ùå Êô∫ËÉΩÂàÜÁ±ªÂ§±Ë¥•:', error);
                showNotification(`‚ùå Êô∫ËÉΩÂàÜÁ±ªÂ§±Ë¥•: ${error.message}`, 'error');
            }
        }
        
        // üî• Ë∂ÖÁÆÄÂçïÔºöÁõ¥Êé•ËØªÂèñÊñá‰ª∂ÂÜÖÂÆπ
        async function readFileDirectly(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    let content = e.target.result;
                    
                    // Â¶ÇÊûúÊòØPDFÔºåÁÆÄÂçïÊèêÂèñÊñáÊú¨
                    if (file.type === 'application/pdf') {
                        // ËøôÈáåÂèØ‰ª•Áî®ÁÆÄÂçïÁöÑÊñáÊú¨ÊèêÂèñÔºåÊàñËÄÖÁõ¥Êé•ÊòæÁ§∫"PDFÊñá‰ª∂Â∑≤‰∏ä‰º†"
                        console.log('üìÑ PDFÊñá‰ª∂ÔºåÊòæÁ§∫Âü∫Êú¨‰ø°ÊÅØ');
                        content = `PDFÊñá‰ª∂Ôºö${file.name}\nÂ§ßÂ∞èÔºö${(file.size/1024).toFixed(1)} KB\n‰∏ä‰º†Êó∂Èó¥Ôºö${new Date().toLocaleString()}\n\nËøôÊòØ‰∏Ä‰∏™PDFÊñá‰ª∂ÔºåÂÜÖÂÆπÂ∑≤ÊàêÂäü‰øùÂ≠òÂà∞Áü•ËØÜÊ†ë‰∏≠„ÄÇ`;
                    }
                    
                    resolve(content);
                };
                
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }
        
        // üéØ ÁÆÄÂåñÁâàÔºö‰∏Ä‰∏™Êñá‰ª∂Âè™ÂàõÂª∫‰∏Ä‰∏™‰∏ªË¶ÅÂàÜÁ±ª
        async function addFileWithAIGuidanceAndStorage(fileName, suggestedPath, analysisResult, originalFile, storageKey) {
            // üîí ÂÖ®Â±ÄÈîÅÔºöÈò≤Ê≠¢Âêå‰∏ÄÊñá‰ª∂Ë¢´Âπ∂ÂèëÂ§ÑÁêÜ
            const lockKey = `saving_${fileName}`;
            if (window[lockKey]) {
                console.log(`‚ö†Ô∏è Êñá‰ª∂ "${fileName}" Ê≠£Âú®‰øùÂ≠ò‰∏≠ÔºåË∑≥ËøáÈáçÂ§çÊìç‰Ωú`);
                return;
            }
            
            // üîí ËÆæÁΩÆÈîÅ
            window[lockKey] = true;
            
            try {
                console.log('üéØ ‰ΩøÁî®AIÂàÜÊûêÊô∫ËÉΩÊ∑ªÂä†Êñá‰ª∂:', fileName);
                console.log('üß† AIÂª∫ËÆÆÁöÑÂÆåÊï¥Ë∑ØÂæÑ:', suggestedPath);
                
                // üîç ‰∏•Ê†ºÊ£ÄÊü•ÔºöÊ£ÄÊü•localStorage‰∏≠ÊòØÂê¶Â∑≤Â≠òÂú®
                const knowledgeTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
                const pathParts = suggestedPath.split(/[/>]/).filter(p => p.trim());
                const mainCategory = pathParts[0]?.trim() || 'Êô∫ËÉΩÂàÜÁ±ª';
                
                // Ê£ÄÊü•ËØ•Êñá‰ª∂ÊòØÂê¶Â∑≤ÁªèÂ≠òÂú®‰∫é‰ªª‰ΩïÂàÜÁ±ª‰∏≠
                for (const [categoryName, categoryData] of Object.entries(knowledgeTree)) {
                    if (categoryData.files) {
                        const existingFile = categoryData.files.find(f => f.name === fileName);
                        if (existingFile) {
                            console.log(`‚úÖ Êñá‰ª∂ "${fileName}" Â∑≤Â≠òÂú®‰∫éÂàÜÁ±ª "${categoryName}" ‰∏≠ÔºåË∑≥Ëøá‰øùÂ≠ò`);
                            return;
                        }
                    }
                }
                
                console.log('üìÇ Á°ÆËÆ§Êñá‰ª∂‰∏çÂ≠òÂú®ÔºåÁªßÁª≠‰øùÂ≠òÊµÅÁ®ã');
                
                console.log('üìÇ ‰ΩøÁî®‰∏ªË¶ÅÂàÜÁ±ª:', mainCategory);
                
                // üèóÔ∏è Êü•ÊâæÊàñÂàõÂª∫‰∏ªË¶ÅÂàÜÁ±ª
                let categoryNode = findNodeByTitle(mainCategory);
                
                if (!categoryNode) {
                    console.log(`üÜï ÂàõÂª∫Êñ∞ÁöÑ‰∏ªË¶ÅÂàÜÁ±ª: ${mainCategory}`);
                    categoryNode = createIntelligentCategoryNode(mainCategory, {
                        aiSuggested: true,
                        concepts: analysisResult.concepts,
                        confidence: analysisResult.confidence
                    }, true); // üî• Êñ∞‰∏ä‰º†Êó∂ÊâçËá™Âä®Ê∑ªÂä†Âà∞DOM
                } else {
                    console.log(`‚úÖ ÊâæÂà∞Áé∞ÊúâÂàÜÁ±ª: ${mainCategory}`);
                }
                
                // üî• Áõ¥Êé•Âú®‰∏ªÂàÜÁ±ª‰∏ãÊ∑ªÂä†Êñá‰ª∂
                if (categoryNode) {
                    const fileNode = createIntelligentFileNodeWithStorage(fileName, analysisResult, originalFile, storageKey);
                    const childrenContainer = categoryNode.querySelector('.node-children');
                    if (childrenContainer) {
                        // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®ÂêåÂêçÊñá‰ª∂
                        const existingFile = Array.from(childrenContainer.children).find(child => {
                            const title = child.querySelector('.node-title');
                            return title && title.textContent.trim() === fileName;
                        });
                        
                        if (!existingFile) {
                            childrenContainer.appendChild(fileNode);
                            expandNodePath(categoryNode);
                            console.log(`‚úÖ Êñá‰ª∂ "${fileName}" Â∑≤Ê∑ªÂä†Âà∞ "${mainCategory}" ÂàÜÁ±ª`);
                            
                            // üî• Âè™ÊúâÂú®DOM‰∏≠ÊàêÂäüÊ∑ªÂä†Êñ∞Êñá‰ª∂ÂêéÊâç‰øùÂ≠òÂà∞localStorage
                            await saveFileToPeristentKnowledgeTree(mainCategory, fileName, analysisResult, originalFile, storageKey);
                        } else {
                            console.log(`‚ö†Ô∏è Êñá‰ª∂ "${fileName}" Â∑≤Â≠òÂú®‰∫é "${mainCategory}" ÂàÜÁ±ª‰∏≠ÔºåË∑≥Ëøá‰øùÂ≠ò`);
                        }
                    }
                }
                
            } catch (error) {
                console.error(`‚ùå ‰øùÂ≠òÊñá‰ª∂ "${fileName}" Â§±Ë¥•:`, error);
                throw error;
            } finally {
                // üîì ÈáäÊîæÈîÅ
                window[lockKey] = false;
                console.log(`üîì Â∑≤ÈáäÊîæÊñá‰ª∂ "${fileName}" ÁöÑ‰øùÂ≠òÈîÅ`);
            }
        }
        
        // üíæ Â∞ÜÊñá‰ª∂ÊåÅ‰πÖÂåñ‰øùÂ≠òÂà∞localStorageÁü•ËØÜÊ†ë
        async function saveFileToPeristentKnowledgeTree(categoryName, fileName, analysisResult, originalFile, storageKey) {
            console.log('üíæ ÊåÅ‰πÖÂåñ‰øùÂ≠òÊñá‰ª∂Âà∞Áü•ËØÜÊ†ë:', fileName, '->', categoryName);
            
            try {
                // Ëé∑ÂèñÁé∞ÊúâÁöÑÁü•ËØÜÊ†ëÁªìÊûÑ
                let knowledgeTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
                
                // Á°Æ‰øùÂàÜÁ±ªÂ≠òÂú®
                if (!knowledgeTree[categoryName]) {
                    knowledgeTree[categoryName] = {
                        type: 'category',
                        aiSuggested: true,
                        confidence: analysisResult.confidence || 0.8,
                        concepts: analysisResult.concepts || [],
                        files: [],
                        createdAt: new Date().toISOString()
                    };
                }
                
                // Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â∑≤Â≠òÂú®
                const existingFileIndex = knowledgeTree[categoryName].files.findIndex(f => f.name === fileName);
                
                // ÂàõÂª∫Êñá‰ª∂Êù°ÁõÆ
                const fileEntry = {
                    name: fileName,
                    type: originalFile.type,
                    size: originalFile.size,
                    storageKey: storageKey,
                    aiAnalysis: {
                        concepts: analysisResult.concepts || [],
                        entities: analysisResult.entities || [],
                        confidence: analysisResult.confidence || 0,
                        summary: analysisResult.extractedContent || '', // ‰øùÁïôÂÆåÊï¥ÂÜÖÂÆπ
                        knowledgeTreePath: analysisResult.positionSuggestion?.primarySuggestion?.path || ''
                    },
                    addedAt: new Date().toISOString(),
                    lastModified: new Date().toISOString()
                };
                
                if (existingFileIndex >= 0) {
                    // Êõ¥Êñ∞Áé∞ÊúâÊñá‰ª∂
                    knowledgeTree[categoryName].files[existingFileIndex] = fileEntry;
                    console.log('üîÑ Êõ¥Êñ∞Áé∞ÊúâÊñá‰ª∂:', fileName);
                } else {
                    // Ê∑ªÂä†Êñ∞Êñá‰ª∂
                    knowledgeTree[categoryName].files.push(fileEntry);
                    console.log('üìÑ Ê∑ªÂä†Êñ∞Êñá‰ª∂:', fileName);
                }
                
                // ‰øùÂ≠òÂà∞localStorage
                localStorage.setItem('intelligentWorkflowKnowledgeTree', JSON.stringify(knowledgeTree));
                
                console.log('‚úÖ Êñá‰ª∂Â∑≤ÊåÅ‰πÖÂåñ‰øùÂ≠òÂà∞Áü•ËØÜÊ†ë');
                console.log('üìä Áü•ËØÜÊ†ëÂàÜÁ±ªÊï∞:', Object.keys(knowledgeTree).length);
                console.log('üìÅ ÂΩìÂâçÂàÜÁ±ªÊñá‰ª∂Êï∞:', knowledgeTree[categoryName].files.length);
                
            } catch (error) {
                console.error('‚ùå ÊåÅ‰πÖÂåñ‰øùÂ≠òÊñá‰ª∂Â§±Ë¥•:', error);
                throw error;
            }
        }
        
        // ü§ñ ÂàõÂª∫Â∏¶Â≠òÂÇ®ÈîÆÁöÑÊô∫ËÉΩÊñá‰ª∂ËäÇÁÇπ
        function createIntelligentFileNodeWithStorage(fileName, analysisResult, originalFile, storageKey) {
            const fileNode = document.createElement('div');
            fileNode.className = 'tree-node';
            
            const confidenceIcon = analysisResult.confidence > 0.8 ? 'üéØ' : 'üìÑ';
            
            fileNode.innerHTML = `
                <div class="node-content" onclick="openFileWithLocalTool(event, this)" draggable="true" 
                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                    <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                    <div class="node-icon file">${confidenceIcon}</div>
                    <div class="node-title" ondblclick="editNodeTitle(event, this)">${fileName}</div>
                    <div class="node-actions">
                        <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                        <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                        <button class="node-action" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                        <button class="node-action" onclick="showGraphRAGAnalysis(event, this)" title="Êü•ÁúãAIÂàÜÊûê">üß†</button>
                    </div>
                </div>
                <div class="node-children"></div>
            `;
            
            // üî• Â≠òÂÇ®ÂÆåÊï¥ÁöÑÊñá‰ª∂‰ø°ÊÅØÂíåAIÂàÜÊûê
            fileNode.setAttribute('data-file-name', fileName);
            fileNode.setAttribute('data-file-size', originalFile.size);
            fileNode.setAttribute('data-file-type', originalFile.type);
            fileNode.setAttribute('data-file-storage-key', storageKey);
            fileNode.setAttribute('data-ai-concepts', JSON.stringify(analysisResult.concepts || []));
            fileNode.setAttribute('data-ai-confidence', analysisResult.confidence || 0);
            fileNode.setAttribute('data-ai-summary', analysisResult.extractedContent || ''); // ‰øùÁïôÂÆåÊï¥ÂÜÖÂÆπ
            
            return fileNode;
        }
        
        // üéØ ÁªìÂêàAIÂàÜÊûêÁöÑÊô∫ËÉΩÊñá‰ª∂Ê∑ªÂä†
        async function addFileWithAIGuidance(fileName, suggestedPath, fileContent, analysisResult, originalFile) {
            console.log('üéØ ‰ΩøÁî®AIÂàÜÊûêÁªìÊûúÊô∫ËÉΩÊ∑ªÂä†Êñá‰ª∂:', fileName);
            console.log('üß† AIÂª∫ËÆÆË∑ØÂæÑ:', suggestedPath);
            console.log('üìã AIÊèêÂèñÁöÑÊ¶ÇÂøµ:', analysisResult.concepts);
            
            // Ëß£ÊûêAIÂª∫ËÆÆÁöÑË∑ØÂæÑ
            const pathParts = suggestedPath.split('/').filter(p => p.trim());
            
            // üèóÔ∏è Ê†πÊçÆAIÂàÜÊûêÈÄêÁ∫ßÂàõÂª∫/Êü•ÊâæË∑ØÂæÑ
            let currentNode = null;
            let currentPath = '';
            
            for (let i = 0; i < pathParts.length; i++) {
                const part = pathParts[i];
                currentPath += (currentPath ? ' > ' : '') + part;
                
                // Êü•ÊâæËøô‰∏ÄÁ∫ßÊòØÂê¶Â∑≤Â≠òÂú®
                let nodeAtLevel = findNodeByTitle(part);
                
                if (!nodeAtLevel) {
                    // ‰∏çÂ≠òÂú®ÂàôÂàõÂª∫
                    console.log(`üÜï AIÊåáÂØºÂàõÂª∫Á±ªÂà´: ${part} (Ë∑ØÂæÑ: ${currentPath})`);
                    nodeAtLevel = createIntelligentCategoryNode(part, {
                        aiSuggested: true,
                        concepts: analysisResult.concepts,
                        confidence: analysisResult.confidence
                    });
                    
                    if (currentNode) {
                        // Ê∑ªÂä†Âà∞Áà∂Á∫ßËäÇÁÇπ
                        const childrenContainer = currentNode.querySelector('.node-children');
                        if (childrenContainer) {
                            childrenContainer.appendChild(nodeAtLevel);
                        }
                    }
                } else {
                    console.log(`‚úÖ ÊâæÂà∞Áé∞ÊúâÁ±ªÂà´: ${part}`);
                }
                
                currentNode = nodeAtLevel;
            }
            
            // üî• Âú®ÊúÄÁªà‰ΩçÁΩÆÊ∑ªÂä†Êñá‰ª∂ÔºåÂ∏¶AIÂàÜÊûê‰ø°ÊÅØ
            if (currentNode) {
                console.log('üìÑ Âú®AIÂª∫ËÆÆ‰ΩçÁΩÆÂàõÂª∫Êñá‰ª∂ËäÇÁÇπ:', fileName);
                const fileNode = createIntelligentFileNode(fileName, fileContent, analysisResult, originalFile);
                
                const childrenContainer = currentNode.querySelector('.node-children');
                if (childrenContainer) {
                    childrenContainer.appendChild(fileNode);
                    
                    // Á°Æ‰øùË∑ØÂæÑÊòØÂ±ïÂºÄÁöÑ
                    expandNodePath(currentNode);
                }
            }
            
            console.log('‚úÖ AIÊåáÂØºÁöÑÊñá‰ª∂ÊîæÁΩÆÂÆåÊàê');
        }
        
        // üß† ÂàõÂª∫Â∏¶AI‰ø°ÊÅØÁöÑÊô∫ËÉΩÁ±ªÂà´ËäÇÁÇπÔºà‰∏çËá™Âä®Ê∑ªÂä†Âà∞DOMÔºâ
        function createIntelligentCategoryNode(categoryName, aiData, autoAppend = false) {
            const categoryNode = document.createElement('div');
            categoryNode.className = 'tree-node';
            
            const confidenceIcon = aiData.confidence > 0.8 ? 'üéØ' : 'üìÅ';
            
            categoryNode.innerHTML = `
                <div class="node-content" onclick="selectNode(this, event)" draggable="true" 
                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                    <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                    <div class="node-icon folder">${confidenceIcon}</div>
                    <div class="node-title" ondblclick="editNodeTitle(event, this)">${categoryName}</div>
                    <div class="node-actions">
                        <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                        <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                        <button class="node-action" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                    </div>
                </div>
                <div class="node-children"></div>
            `;
            
            // üî• Âè™Âú®ÊòéÁ°ÆÊåáÂÆöÊó∂ÊâçËá™Âä®Ê∑ªÂä†Âà∞Áü•ËØÜÊ†ëÊ†πÈÉ®
            if (autoAppend) {
                const knowledgeTree = document.getElementById('knowledgeTree');
                if (knowledgeTree) {
                    knowledgeTree.appendChild(categoryNode);
                    console.log('‚úÖ ÂàÜÁ±ªËäÇÁÇπÂ∑≤Ê∑ªÂä†Âà∞Áü•ËØÜÊ†ë:', categoryName);
                }
            }
            
            return categoryNode;
        }
        
        // ü§ñ ÂàõÂª∫Â∏¶AIÂàÜÊûêÁöÑÊô∫ËÉΩÊñá‰ª∂ËäÇÁÇπ
        function createIntelligentFileNode(fileName, content, analysisResult, originalFile) {
            const fileNode = document.createElement('div');
            fileNode.className = 'tree-node';
            
            // Ê†πÊçÆAIÂàÜÊûêÈÄâÊã©ÂõæÊ†á
            const confidenceIcon = analysisResult.confidence > 0.8 ? 'üéØ' : 'üìÑ';
            
            fileNode.innerHTML = `
                <div class="node-content" onclick="openFileWithLocalTool(event, this)" draggable="true" 
                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                    <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                    <div class="node-icon file">${confidenceIcon}</div>
                    <div class="node-title" ondblclick="editNodeTitle(event, this)">${fileName}</div>
                    <div class="node-actions">
                        <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                        <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                        <button class="node-action" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                        <button class="node-action" onclick="showGraphRAGAnalysis(event, this)" title="Êü•ÁúãAIÂàÜÊûê">üß†</button>
                    </div>
                </div>
                <div class="node-children"></div>
            `;
            
            // üî• Â≠òÂÇ®Êñá‰ª∂ÂºïÁî®ÂíåAIÂàÜÊûêÁªìÊûú
            fileNode.setAttribute('data-file-name', fileName);
            fileNode.setAttribute('data-file-size', originalFile.size);
            fileNode.setAttribute('data-file-type', originalFile.type);
            fileNode.setAttribute('data-ai-concepts', JSON.stringify(analysisResult.concepts));
            fileNode.setAttribute('data-ai-confidence', analysisResult.confidence);
            fileNode.setAttribute('data-ai-summary', analysisResult.extractedContent || ''); // ‰øùÁïôÂÆåÊï¥ÂÜÖÂÆπ
            // üî• Â≠òÂÇ®Êñá‰ª∂Â≠òÂÇ®ÈîÆÔºåÁî®‰∫éÊ£ÄÁ¥¢ÂéüÂßãÊñá‰ª∂
            fileNode.setAttribute('data-file-storage-key', `file_${fileName}_${Date.now()}`);
            
            return fileNode;
        }
        
        // Â±ïÂºÄËäÇÁÇπË∑ØÂæÑ
        function expandNodePath(node) {
            const expandBtn = node.querySelector('.node-expand');
            const childrenContainer = node.querySelector('.node-children');
            
            if (expandBtn && childrenContainer) {
                expandBtn.textContent = '‚ñº';
                childrenContainer.style.display = 'block';
            }
        }
        
        // üî• Ë∂ÖÁÆÄÂçïÔºöÁõ¥Êé•Ê∑ªÂä†Êñá‰ª∂Âà∞Áü•ËØÜÊ†ë
        async function addFileDirectlyToKnowledgeTree(fileName, suggestedPath, fileContent, originalFile) {
            console.log('üìÅ Áõ¥Êé•Ê∑ªÂä†Êñá‰ª∂Âà∞Áü•ËØÜÊ†ë:', fileName);
            
            // Ëé∑ÂèñË∑ØÂæÑÁöÑÁ¨¨‰∏ÄÈÉ®ÂàÜ‰Ωú‰∏∫Á±ªÂà´
            const pathParts = suggestedPath.split('/').filter(p => p.trim());
            const categoryName = pathParts[0] || 'Êú™ÂàÜÁ±ª';
            
            // Êü•ÊâæÊàñÂàõÂª∫Á±ªÂà´ËäÇÁÇπ
            let categoryNode = findNodeByTitle(categoryName);
            
            if (!categoryNode) {
                console.log('üÜï ÂàõÂª∫Êñ∞Á±ªÂà´:', categoryName);
                categoryNode = createNewCategoryNode(categoryName, {});
            }
            
            // ÂàõÂª∫Êñá‰ª∂ËäÇÁÇπÂπ∂Ê∑ªÂä†Âà∞Á±ªÂà´‰∏≠
            console.log('üìÑ ÂàõÂª∫Êñá‰ª∂ËäÇÁÇπ:', fileName);
            const fileNode = createSimpleFileNode(fileName, fileContent, originalFile);
            
            const childrenContainer = categoryNode.querySelector('.node-children');
            if (childrenContainer) {
                childrenContainer.appendChild(fileNode);
                
                // Á°Æ‰øùÁ±ªÂà´ÊòØÂ±ïÂºÄÁöÑÔºåÂèØ‰ª•ÁúãÂà∞Êñ∞Êñá‰ª∂
                const expandBtn = categoryNode.querySelector('.node-expand');
                if (expandBtn) {
                    expandBtn.textContent = '‚ñº';
                    childrenContainer.style.display = 'block';
                }
            }
            
            console.log('‚úÖ Êñá‰ª∂Â∑≤Áõ¥Êé•Ê∑ªÂä†Âà∞Áü•ËØÜÊ†ë');
        }
        
        // üî• ÂàõÂª∫ÁÆÄÂçïÁöÑÊñá‰ª∂ËäÇÁÇπ
        function createSimpleFileNode(fileName, content, originalFile) {
            const fileNode = document.createElement('div');
            fileNode.className = 'tree-node';
            fileNode.innerHTML = `
                <div class="node-content" onclick="openFileWithLocalTool(event, this)" draggable="true" 
                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                    <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                    <div class="node-icon file">üìÑ</div>
                    <div class="node-title" ondblclick="editNodeTitle(event, this)">${fileName}</div>
                    <div class="node-actions">
                        <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                        <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                        <button class="node-action" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                    </div>
                </div>
                <div class="node-children"></div>
            `;
            
            // üî• Áõ¥Êé•Â≠òÂÇ®Êñá‰ª∂ÂÜÖÂÆπÂà∞DOMÂÖÉÁ¥†
            fileNode.setAttribute('data-file-content', content);
            fileNode.setAttribute('data-file-name', fileName);
            fileNode.setAttribute('data-file-size', originalFile.size);
            
            return fileNode;
        }
        
        // üíª ‰ΩøÁî®Êú¨Âú∞Â∑•ÂÖ∑ÊâìÂºÄÊñá‰ª∂
        window.openFileWithLocalTool = function(event, nodeContent) {
            event.stopPropagation();
            
            // Èò≤Ê≠¢ÁÇπÂáªÊìç‰ΩúÊåâÈíÆÊó∂Ëß¶Âèë
            if (event.target.classList.contains('node-action') || 
                event.target.closest('.node-actions')) {
                return;
            }
            
            const nodeElement = nodeContent.closest('.tree-node');
            const fileName = nodeElement.getAttribute('data-file-name');
            const fileType = nodeElement.getAttribute('data-file-type');
            const storageKey = nodeElement.getAttribute('data-file-storage-key');
            
            console.log('üíª Â∞ùËØïÁî®Êú¨Âú∞Â∑•ÂÖ∑ÊâìÂºÄÊñá‰ª∂:', fileName);
            console.log('üîë ‰ΩøÁî®Â≠òÂÇ®ÈîÆ:', storageKey);
            
            try {
                // üî• ‰ªélocalStorageËé∑ÂèñÊñá‰ª∂Êï∞ÊçÆ
                const fileDataStr = localStorage.getItem(storageKey);
                console.log('üíæ localStorage‰∏≠ÁöÑÊï∞ÊçÆ:', fileDataStr ? 'Â≠òÂú®' : '‰∏çÂ≠òÂú®');
                
                if (!fileDataStr) {
                    console.error('‚ùå Êñá‰ª∂Êï∞ÊçÆ‰∏çÂ≠òÂú®ÔºåÂ≠òÂÇ®ÈîÆ:', storageKey);
                    
                    // üîç Â∞ùËØïÊü•ÊâæÊâÄÊúâÂèØËÉΩÁöÑÂ≠òÂÇ®ÈîÆ
                    const allKeys = Object.keys(localStorage);
                    const fileKeys = allKeys.filter(key => key.startsWith('file_') && key.includes(fileName));
                    console.log('üîç ÊâæÂà∞ÁöÑÁõ∏ÂÖ≥Êñá‰ª∂ÈîÆ:', fileKeys);
                    
                    if (fileKeys.length > 0) {
                        // ‰ΩøÁî®ÊâæÂà∞ÁöÑÁ¨¨‰∏Ä‰∏™ÈîÆÈáçËØï
                        const alternativeKey = fileKeys[0];
                        const alternativeData = localStorage.getItem(alternativeKey);
                        console.log('üîÑ ‰ΩøÁî®Êõø‰ª£ÈîÆ:', alternativeKey);
                        
                        if (alternativeData) {
                            const fileData = JSON.parse(alternativeData);
                            console.log('‚úÖ ‰ΩøÁî®Êõø‰ª£Êï∞ÊçÆÊàêÂäü');
                            showIntelligentFileModal(fileName, fileData);
                            return;
                        }
                    }
                    
                    showNotification(`‚ùå Êñá‰ª∂Êï∞ÊçÆ‰∏çÂ≠òÂú®ÔºåËØ∑ÈáçÊñ∞‰∏ä‰º†`, 'warning');
                    return;
                }
                
                const fileData = JSON.parse(fileDataStr);
                console.log('üìÑ Ëß£ÊûêÁöÑÊñá‰ª∂Êï∞ÊçÆ:', {
                    hasTextContent: !!fileData.textContent,
                    textContentLength: fileData.textContent?.length || 0,
                    hasLocalContent: !!fileData.hasLocalContent,
                    dataSize: fileData.data?.length || 0,
                    fileSize: fileData.size,
                    fileName: fileData.name
                });
                
                // üî• Ë∞ÉÁî®Êô∫ËÉΩÊñá‰ª∂È¢ÑËßàÊ®°ÊÄÅÊ°Ü
                showIntelligentFileModal(fileName, fileData);
                
            } catch (error) {
                console.error('‚ùå ÊâìÂºÄÊñá‰ª∂Â§±Ë¥•:', error);
                showNotification(`‚ùå ÊâìÂºÄÊñá‰ª∂Â§±Ë¥•: ${error.message}`, 'error');
            }
        };
        
        // üß† ÊòæÁ§∫GraphRAGÂàÜÊûêÁªìÊûú
        window.showGraphRAGAnalysis = function(event, buttonElement) {
            event.stopPropagation();
            
            const nodeElement = buttonElement.closest('.tree-node');
            const fileName = nodeElement.getAttribute('data-file-name');
            const concepts = JSON.parse(nodeElement.getAttribute('data-ai-concepts') || '[]');
            const confidence = nodeElement.getAttribute('data-ai-confidence');
            const summary = nodeElement.getAttribute('data-ai-summary');
            
            console.log('üß† ÊòæÁ§∫GraphRAGÂàÜÊûêÁªìÊûú:', fileName);
            
            // üîç ‰ªéÂàÜÊûêÊï∞ÊçÆÂ∫ìËé∑ÂèñÂÆåÊï¥Êï∞ÊçÆ
            const analysisDB = JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}');
            let fullAnalysis = null;
            
            // Êü•ÊâæÂåπÈÖçÁöÑÂàÜÊûêËÆ∞ÂΩï
            for (const key in analysisDB) {
                if (analysisDB[key].fileName === fileName) {
                    fullAnalysis = analysisDB[key];
                    break;
                }
            }
            
            // ÂàõÂª∫ÂàÜÊûêÁªìÊûúÊòæÁ§∫Ê®°ÊÄÅÊ°Ü
            const modal = document.createElement('div');
            modal.className = 'analysis-modal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.7); z-index: 6000; display: flex; 
                align-items: center; justify-content: center;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white; padding: 32px; border-radius: 16px; 
                width: 700px; max-width: 90vw; max-height: 80vh; overflow-y: auto;
                box-shadow: 0 20px 60px rgba(0,0,0,0.4);
            `;
            
            modalContent.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3 style="margin: 0; color: #1f2937;">üß† GraphRAG ÂàÜÊûêÁªìÊûú</h3>
                    <button onclick="this.closest('.analysis-modal').remove()" 
                            style="background: none; border: none; font-size: 24px; cursor: pointer;">√ó</button>
                </div>
                
                <div style="margin-bottom: 20px; padding: 16px; background: #f8fafc; border-radius: 8px;">
                    <h4 style="margin: 0 0 8px 0; color: #374151;">üìÑ Êñá‰ª∂‰ø°ÊÅØ</h4>
                    <p style="margin: 4px 0; color: #6b7280;">Êñá‰ª∂Âêç: ${fileName}</p>
                    <p style="margin: 4px 0; color: #6b7280;">ÂàÜÊûêÊó∂Èó¥: ${fullAnalysis?.timestamp || 'Êú™Áü•'}</p>
                    <p style="margin: 4px 0; color: #6b7280;">ÁΩÆ‰ø°Â∫¶: ${safePercent(confidence)}%</p>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <h4 style="margin: 0 0 12px 0; color: #374151;">üè∑Ô∏è ËØÜÂà´ÁöÑÊ¶ÇÂøµ</h4>
                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                        ${concepts.map(concept => `
                            <span style="background: #dbeafe; color: #1e40af; padding: 4px 8px; border-radius: 4px; font-size: 12px;">
                                ${concept}
                            </span>
                        `).join('')}
                    </div>
                </div>
                
                ${fullAnalysis?.entities ? `
                <div style="margin-bottom: 20px;">
                    <h4 style="margin: 0 0 12px 0; color: #374151;">üë• ËØÜÂà´ÁöÑÂÆû‰Ωì</h4>
                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                        ${fullAnalysis.entities.map(entity => `
                            <span style="background: #dcfce7; color: #166534; padding: 4px 8px; border-radius: 4px; font-size: 12px;">
                                ${entity}
                            </span>
                        `).join('')}
                    </div>
                </div>
                ` : ''}
                
                <div style="margin-bottom: 20px;">
                    <h4 style="margin: 0 0 12px 0; color: #374151;">üìç Êô∫ËÉΩÂàÜÁ±ªË∑ØÂæÑ</h4>
                    <p style="background: #fef3c7; color: #92400e; padding: 12px; border-radius: 8px; margin: 0;">
                        ${fullAnalysis?.knowledgeTreePath || 'Êú™Áü•'}
                    </p>
                </div>
                
                <div>
                    <h4 style="margin: 0 0 12px 0; color: #374151;">üìù ÂÜÖÂÆπÊëòË¶Å</h4>
                    <div style="background: #f9fafb; padding: 16px; border-radius: 8px; border-left: 4px solid #3b82f6; max-height: 300px; overflow-y: auto;">
                        ${fullAnalysis?.extractedContent || summary || 'ÊöÇÊó†ÊëòË¶Å'}
                    </div>
                </div>
                
                <div style="text-align: center; margin-top: 24px;">
                    <button onclick="this.closest('.analysis-modal').remove()" 
                            style="background: #3b82f6; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                        ÂÖ≥Èó≠
                    </button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
        };
        
        // üî• Êñ∞ÂáΩÊï∞ÔºöÁõ¥Êé•Ê∑ªÂä†Â∑≤ÂàÜÊûêÁöÑÊñá‰ª∂Âà∞Áü•ËØÜÂ∫ì
        async function addAnalyzedFileToKnowledgeTree(analysisResult, suggestedPath, fileName) {
            console.log('üìÅ Adding analyzed file to knowledge tree:', fileName, '->', suggestedPath);
            
            // Ëß£ÊûêË∑ØÂæÑ
            const pathParts = suggestedPath.split('/').filter(part => part.trim());
            
            // ÂàõÂª∫Áü•ËØÜÂ∫ìÊù°ÁõÆÔºå‰ΩøÁî®Â∑≤ÂàÜÊûêÁöÑÂÜÖÂÆπ
            const knowledgeEntry = {
                id: generateUniqueId(),
                name: fileName,
                content: analysisResult.extractedContent || 'ÊñáÊ°£ÂÜÖÂÆπËß£ÊûêÂÆåÊàê',
                path: suggestedPath,
                pathParts: pathParts,
                type: analysisResult.fileType || 'unknown',
                size: analysisResult.fileSize || 0,
                uploadDate: new Date().toISOString(),
                lastModified: new Date().toISOString(),
                // ÈôÑÂä†AIÂàÜÊûêÁªìÊûú
                aiAnalysis: {
                    concepts: analysisResult.concepts || [],
                    entities: analysisResult.entities || [],
                    confidence: analysisResult.confidence || 0.8,
                    summary: analysisResult.extractedContent || ''
                }
            };
            
            // Ê∑ªÂä†Âà∞Áü•ËØÜÂ∫ìÂ≠òÂÇ®
            await saveToKnowledgeBase(knowledgeEntry);
            console.log('üíæ File saved to knowledge base');
            
            // üî• ‰∏çÂÜçÈúÄË¶ÅÂà∑Êñ∞Êï¥‰∏™Áü•ËØÜÊ†ëÔºåÂõ†‰∏∫Êñá‰ª∂Â∑≤Áõ¥Êé•Ê∑ªÂä†Âà∞DOM
            console.log('‚úÖ Êñá‰ª∂Â∑≤Ê∑ªÂä†Âà∞Áü•ËØÜÊ†ëÔºåÊó†ÈúÄÈáçÊñ∞ÁîüÊàê');
            
            console.log('‚úÖ Analyzed file successfully added to knowledge base');
        }
        
        // Â∞ÜÊñá‰ª∂Ê∑ªÂä†Âà∞Áü•ËØÜÊ†ë
        async function addFileToKnowledgeTree(file, suggestedPath, fileName) {
            console.log('üìÅ Adding file to knowledge tree:', fileName, '->', suggestedPath);
            
            // ËØªÂèñÊñá‰ª∂ÂÜÖÂÆπ
            const content = await readFileContent(file);
            
            // Ëß£ÊûêË∑ØÂæÑ
            const pathParts = suggestedPath.split('/').filter(part => part.trim());
            
            // ÂàõÂª∫ÊàñËé∑ÂèñÁü•ËØÜÂ∫ìÊù°ÁõÆ
            const knowledgeEntry = {
                id: generateUniqueId(),
                name: fileName,
                content: content,
                path: suggestedPath,
                pathParts: pathParts,
                type: getFileType(file),
                size: file.size,
                uploadDate: new Date().toISOString(),
                lastModified: file.lastModified ? new Date(file.lastModified).toISOString() : new Date().toISOString()
            };
            
            // Ê∑ªÂä†Âà∞Áü•ËØÜÂ∫ìÂ≠òÂÇ®
            await saveToKnowledgeBase(knowledgeEntry);
            
            console.log('‚úÖ File successfully added to knowledge base');
        }
        
        // ËØªÂèñÂπ∂Ëß£ÊûêÊñá‰ª∂ÂÜÖÂÆπ
        async function readFileContent(file) {
            console.log('üìÑ Reading file content:', file.name, 'Type:', file.type);
            
            // ÂØπ‰∫éPDFÊñá‰ª∂Ôºå‰ΩøÁî®PDF.jsËß£Êûê
            if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {
                console.log('üîç Detected PDF file, using PDF parsing');
                return await extractPDFText(file);
            }
            
            // ÂØπ‰∫éÂÖ∂‰ªñÊñáÊú¨Êñá‰ª∂Ôºå‰ΩøÁî®ÊôÆÈÄöÊñáÊú¨ËØªÂèñ
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => {
                    const content = e.target.result || '';
                    console.log(`üìù Text file content extracted: ${content.length} characters`);
                    resolve(content);
                };
                reader.onerror = e => {
                    console.error('‚ùå Failed to read file content:', e);
                    resolve(''); // ËøîÂõûÁ©∫Â≠óÁ¨¶‰∏≤ËÄå‰∏çÊòØreject
                };
                reader.readAsText(file);
            });
        }
        
        // ‰ªéPDFÊñá‰ª∂‰∏≠ÊèêÂèñÊñáÊú¨ÂÜÖÂÆπ - ‰ΩøÁî®PDF.js
        async function extractPDFText(file) {
            try {
                console.log('üìñ Starting PDF text extraction using PDF.js for:', file.name);
                
                const arrayBuffer = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
                
                // ÈÖçÁΩÆPDF.js worker
                if (typeof pdfjsLib !== 'undefined') {
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                    
                    // Âä†ËΩΩPDFÊñáÊ°£
                    const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                    console.log('üìñ PDF loaded successfully, total pages:', pdf.numPages);
                    
                    let fullText = '';
                    
                    // ÈÅçÂéÜÊâÄÊúâÈ°µÈù¢ÊèêÂèñÊñáÊú¨
                    for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                        try {
                            const page = await pdf.getPage(pageNum);
                            const textContent = await page.getTextContent();
                            
                            const pageText = textContent.items.map(item => item.str).join(' ');
                            fullText += pageText + '\n\n';
                            
                            console.log(`‚úÖ Page ${pageNum} extracted: ${pageText.length} characters`);
                        } catch (pageError) {
                            console.error(`‚ùå Error extracting page ${pageNum}:`, pageError);
                            fullText += `[Page ${pageNum} extraction failed]\n\n`;
                        }
                    }
                    
                    console.log('‚úÖ PDF text extraction completed:', fullText.length, 'total characters');
                    return fullText.trim();
                } else {
                    console.error('‚ùå PDF.js not available, falling back to simple extraction');
                    return await fallbackPDFExtraction(arrayBuffer);
                }
                
            } catch (error) {
                console.error('‚ùå PDF text extraction failed:', error);
                return `PDFÊñá‰ª∂: ${file.name} (ÊèêÂèñÂ§±Ë¥•: ${error.message})`;
            }
        }
        
        // Â§áÁî®PDFÊèêÂèñÊñπÊ≥ï
        async function fallbackPDFExtraction(arrayBuffer) {
            try {
                const uint8Array = new Uint8Array(arrayBuffer);
                const decoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: false });
                const pdfString = decoder.decode(uint8Array);
                
                let text = '';
                
                // Êü•ÊâæÊñáÊú¨ÂÜÖÂÆπÁöÑÁÆÄÂçïÊ≠£ÂàôË°®ËææÂºè
                const textMatches = pdfString.match(/BT\s+.*?\s+ET/gs);
                if (textMatches) {
                    for (const match of textMatches) {
                        const textContent = match.match(/\((.*?)\)/g);
                        if (textContent) {
                            textContent.forEach(t => {
                                text += t.replace(/[()]/g, '') + ' ';
                            });
                        }
                    }
                }
                
                if (text.length < 50) {
                    const lines = pdfString.split('\n');
                    for (const line of lines) {
                        if (line.length > 10 && 
                            !line.match(/^[<>%\d\s]+$/) &&
                            !line.includes('obj') &&
                            !line.includes('endobj') &&
                            !line.includes('stream') &&
                            !line.includes('endstream')) {
                            
                            const cleanLine = line.replace(/[^\w\s\u4e00-\u9fff.,!?;:()\-]/g, '').trim();
                            if (cleanLine.length > 5) {
                                text += cleanLine + '\n';
                            }
                        }
                    }
                }
                
                console.log(`‚úÖ Fallback PDF text extraction completed: ${text.length} characters`);
                
                if (text.length < 50) {
                    return `PDFÊñá‰ª∂Ôºö${file.name}\n\nÊèêÂèñÁöÑÊñáÊú¨ÂÜÖÂÆπËæÉÂ∞ë„ÄÇËøôÂèØËÉΩÊòØÂõ†‰∏∫PDFÂåÖÂê´ÂõæÁâá„ÄÅÊâ´ÊèèÂÜÖÂÆπÊàñÁâπÊÆäÊ†ºÂºè„ÄÇ\n\nÂª∫ËÆÆÔºö\n- Â¶ÇÊûúÊòØÊâ´ÊèèPDFÔºåËØ∑‰ΩøÁî®OCRÂ∑•ÂÖ∑ËΩ¨Êç¢\n- Â¶ÇÊûúÊòØÂä†ÂØÜPDFÔºåËØ∑ÂÖàËß£ÈîÅ\n- ÂèØ‰ª•ÊâãÂä®Â§çÂà∂Á≤òË¥¥ÊñáÊú¨ÂÜÖÂÆπÂà∞ÁºñËæëÊ°Ü`;
                }
                
                return text.trim();
                
            } catch (error) {
                console.error('‚ùå Fallback PDF text extraction failed:', error);
                return `PDFÊñá‰ª∂Ôºö${file.name}\n\nPDFÊñáÊú¨ÊèêÂèñÂ§±Ë¥•Ôºö${error.message}\n\nÂª∫ËÆÆÔºö\n- Ê£ÄÊü•PDFÊñá‰ª∂ÊòØÂê¶ÂÆåÊï¥\n- Â∞ùËØïÈáçÊñ∞‰∏ä‰º†\n- ÂèØ‰ª•ÊâãÂä®Â§çÂà∂Á≤òË¥¥ÊñáÊú¨ÂÜÖÂÆπ`;
            }
        }
        
        // ‰øùÂ≠òÂà∞Áü•ËØÜÂ∫ì
        async function saveToKnowledgeBase(entry) {
            console.log('üíæ ‰øùÂ≠òÊñá‰ª∂Âà∞Áü•ËØÜÂ∫ì:', entry.name, 'Ë∑ØÂæÑ:', entry.path);
            
            // Ëé∑ÂèñÁé∞ÊúâÁöÑÁü•ËØÜÂ∫ìÊï∞ÊçÆÔºåÁ°Æ‰øù‰øùÊåÅÂéüÊúâÁªìÊûÑ
            let knowledgeBase = JSON.parse(localStorage.getItem('intelligentWorkflowKB') || '{}');
            console.log('üìö Áé∞ÊúâÁü•ËØÜÂ∫ìÁªìÊûÑ:', Object.keys(knowledgeBase));
            
            // ÊåâË∑ØÂæÑÁªÑÁªáÊï∞ÊçÆ - ÁÆÄÂåñÁâàÊú¨ÔºåÁõ¥Êé•Ê∑ªÂä†Âà∞È°∂Á∫ßÁ±ªÂà´
            const pathParts = entry.pathParts;
            const categoryName = pathParts[0]; // ‰ΩøÁî®Á¨¨‰∏ÄÁ∫ß‰Ωú‰∏∫‰∏ªË¶ÅÁ±ªÂà´
            
            // Á°Æ‰øùÁ±ªÂà´Â≠òÂú®
            if (!knowledgeBase[categoryName]) {
                console.log('üÜï ÂàõÂª∫Êñ∞Á±ªÂà´:', categoryName);
                knowledgeBase[categoryName] = {
                    _metadata: {
                        type: 'folder',
                        created: new Date().toISOString()
                    },
                    files: [],
                    children: {}
                };
            }
            
            // Á°Æ‰øùfilesÊï∞ÁªÑÂ≠òÂú®
            if (!knowledgeBase[categoryName].files) {
                knowledgeBase[categoryName].files = [];
            }
            
            // Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â∑≤Â≠òÂú®ÔºàÈÅøÂÖçÈáçÂ§çÔºâ
            const existingFileIndex = knowledgeBase[categoryName].files.findIndex(f => f.name === entry.name);
            if (existingFileIndex >= 0) {
                console.log('üîÑ Êõ¥Êñ∞Áé∞ÊúâÊñá‰ª∂:', entry.name);
                knowledgeBase[categoryName].files[existingFileIndex] = entry;
            } else {
                console.log('üìÑ Ê∑ªÂä†Êñ∞Êñá‰ª∂:', entry.name);
                knowledgeBase[categoryName].files.push(entry);
            }
            
            // ‰øùÂ≠òÂà∞localStorage
            localStorage.setItem('intelligentWorkflowKB', JSON.stringify(knowledgeBase));
            
            // üîç Ë∞ÉËØïËæìÂá∫
            console.log('üìä Knowledge base after save:', {
                totalCategories: Object.keys(knowledgeBase).length,
                entry: entry,
                pathParts: pathParts,
                savedStructure: knowledgeBase
            });
        }
        
        // Ë∑≥ËΩ¨Âà∞Áü•ËØÜÂ∫ì
        async function navigateToKnowledgeTree(suggestedPath, fileName) {
            console.log('üß≠ Navigating to knowledge tree:', suggestedPath, fileName);
            
            // ÊòæÁ§∫Âä†ËΩΩÁä∂ÊÄÅ
            showNotification('üß≠ Ê≠£Âú®Ë∑≥ËΩ¨Âà∞Áü•ËØÜÂ∫ì...', 'info');
            
            // Á°Æ‰øùÁü•ËØÜÈù¢ÊùøÊòØÊâìÂºÄÁöÑ
            const knowledgePanel = document.getElementById('knowledgePanel');
            if (!knowledgePanel || !knowledgePanel.classList.contains('open')) {
                console.log('üìö Opening knowledge panel...');
                openKnowledgePanel();
                
                // ÂêåÊó∂ÊøÄÊ¥ªÁü•ËØÜÂ∫ìÊ≠•È™§
                const knowledgeStep = document.querySelector('[data-step="knowledge"]');
                const inputStep = document.querySelector('[data-step="input"]');
                
                if (knowledgeStep && inputStep) {
                    inputStep.classList.remove('active');
                    knowledgeStep.classList.add('active');
                    console.log('‚úÖ Activated knowledge step');
                }
            } else {
                console.log('‚úÖ Knowledge panel already open');
            }
            
            // Êô∫ËÉΩÈáçËØïÂØºËà™Âà∞Áü•ËØÜÊ†ë
            function tryNavigateToPath(retries = 3, delay = 800) {
                setTimeout(() => {
                    try {
                        // Ê£ÄÊü•Áü•ËØÜÂ∫ìÈù¢ÊùøÊòØÂê¶ÂèØËßÅ
                        const knowledgePanel = document.getElementById('knowledgePanel');
                        if (!knowledgePanel || !knowledgePanel.classList.contains('open')) {
                            console.log('üîÑ Knowledge panel not ready, retrying...');
                            if (retries > 0) {
                                tryNavigateToPath(retries - 1, delay + 300);
                                return;
                            }
                        }
                        
                        // üî• ‰∏çÂÜçÈáçÊñ∞ÁîüÊàêÁü•ËØÜÊ†ëÔºåÊñá‰ª∂Â∑≤Áõ¥Êé•Ê∑ªÂä†Âà∞DOM
                        console.log('üîÑ Ë∑≥ËøáÁü•ËØÜÊ†ëÈáçÂª∫Ôºå‰ΩøÁî®Áé∞ÊúâÁªìÊûÑ');
                        
                        // Á≠âÂæÖÁü•ËØÜÊ†ëDOMÊõ¥Êñ∞
                        setTimeout(() => {
                            try {
                                expandToPath(suggestedPath, fileName);
                                showNotification(`üéØ Â∑≤Ë∑≥ËΩ¨Âà∞ "${suggestedPath}"`, 'success');
                            } catch (expandError) {
                                console.error('‚ùå Path expansion failed:', expandError);
                                if (retries > 0) {
                                    console.log(`üîÑ Retrying navigation (${retries} attempts left)`);
                                    tryNavigateToPath(retries - 1, delay + 300);
                                } else {
                                    showNotification('‚ö†Ô∏è Ë∑ØÂæÑÂ±ïÂºÄÂ§±Ë¥•Ôºå‰ΩÜÊñá‰ª∂Â∑≤ÊàêÂäüÊ∑ªÂä†Âà∞Áü•ËØÜÂ∫ì', 'warning');
                                }
                            }
                        }, 200);
                        
                    } catch (error) {
                        console.error('‚ùå Navigation failed:', error);
                        if (retries > 0) {
                            tryNavigateToPath(retries - 1, delay + 300);
                        } else {
                            showNotification('‚ö†Ô∏è Ë∑≥ËΩ¨Âà∞Áü•ËØÜÂ∫ìÊó∂Âá∫Áé∞ÈóÆÈ¢òÔºå‰ΩÜÊñá‰ª∂Â∑≤‰øùÂ≠ò', 'warning');
                        }
                    }
                }, delay);
            }
            
            tryNavigateToPath();
        }
        
        // üåê ‰ªéÂêéÁ´ØÂêåÊ≠•Áé∞ÊúâÊñáÊ°£Êï∞ÊçÆ
        async function syncDocumentsFromBackend() {
            console.log('üîÑ Â∞ùËØï‰ªéÂêéÁ´ØÂêåÊ≠•Áé∞ÊúâÊñáÊ°£...');
            
            try {
                const response = await fetch('http://127.0.0.1:3001/api/documents', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    timeout: 5000
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('üì• ÂêéÁ´ØÊñáÊ°£ÂìçÂ∫î:', data);
                    
                    if (data.success && data.documents && data.documents.length > 0) {
                        console.log(`‚úÖ ÂèëÁé∞ ${data.documents.length} ‰∏™ÂêéÁ´ØÊñáÊ°£ÔºåÂºÄÂßãÂêåÊ≠•Âà∞Êú¨Âú∞Â≠òÂÇ®`);
                        
                        // Ëé∑ÂèñÁé∞ÊúâÁöÑÊåÅ‰πÖÂåñÊï∞ÊçÆ
                        let persistentTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
                        let analysisDB = JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}');
                        
                        for (const doc of data.documents) {
                            console.log('üìÑ ÂêåÊ≠•ÊñáÊ°£:', doc.title);
                            
                            // Ê†πÊçÆÊñáÊ°£Á±ªÂûãÁ°ÆÂÆöÂàÜÁ±ª
                            let category = 'üìÇ Êú™ÂàÜÁ±ª';
                            if (doc.type === 'github_project') {
                                category = 'üîó ÂºÄÊ∫êÈ°πÁõÆ';
                            }
                            
                            // Ê∑ªÂä†Âà∞Áü•ËØÜÊ†ë - ‰ΩøÁî®Ê≠£Á°ÆÁöÑÊï∞ÊçÆÁªìÊûÑ
                            if (!persistentTree[category]) {
                                persistentTree[category] = {
                                    files: [],
                                    aiSuggested: true,
                                    concepts: [],
                                    confidence: 0.9
                                };
                            }
                            
                            // Á°Æ‰øù files Êï∞ÁªÑÂ≠òÂú®
                            if (!persistentTree[category].files) {
                                persistentTree[category].files = [];
                            }
                            
                            // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®ËØ•Êñá‰ª∂
                            const existingFileIndex = persistentTree[category].files.findIndex(f => f.name === doc.title);
                            
                            const fileData = {
                                name: doc.title,
                                id: doc.id,
                                type: doc.type || 'document',
                                content_length: doc.content_length,
                                created_at: doc.created_at,
                                entities_count: doc.entities_count || 0,
                                relationships_count: doc.relationships_count || 0,
                                source: 'backend_sync'
                            };
                            
                            if (existingFileIndex >= 0) {
                                // Êõ¥Êñ∞Áé∞ÊúâÊñá‰ª∂
                                persistentTree[category].files[existingFileIndex] = fileData;
                            } else {
                                // Ê∑ªÂä†Êñ∞Êñá‰ª∂
                                persistentTree[category].files.push(fileData);
                            }
                            
                            // Ëé∑ÂèñËØ¶ÁªÜÂÜÖÂÆπÂπ∂Ê∑ªÂä†Âà∞ÂàÜÊûêÊï∞ÊçÆÂ∫ì
                            try {
                                const contentResponse = await fetch(`http://127.0.0.1:3001/api/documents/${doc.id}/content`, {
                                    timeout: 5000
                                });
                                
                                if (contentResponse.ok) {
                                    const contentData = await contentResponse.json();
                                    if (contentData.success && contentData.document) {
                                        const timestamp = new Date().toISOString();
                                        const key = `${doc.title}_${timestamp}`;
                                        
                                        analysisDB[key] = {
                                            title: doc.title,
                                            content: contentData.document.content.raw_content || '',
                                            analysis: contentData.document.analysis || {},
                                            structure: contentData.document.document_structure || {},
                                            timestamp: timestamp,
                                            source: 'backend_sync'
                                        };
                                        
                                        // üîß ‰øÆÂ§çÔºö‰∏∫fileDataÊ∑ªÂä†storageKeyÔºå‰ª•‰æøopenFileWithLocalToolËÉΩÊâæÂà∞Êñá‰ª∂ÂÜÖÂÆπ
                                        fileData.storageKey = key;
                                        
                                        // üíæ ‰øùÂ≠òÊñá‰ª∂Êï∞ÊçÆÂà∞localStorageÔºàÁî®‰∫éopenFileWithLocalToolÂáΩÊï∞Ôºâ
                                        const fileStorageData = {
                                            fileName: doc.title,
                                            textContent: contentData.document.content.raw_content || '',
                                            analysis: contentData.document.analysis || {},
                                            structure: contentData.document.document_structure || {},
                                            timestamp: timestamp,
                                            source: 'backend_sync'
                                        };
                                        localStorage.setItem(key, JSON.stringify(fileStorageData));
                                        
                                        console.log(`‚úÖ Â∑≤ÂêåÊ≠•ÊñáÊ°£ÂÜÖÂÆπ: ${doc.title}, Â≠òÂÇ®ÈîÆ: ${key}`);
                                    }
                                }
                            } catch (contentError) {
                                console.warn(`‚ö†Ô∏è Ëé∑ÂèñÊñáÊ°£ÂÜÖÂÆπÂ§±Ë¥•: ${doc.title}`, contentError);
                            }
                        }
                        
                        // ‰øùÂ≠òÊõ¥Êñ∞ÂêéÁöÑÊï∞ÊçÆ
                        localStorage.setItem('intelligentWorkflowKnowledgeTree', JSON.stringify(persistentTree));
                        localStorage.setItem('graphRAGAnalysisDB', JSON.stringify(analysisDB));
                        
                        console.log('‚úÖ ÂêéÁ´ØÊñáÊ°£ÂêåÊ≠•ÂÆåÊàê');
                        return true;
                    } else {
                        console.log('üì≠ ÂêéÁ´ØÊöÇÊó†ÊñáÊ°£Êï∞ÊçÆ');
                        return false;
                    }
                } else {
                    console.warn('‚ö†Ô∏è ÂêéÁ´ØÊñáÊ°£Êé•Âè£ÂìçÂ∫îÂºÇÂ∏∏:', response.status);
                    return false;
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è ÂêéÁ´ØÂêåÊ≠•Â§±Ë¥•ÔºåÂèØËÉΩÊúçÂä°Êú™ÂêØÂä®:', error.message);
                return false;
            }
        }
        
        // üîÑ È°µÈù¢Âä†ËΩΩÊó∂ÊÅ¢Â§çÁü•ËØÜÊ†ë
        async function regenerateKnowledgeTree() {
            console.log('üå≥ ÈáçÊñ∞ÁîüÊàêÁü•ËØÜÊ†ëÔºåÊÅ¢Â§çÊåÅ‰πÖÂåñÊï∞ÊçÆ');
            
            const treeContainer = document.getElementById('knowledgeTree');
            if (!treeContainer) {
                console.error('‚ùå Tree container not found!');
                return;
            }
            
            // üåê È¶ñÂÖàÂ∞ùËØï‰ªéÂêéÁ´ØÂêåÊ≠•Êï∞ÊçÆ
            const backendSyncSuccess = await syncDocumentsFromBackend();
            
            // üî• ‰ªéÊåÅ‰πÖÂåñÁöÑÁü•ËØÜÊ†ëÊÅ¢Â§çÔºàÁé∞Âú®ÂåÖÂê´ÂêéÁ´ØÂêåÊ≠•ÁöÑÊï∞ÊçÆÔºâ
            const persistentTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
            const hasPeristentData = Object.keys(persistentTree).length > 0;
            
            console.log('üìä ÊåÅ‰πÖÂåñÁü•ËØÜÊ†ëÊï∞ÊçÆ:', hasPeristentData ? 'Â≠òÂú®' : '‰∏çÂ≠òÂú®');
            console.log('üìÅ ÂàÜÁ±ªÊï∞Èáè:', Object.keys(persistentTree).length);
            console.log('üåê ÂêéÁ´ØÂêåÊ≠•Áä∂ÊÄÅ:', backendSyncSuccess ? 'ÊàêÂäü' : 'Â§±Ë¥•/Êó†Êï∞ÊçÆ');
            
            if (hasPeristentData) {
                console.log('üîÑ ‰ªéÊåÅ‰πÖÂåñÊï∞ÊçÆÊÅ¢Â§çÁü•ËØÜÊ†ëÔºàÂåÖÂê´ÂêéÁ´ØÊï∞ÊçÆÔºâ');
                restoreKnowledgeTreeFromPersistentData(persistentTree, treeContainer);
            } else {
                // ÂõûÈÄÄÂà∞ÂéüÊúâÁöÑÁü•ËØÜÂ∫ìÊï∞ÊçÆ
                const legacyKnowledgeBase = JSON.parse(localStorage.getItem('intelligentWorkflowKB') || '{}');
                const hasExistingNodes = treeContainer.querySelector('.tree-node');
                
                if (hasExistingNodes) {
                    console.log('‚úÖ ‰øùÊåÅÁé∞ÊúâÁü•ËØÜÊ†ëÁªìÊûÑ');
                    updateExistingKnowledgeTree(legacyKnowledgeBase);
                } else if (Object.keys(legacyKnowledgeBase).length > 0) {
                    console.log('üîÑ ‰ªé‰º†ÁªüÁü•ËØÜÂ∫ìÊÅ¢Â§ç');
                    buildTreeFromKnowledgeBase(legacyKnowledgeBase, treeContainer);
                } else {
                    console.log('üìÅ ÊòæÁ§∫Á©∫Áä∂ÊÄÅ');
                    treeContainer.innerHTML = '<div class="empty-message" style="padding: 20px; color: #666; text-align: center;">üìÅ Áü•ËØÜÂ∫ì‰∏∫Á©∫ÔºåËØ∑‰∏ä‰º†ÊñáÊ°£ÂºÄÂßã‰ΩøÁî®</div>';
                }
            }
        }
        
        // üßπ Ê∏ÖÁêÜÂáΩÊï∞ÔºàË∞ÉËØïÁî®Ôºâ
        window.clearAllKnowledgeData = function() {
            console.log('üßπ Ê∏ÖÁêÜÊâÄÊúâÁü•ËØÜÂ∫ìÊï∞ÊçÆ');
            localStorage.removeItem('intelligentWorkflowKnowledgeTree');
            localStorage.removeItem('intelligentWorkflowKB');
            localStorage.removeItem('graphRAGAnalysisDB');
            
            // Ê∏ÖÁêÜÊâÄÊúâÊñá‰ª∂Â≠òÂÇ®
            const keys = Object.keys(localStorage);
            keys.forEach(key => {
                if (key.startsWith('file_')) {
                    localStorage.removeItem(key);
                    console.log('üóëÔ∏è Âà†Èô§Êñá‰ª∂:', key);
                }
            });
            
            // ÈáçÊñ∞ÁîüÊàêÁü•ËØÜÊ†ë
            const treeContainer = document.getElementById('knowledgeTree');
            if (treeContainer) {
                treeContainer.innerHTML = '<div class="empty-message" style="padding: 20px; color: #666; text-align: center;">üìÅ Áü•ËØÜÂ∫ìÂ∑≤Ê∏ÖÁ©∫</div>';
            }
            
            console.log('‚úÖ ÊâÄÊúâÊï∞ÊçÆÂ∑≤Ê∏ÖÁêÜÂÆåÊàê');
        };
        
        // üßπ Ê∏ÖÁêÜÁü•ËØÜÊ†ë‰∏≠ÁöÑÈáçÂ§çÊñá‰ª∂
        window.cleanupDuplicateFiles = function() {
            console.log('üßπ ÂºÄÂßãÊ∏ÖÁêÜÁü•ËØÜÊ†ë‰∏≠ÁöÑÈáçÂ§çÊñá‰ª∂');
            
            try {
                // Ëé∑ÂèñÁü•ËØÜÊ†ëÊï∞ÊçÆ
                const knowledgeTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
                const fileTracker = new Map(); // ËøΩË∏™Êñá‰ª∂ÂêçÂá∫Áé∞Ê¨°Êï∞
                let duplicatesRemoved = 0;
                
                // Á¨¨‰∏ÄÈÅçÔºöÁªüËÆ°ÊâÄÊúâÊñá‰ª∂
                for (const [categoryName, categoryData] of Object.entries(knowledgeTree)) {
                    if (categoryData.files) {
                        categoryData.files.forEach(file => {
                            const fileName = file.name;
                            if (!fileTracker.has(fileName)) {
                                fileTracker.set(fileName, []);
                            }
                            fileTracker.get(fileName).push({ category: categoryName, file });
                        });
                    }
                }
                
                // Á¨¨‰∫åÈÅçÔºöÊ∏ÖÁêÜÈáçÂ§çÊñá‰ª∂Ôºà‰øùÁïôÊúÄÊñ∞ÁöÑÔºâ
                for (const [fileName, locations] of fileTracker.entries()) {
                    if (locations.length > 1) {
                        console.log(`üîç ÂèëÁé∞ÈáçÂ§çÊñá‰ª∂ "${fileName}" Âá∫Áé∞Âú® ${locations.length} ‰∏™‰ΩçÁΩÆ`);
                        
                        // ÊåâÊ∑ªÂä†Êó∂Èó¥ÊéíÂ∫èÔºå‰øùÁïôÊúÄÊñ∞ÁöÑ
                        locations.sort((a, b) => new Date(b.file.addedAt || 0) - new Date(a.file.addedAt || 0));
                        const keepLocation = locations[0];
                        const removeLocations = locations.slice(1);
                        
                        console.log(`üìå ‰øùÁïô: ${keepLocation.category}/${fileName}`);
                        
                        // ÁßªÈô§ÈáçÂ§çÁöÑÊñá‰ª∂
                        for (const removeLocation of removeLocations) {
                            const category = knowledgeTree[removeLocation.category];
                            if (category && category.files) {
                                const beforeCount = category.files.length;
                                category.files = category.files.filter(f => f.name !== fileName);
                                const afterCount = category.files.length;
                                
                                if (beforeCount > afterCount) {
                                    duplicatesRemoved++;
                                    console.log(`üóëÔ∏è ‰ªé "${removeLocation.category}" ‰∏≠ÁßªÈô§ÈáçÂ§çÊñá‰ª∂ "${fileName}"`);
                                }
                            }
                        }
                    }
                }
                
                // ‰øùÂ≠òÊ∏ÖÁêÜÂêéÁöÑÊï∞ÊçÆ
                localStorage.setItem('intelligentWorkflowKnowledgeTree', JSON.stringify(knowledgeTree));
                
                // ÈáçÊñ∞ÁîüÊàêÁü•ËØÜÊ†ëÊòæÁ§∫
                regenerateKnowledgeTree();
                
                console.log(`‚úÖ Ê∏ÖÁêÜÂÆåÊàêÔºÅÁßªÈô§‰∫Ü ${duplicatesRemoved} ‰∏™ÈáçÂ§çÊñá‰ª∂`);
                alert(`Ê∏ÖÁêÜÂÆåÊàêÔºÅ\nÁßªÈô§‰∫Ü ${duplicatesRemoved} ‰∏™ÈáçÂ§çÊñá‰ª∂\nËØ∑Âà∑Êñ∞È°µÈù¢Êü•ÁúãÁªìÊûú`);
                
            } catch (error) {
                console.error('‚ùå Ê∏ÖÁêÜÈáçÂ§çÊñá‰ª∂Â§±Ë¥•:', error);
                alert('Ê∏ÖÁêÜÂ§±Ë¥•Ôºö' + error.message);
            }
        }

        // üß™ ÊµãËØïÂíåÈáçÁΩÆÊãñÊãΩÂäüËÉΩ
        window.resetDragAndDrop = function() {
            console.log('üß™ ÈáçÁΩÆÊãñÊãΩÂäüËÉΩÁä∂ÊÄÅ...');
            window.isProcessingFiles = false;
            window.lastProcessedSignature = null;
            window.currentAnalysisResults = {};
            window.currentUploadedFiles = [];
            
            // Ê∏ÖÁêÜÊâÄÊúâÊñá‰ª∂ÈîÅ
            Object.keys(window).forEach(key => {
                if (key.startsWith('saving_')) {
                    window[key] = false;
                }
            });
            
            console.log('‚úÖ ÊãñÊãΩÂäüËÉΩÁä∂ÊÄÅÂ∑≤ÈáçÁΩÆ');
            alert('ÊãñÊãΩÂäüËÉΩÂ∑≤ÈáçÁΩÆÔºÅÁé∞Âú®Â∫îËØ•ÂèØ‰ª•Ê≠£Â∏∏ÊãñÊãΩÊñá‰ª∂‰∫Ü„ÄÇ');
        }

        // üîç Ë∞ÉËØïÂáΩÊï∞ÔºöÊü•ÁúãÂΩìÂâçÂ≠òÂÇ®Áä∂ÊÄÅ
        window.debugKnowledgeStorage = function() {
            console.log('üîç Ë∞ÉËØïÁü•ËØÜÂ∫ìÂ≠òÂÇ®Áä∂ÊÄÅ:');
            console.log('üìä Êñ∞ÊåÅ‰πÖÂåñÁü•ËØÜÊ†ë:', JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}'));
            console.log('üìä ÊóßÁü•ËØÜÂ∫ì:', JSON.parse(localStorage.getItem('intelligentWorkflowKB') || '{}'));
            console.log('üìä GraphRAGÂàÜÊûêÂ∫ì:', Object.keys(JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}')).length, 'Êù°ËÆ∞ÂΩï');
            console.log('üìä Êñá‰ª∂Â≠òÂÇ®:', Object.keys(localStorage).filter(k => k.startsWith('file_')).length, '‰∏™Êñá‰ª∂');
            
            // ÂàóÂá∫ÊâÄÊúâlocalStorageÈîÆ
            console.log('üìä ÊâÄÊúâlocalStorageÈîÆ:', Object.keys(localStorage));
        };
        
        // üîß ÊµãËØïÊñá‰ª∂ÂÜÖÂÆπÂ≠òÂÇ®
        window.testFileContent = function(fileName) {
            console.log('üîß ÊµãËØïÊñá‰ª∂ÂÜÖÂÆπÂ≠òÂÇ®:', fileName);
            
            // Êü•ÊâæÊâÄÊúâÁõ∏ÂÖ≥ÁöÑÂ≠òÂÇ®ÈîÆ
            const allKeys = Object.keys(localStorage);
            const fileKeys = allKeys.filter(key => key.startsWith('file_') && key.includes(fileName));
            
            console.log('üìÅ ÊâæÂà∞Áõ∏ÂÖ≥Â≠òÂÇ®ÈîÆ:', fileKeys);
            
            fileKeys.forEach(key => {
                const dataStr = localStorage.getItem(key);
                if (dataStr) {
                    try {
                        const data = JSON.parse(dataStr);
                        console.log(`üìÑ Â≠òÂÇ®ÈîÆ: ${key}`);
                        console.log('  - Êñá‰ª∂Âêç:', data.name);
                        console.log('  - Êñá‰ª∂Á±ªÂûã:', data.type);
                        console.log('  - Êñá‰ª∂Â§ßÂ∞è:', data.size);
                        console.log('  - ÊúâÂÆåÊï¥ÂÜÖÂÆπ:', !!data.hasLocalContent);
                        console.log('  - ÊúâÊñáÊú¨ÂÜÖÂÆπ:', !!data.textContent, data.textContent?.length);
                        if (data.textContent) {
                            console.log('  - ÊñáÊú¨ÂÜÖÂÆπÈ¢ÑËßà:', data.textContent.substring(0, 200));
                        }
                    } catch (e) {
                        console.error('‚ùå Ëß£ÊûêÂ≠òÂÇ®Êï∞ÊçÆÂ§±Ë¥•:', e);
                    }
                }
            });
        };
        
        // üîß ÊµãËØïÊãñÊãΩÂäüËÉΩÁä∂ÊÄÅ
        window.testDragDrop = function() {
            console.log('üîß ÊµãËØïÊãñÊãΩÂäüËÉΩÁä∂ÊÄÅ...');
            
            const inputContainer = document.querySelector('.multimodal-input-container');
            const fileDropZone = document.querySelector('.file-drop-zone');
            
            console.log('üìã ÊãñÊãΩÂÖÉÁ¥†Ê£ÄÊü•:');
            console.log('  - Input ContainerÂ≠òÂú®:', !!inputContainer);
            console.log('  - File Drop ZoneÂ≠òÂú®:', !!fileDropZone);
            
            if (inputContainer) {
                // Ê£ÄÊü•‰∫ã‰ª∂ÁõëÂê¨Âô®ÔºàËôΩÁÑ∂Êó†Ê≥ïÁõ¥Êé•Ê£ÄÊü•Ôºå‰ΩÜÂèØ‰ª•Ëß¶ÂèëÊµãËØïÔºâ
                console.log('  - Input Container classes:', inputContainer.classList.toString());
                console.log('  - Input Container styles:', inputContainer.style.cssText);
            }
            
            if (fileDropZone) {
                console.log('  - File Drop Zone classes:', fileDropZone.classList.toString());
                console.log('  - File Drop Zone styles:', fileDropZone.style.cssText);
            }
            
            // Ê£ÄÊü•ÊòØÂê¶Âú®Êñá‰ª∂Ê®°Âºè
            const fileInputMode = document.getElementById('fileInputMode');
            console.log('  - Êñá‰ª∂ËæìÂÖ•Ê®°ÂºèÊòæÁ§∫:', fileInputMode?.style.display !== 'none');
            
            console.log('üí° ËØ∑Â∞ùËØïÊãñÊãΩÊñá‰ª∂Âà∞ËæìÂÖ•Âå∫ÂüüÊü•ÁúãÊéßÂà∂Âè∞ËæìÂá∫');
        };
        
        // üîß ÊµãËØïÂà†Èô§ÁúüÂÆûÊñá‰ª∂ÂäüËÉΩ
        window.testDeleteRealFile = function() {
            console.log('üîß ÊµãËØïÂà†Èô§ÁúüÂÆûÊñá‰ª∂...');
            
            const knowledgeTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
            console.log('üìä ÂΩìÂâçÁü•ËØÜÊ†ë:', knowledgeTree);
            
            // ÊâæÂà∞Á¨¨‰∏Ä‰∏™ÁúüÂÆûÊñá‰ª∂
            for (const [categoryName, categoryData] of Object.entries(knowledgeTree)) {
                if (categoryData.files && categoryData.files.length > 0) {
                    const realFile = categoryData.files[0];
                    console.log(`üéØ ÊâæÂà∞ÁúüÂÆûÊñá‰ª∂: "${realFile.name}" Âú®ÂàÜÁ±ª "${categoryName}" ‰∏≠`);
                    
                    // Ê®°ÊãüÂà†Èô§
                    console.log('üóëÔ∏è ÂºÄÂßãÂà†Èô§ÊµãËØï...');
                    cleanupFileFromPersistentData(realFile.name);
                    
                    const newTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
                    console.log('üìä Âà†Èô§ÂêéÁü•ËØÜÊ†ë:', newTree);
                    return;
                }
            }
            
            console.log('‚ö†Ô∏è Ê≤°ÊúâÊâæÂà∞ÁúüÂÆûÊñá‰ª∂');
        };
        
        // üîß ÊµãËØïÂà†Èô§ÂäüËÉΩÊòØÂê¶Ê≠£Â∏∏ÁªëÂÆö
        window.testDeleteFunction = function() {
            console.log('üîß Testing delete function binding...');
            
            // Ê£ÄÊü•ÂáΩÊï∞ÊòØÂê¶Â≠òÂú®
            console.log('üîß window.deleteNode exists:', typeof window.deleteNode);
            
            // Êü•ÊâæÂà†Èô§ÊåâÈíÆ
            const deleteButtons = document.querySelectorAll('button[onclick*="deleteNode"]');
            console.log('üîß Found delete buttons:', deleteButtons.length);
            
            deleteButtons.forEach((btn, index) => {
                console.log(`üîß Button ${index}:`, btn.outerHTML);
            });
            
            // Êü•ÊâæÊâÄÊúâ.node-actionÊåâÈíÆ
            const actionButtons = document.querySelectorAll('.node-action');
            console.log('üîß Found action buttons:', actionButtons.length);
            
            actionButtons.forEach((btn, index) => {
                const text = btn.textContent || btn.innerHTML;
                if (text.includes('üóëÔ∏è')) {
                    console.log(`üîß Delete button ${index}:`, btn.outerHTML);
                }
            });
        };
        
        // üóëÔ∏è Ê∏ÖÁêÜÊñá‰ª∂ÁöÑÊåÅ‰πÖÂåñÊï∞ÊçÆ
        function cleanupFileFromPersistentData(fileName) {
            console.log('üóëÔ∏è Ê∏ÖÁêÜÊñá‰ª∂ÊåÅ‰πÖÂåñÊï∞ÊçÆ:', fileName);
            
            try {
                // üî• Ê∏ÖÁêÜÊñ∞ÁöÑÁü•ËØÜÊ†ëÁªìÊûÑ
                let knowledgeTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
                let fileRemoved = false;
                
                console.log('üîç Ê≠£Âú®ÊêúÁ¥¢Êñá‰ª∂Âêç:', fileName);
                console.log('üîç Áü•ËØÜÊ†ëÁªìÊûÑ:', Object.keys(knowledgeTree));
                
                for (const [categoryName, categoryData] of Object.entries(knowledgeTree)) {
                    if (categoryData.files) {
                        console.log(`üîç ÂàÜÁ±ª "${categoryName}" ‰∏≠ÁöÑÊñá‰ª∂:`, categoryData.files.map(f => f.name));
                        const beforeCount = categoryData.files.length;
                        categoryData.files = categoryData.files.filter(file => {
                            const matches = file.name === fileName;
                            if (!matches) {
                                console.log(`üîç Êñá‰ª∂Âêç‰∏çÂåπÈÖç: "${file.name}" !== "${fileName}"`);
                            }
                            return !matches;
                        });
                        if (categoryData.files.length < beforeCount) {
                            fileRemoved = true;
                            console.log(`üóëÔ∏è ‰ªéÂàÜÁ±ª "${categoryName}" ‰∏≠ÁßªÈô§Êñá‰ª∂ "${fileName}"`);
                        }
                    }
                }
                
                localStorage.setItem('intelligentWorkflowKnowledgeTree', JSON.stringify(knowledgeTree));
                
                // üî• ÂêåÊó∂Ê∏ÖÁêÜÊóßÁöÑÁü•ËØÜÂ∫ìÁªìÊûÑ  
                let knowledgeBase = JSON.parse(localStorage.getItem('intelligentWorkflowKB') || '{}');
                for (const [categoryName, categoryData] of Object.entries(knowledgeBase)) {
                    if (categoryData.files) {
                        const beforeCount = categoryData.files.length;
                        categoryData.files = categoryData.files.filter(file => file.name !== fileName);
                        if (categoryData.files.length < beforeCount) {
                            fileRemoved = true;
                            console.log(`üóëÔ∏è ‰ªéÊóßÁü•ËØÜÂ∫ìÂàÜÁ±ª "${categoryName}" ‰∏≠ÁßªÈô§Êñá‰ª∂ "${fileName}"`);
                        }
                    }
                }
                localStorage.setItem('intelligentWorkflowKB', JSON.stringify(knowledgeBase));
                
                // Ê∏ÖÁêÜGraphRAGÂàÜÊûêÊï∞ÊçÆ
                let analysisDB = JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}');
                delete analysisDB[fileName];
                localStorage.setItem('graphRAGAnalysisDB', JSON.stringify(analysisDB));
                
                // Ê∏ÖÁêÜÊñá‰ª∂Â≠òÂÇ®
                const storageKeys = Object.keys(localStorage).filter(key => key.startsWith('file_') && key.includes(fileName));
                storageKeys.forEach(key => {
                    localStorage.removeItem(key);
                    console.log(`üóëÔ∏è ÁßªÈô§Êñá‰ª∂Â≠òÂÇ®: ${key}`);
                });
                
                console.log('‚úÖ Êñá‰ª∂ÊåÅ‰πÖÂåñÊï∞ÊçÆÂ∑≤ÂÆåÂÖ®Ê∏ÖÁêÜ, Êñá‰ª∂Â∑≤ÁßªÈô§:', fileRemoved);
                
            } catch (error) {
                console.error('‚ùå Ê∏ÖÁêÜÊñá‰ª∂Êï∞ÊçÆÂ§±Ë¥•:', error);
            }
        }
        
        // üóëÔ∏è Ê∏ÖÁêÜÂàÜÁ±ªÁöÑÊåÅ‰πÖÂåñÊï∞ÊçÆ
        function cleanupCategoryFromPersistentData(categoryName) {
            console.log('üóëÔ∏è Ê∏ÖÁêÜÂàÜÁ±ªÊåÅ‰πÖÂåñÊï∞ÊçÆ:', categoryName);
            
            try {
                // üî• Ê∏ÖÁêÜÊñ∞ÁöÑÁü•ËØÜÊ†ëÁªìÊûÑ
                let knowledgeTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
                const treeHadCategory = categoryName in knowledgeTree;
                delete knowledgeTree[categoryName];
                localStorage.setItem('intelligentWorkflowKnowledgeTree', JSON.stringify(knowledgeTree));
                
                // üî• ÂêåÊó∂Ê∏ÖÁêÜÊóßÁöÑÁü•ËØÜÂ∫ìÁªìÊûÑ
                let knowledgeBase = JSON.parse(localStorage.getItem('intelligentWorkflowKB') || '{}');
                const baseHadCategory = categoryName in knowledgeBase;
                delete knowledgeBase[categoryName];
                localStorage.setItem('intelligentWorkflowKB', JSON.stringify(knowledgeBase));
                
                console.log('‚úÖ ÂàÜÁ±ªÊåÅ‰πÖÂåñÊï∞ÊçÆÂ∑≤ÂÆåÂÖ®Ê∏ÖÁêÜ:', {
                    fromTree: treeHadCategory,
                    fromBase: baseHadCategory
                });
                
            } catch (error) {
                console.error('‚ùå Ê∏ÖÁêÜÂàÜÁ±ªÊï∞ÊçÆÂ§±Ë¥•:', error);
            }
        }
        
        // üîÑ ‰ªéÊåÅ‰πÖÂåñÊï∞ÊçÆÊÅ¢Â§çÁü•ËØÜÊ†ë
        function restoreKnowledgeTreeFromPersistentData(persistentTree, treeContainer) {
            console.log('üîÑ ‰ªéÊåÅ‰πÖÂåñÊï∞ÊçÆÊÅ¢Â§çÁü•ËØÜÊ†ë');
            
            // üî• Êô∫ËÉΩÂêàÂπ∂ÔºöÂè™Ê∑ªÂä†‰∏çÂ≠òÂú®ÁöÑÂàÜÁ±ªÔºå‰øùÁïôÁé∞ÊúâÂÜÖÂÆπ
            console.log('üîÑ Êô∫ËÉΩÂêàÂπ∂Áü•ËØÜÊ†ëÂÜÖÂÆπÔºå‰øùÁïôÁé∞ÊúâÁªìÊûÑ');
            
            // ÈÅçÂéÜÊØè‰∏™ÂàÜÁ±ª
            for (const [categoryName, categoryData] of Object.entries(persistentTree)) {
                console.log(`üìÇ Ê£ÄÊü•ÂàÜÁ±ª: ${categoryName} (${categoryData.files?.length || 0} Êñá‰ª∂)`);
                
                // üîç Ê£ÄÊü•ÂàÜÁ±ªÊòØÂê¶Â∑≤Â≠òÂú®
                let existingCategory = findNodeByTitle(categoryName);
                
                if (!existingCategory) {
                    console.log(`‚ûï ÂàõÂª∫Êñ∞ÂàÜÁ±ª: ${categoryName}`);
                    // ÂàõÂª∫ÂàÜÁ±ªËäÇÁÇπÔºà‰∏çËá™Âä®Ê∑ªÂä†Ôºâ
                    const categoryNode = createIntelligentCategoryNode(categoryName, {
                        aiSuggested: categoryData.aiSuggested || false,
                        concepts: categoryData.concepts || [],
                        confidence: categoryData.confidence || 0.8
                    }, false);
                    
                    // ÊâãÂä®Ê∑ªÂä†Âà∞Áü•ËØÜÊ†ëÂÆπÂô®
                    treeContainer.appendChild(categoryNode);
                    existingCategory = categoryNode;
                } else {
                    console.log(`‚úÖ ÂàÜÁ±ª "${categoryName}" Â∑≤Â≠òÂú®ÔºåË∑≥ËøáÂàõÂª∫`);
                }
                
                // ÊÅ¢Â§çÂàÜÁ±ª‰∏ãÁöÑÊñá‰ª∂
                if (categoryData.files && categoryData.files.length > 0) {
                    const childrenContainer = existingCategory.querySelector('.node-children');
                    
                    for (const fileData of categoryData.files) {
                        console.log(`üìÑ ÊÅ¢Â§çÊñá‰ª∂: ${fileData.name}`);
                        
                        // üî• Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â∑≤Â≠òÂú®ÔºåÈÅøÂÖçÈáçÂ§çÊ∑ªÂä†
                        const existingFiles = childrenContainer.querySelectorAll('.node-title');
                        const fileExists = Array.from(existingFiles).some(title => title.textContent.trim() === fileData.name);
                        
                        if (!fileExists) {
                            // ÂàõÂª∫Êñá‰ª∂ËäÇÁÇπ
                            const fileNode = createRestoredFileNode(fileData);
                            if (childrenContainer) {
                                childrenContainer.appendChild(fileNode);
                            }
                        } else {
                            console.log(`‚ö†Ô∏è Êñá‰ª∂ "${fileData.name}" Â∑≤Â≠òÂú®ÔºåË∑≥ËøáÈáçÂ§çÂàõÂª∫`);
                        }
                    }
                    
                    // Â±ïÂºÄÊúâÊñá‰ª∂ÁöÑÂàÜÁ±ª
                    expandNodePath(existingCategory);
                }
            }
            
            console.log('‚úÖ Áü•ËØÜÊ†ëÊÅ¢Â§çÂÆåÊàê');
        }
        
        // üîÑ ÂàõÂª∫ÊÅ¢Â§çÁöÑÊñá‰ª∂ËäÇÁÇπ
        function createRestoredFileNode(fileData) {
            const fileNode = document.createElement('div');
            fileNode.className = 'tree-node';
            
            const confidenceIcon = (fileData.aiAnalysis?.confidence || 0) > 0.8 ? 'üéØ' : 'üìÑ';
            
            fileNode.innerHTML = `
                <div class="node-content" onclick="openFileWithLocalTool(event, this)" draggable="true" 
                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                    <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                    <div class="node-icon file">${confidenceIcon}</div>
                    <div class="node-title" ondblclick="editNodeTitle(event, this)">${fileData.name}</div>
                    <div class="node-actions">
                        <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                        <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                        <button class="node-action" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                        <button class="node-action" onclick="showGraphRAGAnalysis(event, this)" title="Êü•ÁúãAIÂàÜÊûê">üß†</button>
                    </div>
                </div>
                <div class="node-children"></div>
            `;
            
            // ÊÅ¢Â§çÊñá‰ª∂Â±ûÊÄß
            fileNode.setAttribute('data-file-name', fileData.name);
            fileNode.setAttribute('data-file-size', fileData.size);
            fileNode.setAttribute('data-file-type', fileData.type);
            fileNode.setAttribute('data-file-storage-key', fileData.storageKey);
            fileNode.setAttribute('data-ai-concepts', JSON.stringify(fileData.aiAnalysis?.concepts || []));
            fileNode.setAttribute('data-ai-confidence', fileData.aiAnalysis?.confidence || 0);
            fileNode.setAttribute('data-ai-summary', fileData.aiAnalysis?.summary || '');
            
            return fileNode;
        }
        
        // üî• Êõ¥Êñ∞Áé∞ÊúâÁü•ËØÜÊ†ëÔºåÊ∑ªÂä†Êñ∞Êñá‰ª∂‰ΩÜ‰øùÊåÅÂéüÊúâÁªìÊûÑÂíå‰∫§‰∫í
        function updateExistingKnowledgeTree(knowledgeBase) {
            console.log('üîÑ Êõ¥Êñ∞Áé∞ÊúâÁü•ËØÜÊ†ëÁªìÊûÑ');
            
            // ÈÅçÂéÜÁü•ËØÜÂ∫ì‰∏≠ÁöÑÊñ∞Êï∞ÊçÆÔºåÊü•ÊâæÈúÄË¶ÅÊ∑ªÂä†ÁöÑÊñá‰ª∂
            Object.keys(knowledgeBase).forEach(categoryName => {
                const category = knowledgeBase[categoryName];
                if (category.files && category.files.length > 0) {
                    // Ê£ÄÊü•Ëøô‰∏™Á±ªÂà´ÁöÑÊñá‰ª∂ÊòØÂê¶Â∑≤ÁªèÂú®Áü•ËØÜÊ†ë‰∏≠
                    const existingCategoryNode = findNodeByTitle(categoryName);
                    
                    if (existingCategoryNode) {
                        console.log(`‚úÖ ÊâæÂà∞Áé∞ÊúâÁ±ªÂà´: ${categoryName}`);
                        // Ê∑ªÂä†Êñ∞Êñá‰ª∂Âà∞Áé∞ÊúâÁ±ªÂà´
                        addFilesToExistingCategory(existingCategoryNode, category.files);
                    } else {
                        console.log(`üÜï ÂàõÂª∫Êñ∞Á±ªÂà´: ${categoryName}`);
                        // ÂàõÂª∫Êñ∞ÁöÑÁ±ªÂà´ËäÇÁÇπ
                        createNewCategoryNode(categoryName, category);
                    }
                }
            });
        }
        
        // Âú®Áü•ËØÜÊ†ë‰∏≠Êü•ÊâæÂÖ∑ÊúâÊåáÂÆöÊ†áÈ¢òÁöÑËäÇÁÇπ
        function findNodeByTitle(title) {
            const knowledgeTree = document.getElementById('knowledgeTree');
            if (!knowledgeTree) return null;
            
            const titleElements = knowledgeTree.querySelectorAll('.node-title');
            for (const element of titleElements) {
                if (element.textContent.trim() === title) {
                    return element.closest('.tree-node');
                }
            }
            return null;
        }
        
        // ÂêëÁé∞ÊúâÁ±ªÂà´Ê∑ªÂä†Êñá‰ª∂
        function addFilesToExistingCategory(categoryNode, files) {
            const childrenContainer = categoryNode.querySelector('.node-children');
            if (!childrenContainer) return;
            
            files.forEach(file => {
                // Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â∑≤Â≠òÂú®
                const existingFile = findNodeByTitle(file.name);
                if (!existingFile) {
                    console.log(`üìÑ Ê∑ªÂä†Êñ∞Êñá‰ª∂Âà∞Áé∞ÊúâÁ±ªÂà´: ${file.name}`);
                    const fileNode = createFileNode(file);
                    childrenContainer.appendChild(fileNode);
                } else {
                    console.log(`‚úÖ Êñá‰ª∂Â∑≤Â≠òÂú®: ${file.name}`);
                }
            });
        }
        
        // ÂàõÂª∫Êñ∞ÁöÑÁ±ªÂà´ËäÇÁÇπÔºàÂÆåÊï¥‰∫§‰∫íÂäüËÉΩÔºâ
        function createNewCategoryNode(categoryName, categoryData) {
            const knowledgeTree = document.getElementById('knowledgeTree');
            if (!knowledgeTree) return;
            
            const categoryNode = document.createElement('div');
            categoryNode.className = 'tree-node';
            categoryNode.innerHTML = `
                <div class="node-content" onclick="selectNode(this, event)" draggable="true" 
                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                    <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                    <div class="node-icon folder">üìÅ</div>
                    <div class="node-title" ondblclick="editNodeTitle(event, this)">${categoryName}</div>
                    <div class="node-actions">
                        <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                        <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                        <button class="node-action" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                    </div>
                </div>
                <div class="node-children"></div>
            `;
            
            knowledgeTree.appendChild(categoryNode);
            
            // Ê∑ªÂä†Êñá‰ª∂Âà∞Êñ∞Á±ªÂà´
            if (categoryData.files) {
                addFilesToExistingCategory(categoryNode, categoryData.files);
            }
        }
        
        // ÂàõÂª∫Êñá‰ª∂ËäÇÁÇπÔºàÂÆåÊï¥‰∫§‰∫íÂäüËÉΩÔºâ
        function createFileNode(file) {
            const fileNode = document.createElement('div');
            fileNode.className = 'tree-node';
            fileNode.innerHTML = `
                <div class="node-content" onclick="openFileWithLocalTool(event, this)" draggable="true" 
                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                    <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                    <div class="node-icon file">üìÑ</div>
                    <div class="node-title" ondblclick="editNodeTitle(event, this)">${file.name}</div>
                    <div class="node-actions">
                        <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                        <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                        <button class="node-action" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                    </div>
                </div>
                <div class="node-children"></div>
            `;
            
            // Â≠òÂÇ®Êñá‰ª∂ÂÜÖÂÆπÊï∞ÊçÆ
            fileNode.setAttribute('data-file-content', file.content || '');
            fileNode.setAttribute('data-file-id', file.id || '');
            
            return fileNode;
        }
        
        // ‰ªéÁü•ËØÜÂ∫ìÊûÑÂª∫Ê†ë
        function buildTreeFromKnowledgeBase(data, container, level = 0) {
            console.log(`üìÇ Building tree at level ${level}, keys:`, Object.keys(data));
            
            Object.keys(data).forEach(key => {
                const item = data[key];
                console.log(`üìÑ Processing item: ${key}`, item);
                
                // ÂÖºÂÆπÂ§öÁßçÊï∞ÊçÆÁªìÊûÑ
                const isFolder = (item._metadata && item._metadata.type === 'folder') || 
                                (item.type === 'category') ||
                                (item.children && Object.keys(item.children).length > 0) ||
                                (item.files && Array.isArray(item.files));
                
                if (isFolder) {
                    // ÂàõÂª∫Êñá‰ª∂Â§πËäÇÁÇπ
                    const folderDiv = document.createElement('div');
                    folderDiv.className = 'category-item';
                    folderDiv.style.paddingLeft = `${level * 20}px`;
                    
                    folderDiv.innerHTML = `
                        <span class="toggle-arrow">‚ñ∂</span>
                        <span class="category-icon">üìÅ</span>
                        <span class="category-name">${key}</span>
                        <span class="file-count">${item.files?.length || 0} files</span>
                    `;
                    
                    container.appendChild(folderDiv);
                    
                    // ÂàõÂª∫Â≠êÂÆπÂô®
                    const subContainer = document.createElement('div');
                    subContainer.className = 'subcategory';
                    subContainer.style.display = 'none';
                    container.appendChild(subContainer);
                    
                    // Ê∑ªÂä†ÁÇπÂáªÂ±ïÂºÄÂäüËÉΩ
                    folderDiv.addEventListener('click', () => {
                        const arrow = folderDiv.querySelector('.toggle-arrow');
                        if (subContainer.style.display === 'none') {
                            subContainer.style.display = 'block';
                            arrow.textContent = '‚ñº';
                        } else {
                            subContainer.style.display = 'none';
                            arrow.textContent = '‚ñ∂';
                        }
                    });
                    
                    // ÈÄíÂΩíÊ∑ªÂä†Â≠êÈ°π
                    if (item.children) {
                        buildTreeFromKnowledgeBase(item.children, subContainer, level + 1);
                    }
                    
                    // Ê∑ªÂä†Êñá‰ª∂
                    if (item.files && item.files.length > 0) {
                        item.files.forEach(file => {
                            const fileDiv = document.createElement('div');
                            fileDiv.className = 'file-item';
                            fileDiv.style.paddingLeft = `${(level + 1) * 20}px`;
                            fileDiv.innerHTML = `
                                <span class="file-icon">üìÑ</span>
                                <span class="file-name">${file.name}</span>
                                <span class="file-size">${formatFileSize(file.size)}</span>
                            `;
                            
                            // Ê∑ªÂä†ÁÇπÂáªÊü•ÁúãÂäüËÉΩ
                            fileDiv.addEventListener('click', () => {
                                showFileContent(file);
                            });
                            
                            subContainer.appendChild(fileDiv);
                        });
                    }
                }
            });
        }
        
        // Ëá™Âä®ÂàõÂª∫ÂàÜÁ±ªË∑ØÂæÑÂà∞Áü•ËØÜÂ∫ì
        async function createCategoryPath(categoryPath) {
            console.log('üÜï Creating category path:', categoryPath);
            
            const knowledgeBase = JSON.parse(localStorage.getItem('intelligentWorkflowKB') || '{}');
            const pathParts = categoryPath.split('/').filter(p => p.trim());
            
            let currentLevel = knowledgeBase;
            let currentPath = '';
            
            // ÈÄêÁ∫ßÂàõÂª∫Ë∑ØÂæÑ
            for (const part of pathParts) {
                currentPath += (currentPath ? '/' : '') + part;
                
                if (!currentLevel[part]) {
                    console.log(`‚ú® Creating category: "${part}" at path: ${currentPath}`);
                    currentLevel[part] = {
                        _metadata: { 
                            type: 'folder',
                            autoCreated: true,
                            createdAt: new Date().toISOString()
                        },
                        children: {},
                        files: []
                    };
                }
                currentLevel = currentLevel[part].children;
            }
            
            // ‰øùÂ≠òÊõ¥Êñ∞ÂêéÁöÑÁü•ËØÜÂ∫ì
            localStorage.setItem('intelligentWorkflowKB', JSON.stringify(knowledgeBase));
            console.log('‚úÖ Category path created and saved to localStorage');
        }
        
        // ÊèêÂèñÊñá‰ª∂ÂÜÖÂÆπÁî®‰∫é‰øùÂ≠ò
        async function readFileContentForSave(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => {
                    const content = e.target.result || '';
                    console.log(`üìÑ Extracted content from ${file.name}: ${content.length} characters`);
                    resolve(content);
                };
                reader.onerror = e => {
                    console.error('‚ùå Failed to read file content:', e);
                    resolve(''); // ËøîÂõûÁ©∫Â≠óÁ¨¶‰∏≤ËÄå‰∏çÊòØreject
                };
                reader.readAsText(file);
            });
        }
        
        // Â∞ÜÊñáÊ°£‰øùÂ≠òÂà∞localStorageÁü•ËØÜÂ∫ì‰∏≠
        function saveDocumentToLocalStorage(targetPath, fileName, fileContent = null) {
            console.log('üíæ Saving document to localStorage:', targetPath, fileName);
            
            const knowledgeBase = JSON.parse(localStorage.getItem('intelligentWorkflowKB') || '{}');
            const pathParts = targetPath.split(/[/>]/).filter(p => p.trim());
            
            let currentLevel = knowledgeBase;
            
            // ÂØºËà™Âà∞ÊúÄÁªàË∑ØÂæÑ
            for (const part of pathParts) {
                if (!currentLevel[part]) {
                    // Â¶ÇÊûúË∑ØÂæÑ‰∏çÂ≠òÂú®ÔºåÂàõÂª∫ÂÆÉ
                    currentLevel[part] = {
                        _metadata: { 
                            type: 'folder',
                            autoCreated: true,
                            createdAt: new Date().toISOString()
                        },
                        children: {},
                        files: []
                    };
                }
                
                // Á°Æ‰øùfilesÊï∞ÁªÑÂ≠òÂú®
                if (!currentLevel[part].files) {
                    currentLevel[part].files = [];
                }
                
                // Â¶ÇÊûúËøôÊòØÊúÄÂêé‰∏ÄÁ∫ßÔºåÊ∑ªÂä†Êñá‰ª∂
                if (part === pathParts[pathParts.length - 1]) {
                    // Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â∑≤Â≠òÂú®
                    const existingFile = currentLevel[part].files.find(f => f.name === fileName);
                    if (!existingFile) {
                        const fileEntry = {
                            name: fileName,
                            type: 'document',
                            addedAt: new Date().toISOString(),
                            source: 'ai_upload'
                        };
                        
                        // Ê∑ªÂä†Êñá‰ª∂ÂÜÖÂÆπ
                        if (fileContent) {
                            fileEntry.content = fileContent;
                            console.log(`‚úÖ Document "${fileName}" with content (${fileContent.length} chars) saved to localStorage`);
                        } else {
                            console.warn(`‚ö†Ô∏è Document "${fileName}" saved without content`);
                        }
                        
                        currentLevel[part].files.push(fileEntry);
                        console.log(`‚úÖ Document "${fileName}" saved to localStorage at path: ${targetPath}`);
                    }
                } else {
                    // ÁªßÁª≠Ê∑±ÂÖ•
                    currentLevel = currentLevel[part].children;
                }
            }
            
            // ‰øùÂ≠òÊõ¥Êñ∞ÂêéÁöÑÁü•ËØÜÂ∫ì
            localStorage.setItem('intelligentWorkflowKB', JSON.stringify(knowledgeBase));
        }
        
        // ‰ªélocalStorageÁü•ËØÜÂ∫ì‰∏≠Ëé∑ÂèñÊñáÊ°£ÂÜÖÂÆπ
        function getContentFromKnowledgeBase(fileName) {
            console.log('üîç Looking for content in knowledge base:', fileName);
            
            try {
                const knowledgeBase = JSON.parse(localStorage.getItem('intelligentWorkflowKB') || '{}');
                
                // ÈÄíÂΩíÊêúÁ¥¢ÊâÄÊúâÂ±ÇÁ∫ßÁöÑÊñá‰ª∂
                function searchInLevel(level, depth = 0) {
                    const indent = '  '.repeat(depth);
                    console.log(`${indent}üîç Searching level:`, Object.keys(level));
                    
                    for (const key in level) {
                        const item = level[key];
                        
                        // Ê£ÄÊü•filesÊï∞ÁªÑ
                        if (item.files && Array.isArray(item.files)) {
                            console.log(`${indent}üìÅ Checking files in "${key}":`, item.files.length);
                            for (const file of item.files) {
                                console.log(`${indent}  üìÑ File: "${file.name}"`);
                                if (file.name === fileName && file.content) {
                                    console.log(`${indent}  ‚úÖ Found content for "${fileName}":`, file.content.substring(0, 100) + '...');
                                    return file.content;
                                }
                            }
                        }
                        
                        // ÈÄíÂΩíÊêúÁ¥¢Â≠êÁ∫ß
                        if (item.children && typeof item.children === 'object') {
                            const result = searchInLevel(item.children, depth + 1);
                            if (result) return result;
                        }
                    }
                    return null;
                }
                
                const content = searchInLevel(knowledgeBase);
                if (content) {
                    console.log('‚úÖ Content found in knowledge base for:', fileName);
                } else {
                    console.log('‚ùå No content found in knowledge base for:', fileName);
                }
                
                return content;
                
            } catch (error) {
                console.error('‚ùå Error reading from knowledge base:', error);
                return null;
            }
        }

        // Â±ïÂºÄÂà∞ÊåáÂÆöË∑ØÂæÑ
        async function expandToPath(targetPath, fileName) {
            console.log('üéØ Expanding to path:', targetPath, fileName);
            
            // Ê£ÄÊü•Áü•ËØÜÊ†ëÊòØÂê¶Â≠òÂú®
            const categoryTree = document.getElementById('knowledgeTree');
            if (!categoryTree) {
                console.error('‚ùå Knowledge tree not found, retrying...');
                throw new Error('Knowledge tree container not found');
            }
            
            const pathParts = targetPath.split(/[/>]/).map(p => p.trim()).filter(p => p); // ÊîØÊåÅ / Âíå > ÂàÜÈöîÁ¨¶ÔºåÂéªÈô§Á©∫Ê†º
            console.log('üìÇ Path parts:', pathParts);
            
            // ÈÄêÁ∫ßÂ±ïÂºÄË∑ØÂæÑÔºåÂ¶ÇÊûúË∑ØÂæÑ‰∏çÂ≠òÂú®ÂàôËá™Âä®ÂàõÂª∫
            // ‰ªéÁü•ËØÜÊ†ëÁöÑÊ†πÂÆπÂô®ÂºÄÂßã
            let currentContainer = categoryTree;
            let currentPath = '';
            
            for (let i = 0; i < pathParts.length; i++) {
                const part = pathParts[i];
                currentPath += (currentPath ? '/' : '') + part;
                console.log(`üîç Looking for category: "${part}" in path: ${currentPath}`);
                
                if (!currentContainer) {
                    console.error('‚ùå Container not found for part:', part);
                    break;
                }
                
                // üîç Áªü‰∏ÄÊü•ÊâæÁé∞ÊúâÂàÜÁ±ªËäÇÁÇπÔºàÊîØÊåÅ‰∏çÂêåÁ±ªÂûãÁöÑËäÇÁÇπÁªìÊûÑÔºâ
                const allTreeNodes = currentContainer.querySelectorAll('.tree-node');
                let foundCategory = false;
                
                console.log(`üîç Searching in ${allTreeNodes.length} existing nodes for: "${part}"`);
                
                // Êü•ÊâæÁé∞ÊúâÂàÜÁ±ªÔºàÁªü‰∏ÄÂ§ÑÁêÜÊâÄÊúâÁ±ªÂûãÁöÑËäÇÁÇπÔºâ
                for (const node of allTreeNodes) {
                    const titleElement = node.querySelector('.node-title');
                    if (titleElement && titleElement.textContent.trim() === part) {
                        console.log(`‚úÖ Found existing category: "${part}"`);
                        // Â±ïÂºÄËøô‰∏™ËäÇÁÇπ
                        const expandBtn = node.querySelector('.node-expand');
                        const childrenContainer = node.querySelector('.node-children');
                        if (expandBtn && childrenContainer) {
                            expandBtn.innerHTML = '‚ñº';
                            childrenContainer.classList.add('expanded');
                            currentContainer = childrenContainer;
                            foundCategory = true;
                            break;
                        }
                    }
                }
                
                // Â¶ÇÊûúÂàÜÁ±ª‰∏çÂ≠òÂú®ÊâçÂàõÂª∫Êñ∞ÁöÑ
                if (!foundCategory) {
                    console.log(`üÜï Creating new tree-node: "${part}"`);
                    const newNode = createTreeNode(part, 'folder', false);
                    currentContainer.appendChild(newNode);
                    
                    // Êõ¥Êñ∞ÂΩìÂâçÂÆπÂô®Âà∞Êñ∞ËäÇÁÇπÁöÑÂ≠êÂÆπÂô®
                    const childrenContainer = newNode.querySelector('.node-children');
                    if (childrenContainer) {
                        currentContainer = childrenContainer;
                    }
                }
            }
            
            // üéØ Âè™Ë¥üË¥£ÂØºËà™Âà∞Êñá‰ª∂‰ΩçÁΩÆÔºå‰∏çÂàõÂª∫Êñá‰ª∂ÔºàÊñá‰ª∂Â∑≤Âú®addFileWithAIGuidanceAndStorage‰∏≠ÂàõÂª∫Ôºâ
            console.log(`üéØ Navigating to document "${fileName}" location`);
            console.log(`üìç Current container:`, currentContainer);
            console.log(`üìç Container class:`, currentContainer?.className);
            console.log(`üìç Container children count:`, currentContainer?.children.length);
            
            if (currentContainer && fileName) {
                // üîç Êü•ÊâæÂπ∂È´ò‰∫ÆÂ∑≤Â≠òÂú®ÁöÑÊñá‰ª∂
                const existingFile = Array.from(currentContainer.querySelectorAll(':scope > .tree-node')).find(node => {
                    const titleElement = node.querySelector('.node-title');
                    return titleElement && titleElement.textContent.trim() === fileName;
                });
                
                if (existingFile) {
                    console.log(`‚úÖ Found existing document "${fileName}", highlighting it`);
                    // È´ò‰∫ÆÂ∑≤Â≠òÂú®ÁöÑÊñá‰ª∂
                    const existingNodeContent = existingFile.querySelector('.node-content');
                    if (existingNodeContent) {
                        existingNodeContent.style.backgroundColor = '#f0f9ff';
                        existingNodeContent.style.border = '2px solid #3b82f6';
                        
                        // ÊªöÂä®Âà∞ËßÜÂõæ
                        setTimeout(() => {
                            existingNodeContent.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }, 300);
                        
                        // 3ÁßíÂêéÁßªÈô§È´ò‰∫Æ
                        setTimeout(() => {
                            existingNodeContent.style.backgroundColor = '';
                            existingNodeContent.style.border = '';
                        }, 3000);
                    }
                    console.log(`üéØ Document "${fileName}" highlighted successfully`);
                } else {
                    console.log(`‚ö†Ô∏è Document "${fileName}" not found in expected location`);
                }
            }
        }
        
        // ÊòæÁ§∫Êõø‰ª£Âª∫ËÆÆ
        function showAlternatives(index) {
            console.log('üîÑ Showing alternatives for index:', index);
            const alternativesDiv = document.getElementById(`alternatives-${index}`);
            
            if (alternativesDiv) {
                const isHidden = alternativesDiv.style.display === 'none' || alternativesDiv.style.display === '';
                alternativesDiv.style.display = isHidden ? 'block' : 'none';
                
                // Ê∑ªÂä†ËßÜËßâÂèçÈ¶à
                if (isHidden) {
                    alternativesDiv.style.animation = 'fadeIn 0.3s ease-in';
                    console.log('‚úÖ ÊòæÁ§∫ÂÖ∂‰ªñÈÄâÈ°π');
                } else {
                    console.log('‚úÖ ÈöêËóèÂÖ∂‰ªñÈÄâÈ°π');
                }
            } else {
                console.warn('‚ö†Ô∏è Êú™ÊâæÂà∞alternatives divÔºåindex:', index);
                
                // Ë∞ÉËØïÔºöÂàóÂá∫ÊâÄÊúâÂèØÁî®ÁöÑalternatives divs
                const allAlternatives = document.querySelectorAll('[id^="alternatives-"]');
                console.log('üîç ÂèØÁî®ÁöÑalternatives divs:', Array.from(allAlternatives).map(div => div.id));
                
                // ÊòæÁ§∫ÂèãÂ•ΩÁöÑÈîôËØØÊèêÁ§∫
                showNotification('‚ö†Ô∏è Êú™ÊâæÂà∞ÂÖ∂‰ªñÈÄâÈ°πÔºåËØ∑ÈáçËØï', 'warning');
            }
        }
        
        // ÈáçËØïÂàÜÊûê
        async function retryAnalysis(fileName, index) {
            console.log(`üîÑ ÈáçËØïÂàÜÊûê: ${fileName}`);
            showNotification(`üîÑ Ê≠£Âú®ÈáçËØïÂàÜÊûê "${fileName}"`);
            
            // ËøôÈáåÂèØ‰ª•ÈáçÊñ∞Ëß¶ÂèëÂàÜÊûêÊµÅÁ®ã
        }
        
        // Ê∏ÖÁêÜ‰∏ä‰º†Âå∫Âüü
        function clearUploadArea() {
            console.log('üßπ Clearing upload area');
            
            // Ê∏ÖÁ©∫Êñá‰ª∂ÂÆπÂô®
            const container = document.getElementById('uploadedFiles');
            if (container) {
                container.innerHTML = '';
            }
            
            // Ê∏ÖÁ©∫URLÂÜÖÂÆπÂå∫Âüü
            const urlContent = document.getElementById('urlContent');
            if (urlContent) {
                urlContent.style.display = 'none';
                urlContent.innerHTML = '';
            }
            
            // Ê∏ÖÁ©∫ËØ≠Èü≥ËΩ¨ÂΩïÂå∫Âüü
            const voiceTranscript = document.getElementById('voiceTranscript');
            if (voiceTranscript) {
                voiceTranscript.style.display = 'none';
                voiceTranscript.innerHTML = '';
            }
            
            // üî• Ê∏ÖÁ©∫ÁªìÊûúÊòæÁ§∫Âå∫Âüü
            const resultsContainer = document.getElementById('results');
            if (resultsContainer) {
                resultsContainer.innerHTML = '';
                console.log('üßπ Â∑≤Ê∏ÖÁ©∫ÁªìÊûúÊòæÁ§∫Âå∫Âüü');
            }
            
            // ÈáçÁΩÆÊñá‰ª∂ËæìÂÖ•
            const fileInputs = document.querySelectorAll('input[type="file"]');
            fileInputs.forEach(input => {
                input.value = '';
            });
            
            // Ê∏ÖÁ©∫ÂÖ®Â±ÄÊñá‰ª∂ÂèòÈáè
            window.currentUploadedFiles = [];
            
            // üî• Ê∏ÖÁ©∫ÂÖ®Â±ÄÁªìÊûúÁºìÂ≠ò
            window.lastAnalysisResult = null;
            window.lastProcessedContent = null;
            
            // ÈáçÁΩÆ‰∏ä‰º†Âå∫ÂüüÁä∂ÊÄÅ
            const uploadArea = document.querySelector('.upload-area');
            if (uploadArea) {
                uploadArea.style.borderColor = '#e2e8f0';
                uploadArea.style.backgroundColor = 'white';
            }
            
            // üîÑ Êô∫ËÉΩËæìÂÖ•Âå∫ÂüüÊó†ÈúÄÂàáÊç¢Ê®°ÂºèÔºåÂõ†‰∏∫Â∑≤ÁªèÁªü‰∏Ä‰∫Ü
            console.log('ü§ñ Smart input area - no mode switching needed');
            
            console.log('‚úÖ Upload area cleared');
        }
        
        // ÁîüÊàêÂîØ‰∏ÄID
        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }
        
        // Ëé∑ÂèñÊñá‰ª∂Á±ªÂûã
        function getFileType(file) {
            const extension = file.name.split('.').pop()?.toLowerCase();
            const mimeType = file.type;
            
            if (mimeType.startsWith('text/')) return 'text';
            if (mimeType.startsWith('application/')) return 'application';
            if (mimeType.startsWith('image/')) return 'image';
            
            return extension || 'unknown';
        }
        
        // ÊòæÁ§∫Êñá‰ª∂ÂÜÖÂÆπ
        function showFileContent(file) {
            console.log('üëÅÔ∏è Showing file content:', file.name);
            
            // ÂàõÂª∫Ê®°ÊÄÅÊ°ÜÊòæÁ§∫Êñá‰ª∂ÂÜÖÂÆπ
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.5); z-index: 9999;
                display: flex; align-items: center; justify-content: center;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white; padding: 24px; border-radius: 12px; 
                    max-width: 80%; max-height: 80%; overflow-y: auto;
                    box-shadow: 0 25px 80px rgba(0,0,0,0.3);
                ">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <h3 style="margin: 0; color: #1f2937;">üìÑ ${file.name}</h3>
                        <button onclick="this.closest('div').remove()" style="
                            background: #ef4444; color: white; border: none;
                            width: 32px; height: 32px; border-radius: 50%; cursor: pointer;
                        ">‚úï</button>
                    </div>
                    
                    <div style="
                        background: #f8fafc; border: 1px solid #e2e8f0; 
                        padding: 16px; border-radius: 8px; white-space: pre-wrap;
                        font-family: 'Courier New', monospace; font-size: 12px;
                        max-height: 400px; overflow-y: auto;
                    ">
                        ${file.content || 'ÂÜÖÂÆπÂä†ËΩΩ‰∏≠...'}
                    </div>
                    
                    <div style="margin-top: 16px; font-size: 12px; color: #6b7280;">
                        Ë∑ØÂæÑ: ${file.path} | Â§ßÂ∞è: ${formatFileSize(file.size)} | ‰∏ä‰º†: ${new Date(file.uploadDate).toLocaleString()}
                    </div>
                </div>
            `;
            
            // ÁÇπÂáªËÉåÊôØÂÖ≥Èó≠
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
            
            document.body.appendChild(modal);
        }
        
        // CSS Âä®ÁîªÊ†∑Âºè
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideInUp {
                from {
                    opacity: 0;
                    transform: translateY(30px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
            
            @keyframes spin {
                from { transform: rotate(0deg); }
                to { transform: rotate(360deg); }
            }
            
            .spinner {
                animation: spin 1s linear infinite;
            }
            
            @keyframes modalSlideIn {
                from { 
                    opacity: 0; 
                    transform: scale(0.9) translateY(-20px); 
                }
                to { 
                    opacity: 1; 
                    transform: scale(1) translateY(0); 
                }
            }
        `;
        document.head.appendChild(style);
        
        // Process uploaded files
        function processUploadedFilesLegacy(files) {
            // Legacy function for compatibility
            // Simulate AI content extraction and categorization
            setTimeout(() => {
                processFilesWithAI(files);
            }, 1000);
        }

        function getFileIcon(mimeType) {
            if (mimeType.includes('pdf')) return 'üìÑ';
            if (mimeType.includes('word') || mimeType.includes('document')) return 'üìù';
            if (mimeType.includes('excel') || mimeType.includes('spreadsheet')) return 'üìä';
            if (mimeType.includes('image')) return 'üñºÔ∏è';
            if (mimeType.includes('text')) return 'üìã';
            return 'üìé';
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1048576) return Math.round(bytes / 1024) + ' KB';
            return Math.round(bytes / 1048576 * 100) / 100 + ' MB';
        }

        window.removeFile = function(button) {
            button.parentElement.remove();
        }

        // Voice recording
        window.toggleVoiceRecording = function() {
            const btn = document.getElementById('voiceBtn');
            const status = document.getElementById('voiceStatus');
            const transcript = document.getElementById('voiceTranscript');
            
            if (!isRecording) {
                // Start recording
                startVoiceRecording();
                btn.innerHTML = '‚èπÔ∏è Stop Recording';
                btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                status.textContent = 'üî¥';
                isRecording = true;
            } else {
                // Stop recording
                stopVoiceRecording();
                btn.innerHTML = 'üé§ Start Recording';
                btn.style.background = 'linear-gradient(135deg, #ef4444, #dc2626)';
                status.textContent = 'üéôÔ∏è';
                isRecording = false;
            }
        }

        function startVoiceRecording() {
            if ('webkitSpeechRecognition' in window) {
                recognition = new webkitSpeechRecognition();
                recognition.continuous = true;
                recognition.interimResults = true;
                
                recognition.onresult = function(event) {
                    let transcript = '';
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        transcript += event.results[i][0].transcript;
                    }
                    document.getElementById('voiceTranscript').textContent = transcript;
                    document.getElementById('voiceTranscript').style.display = 'block';
                };
                
                recognition.start();
            } else {
                showNotification('‚ö†Ô∏è Voice recognition not supported in this browser');
            }
        }

        function stopVoiceRecording() {
            if (recognition) {
                recognition.stop();
                recognition = null;
            }
        }

        // URL content fetching
        window.fetchUrlContent = function() {
            const url = document.getElementById('urlInput').value;
            const content = document.getElementById('urlContent');
            
            if (!url) {
                showNotification('‚ö†Ô∏è Please enter a valid URL');
                return;
            }
            
            // Simulate URL content fetching
            content.style.display = 'block';
            content.innerHTML = '<div style="text-align: center; padding: 20px; color: #6b7280;">üîÑ Fetching content...</div>';
            
            setTimeout(() => {
                content.innerHTML = `
                    <h3 style="margin: 0 0 12px 0; color: #1f2937;">üìñ Content Preview</h3>
                    <p style="color: #4b5563; line-height: 1.6;">
                        This is a simulated preview of the fetched content from: <strong>${url}</strong>
                        <br><br>
                        In a real implementation, this would use a web scraping service or API to extract the actual content from the provided URL, including text, images, and metadata.
                    </p>
                    <div style="margin-top: 16px; padding: 12px; background: #f3f4f6; border-radius: 6px; font-size: 12px; color: #6b7280;">
                        <strong>Note:</strong> URL content fetching requires backend integration with services like Puppeteer, Scrapy, or commercial APIs like Mercury or Diffbot.
                    </div>
                `;
                showNotification('üîó URL content fetched successfully!');
            }, 1500);
        }

        // AI Content Processing System (Simulation)
        function processFilesWithAI(files) {
            showNotification('ü§ñ AI is analyzing your files...');
            
            Array.from(files).forEach(async (file, index) => {
                setTimeout(async () => {
                    try {
                        const analysis = await simulateAIAnalysis(file);
                        showAIAnalysisResult(file, analysis);
                    } catch (error) {
                        console.error('Analysis failed for file:', file.name, error);
                        showAIAnalysisResult(file, {
                            category: { name: "‚ùå Analysis Failed", confidence: 0, reason: "Service unavailable" },
                            entities: [], relationships: [], keyInsights: ["Analysis service unavailable"]
                        });
                    }
                }, (index + 1) * 1500);
            });
        }

        async function simulateAIAnalysis(file) {
            // GraphRAG-powered multi-modal analysis
            console.log('üöÄ Starting GraphRAG-powered analysis for:', file.name, file.type, file.size);
            
            try {
                // Use GraphRAG service for analysis
                const graphRAGResult = await graphRAGService.analyzeContent(file, {
                    includeGraph: true,
                    extractEntities: true,
                    identifyRelationships: true,
                    generateInsights: true
                });
                
                console.log('üìä GraphRAG analysis complete:', graphRAGResult);
                
                // Transform GraphRAG result to match expected format
                const transformedResult = {
                    category: {
                        name: graphRAGResult.bestMatch?.name || "üìà Analytics & Data",
                        confidence: graphRAGResult.confidence || 0.8,
                        reason: graphRAGResult.bestMatch?.reason || "Analyzed using GraphRAG multi-modal intelligence",
                        isNewCategory: graphRAGResult.isNewCategory || false
                    },
                    entities: graphRAGResult.entities || [],
                    relationships: graphRAGResult.relationships || [],
                    concepts: graphRAGResult.concepts || [],
                    keyInsights: graphRAGResult.keyInsights || [],
                    suggestedActions: graphRAGResult.suggestedActions || [
                        `Add to knowledge base under ${graphRAGResult.bestMatch?.name || "General"}`,
                        "Create cross-reference with related documents",
                        "Schedule for team review",
                        "Include in next insight analysis"
                    ],
                    reasoning: graphRAGResult.reasoning || [],
                    graphData: graphRAGResult.graphData || null,
                    isSimulated: graphRAGResult.isSimulated || false,
                    serviceStatus: graphRAGResult.serviceStatus || 'connected'
                };
                
                // Add GraphRAG-specific enhancements
                if (graphRAGResult.summary) {
                    transformedResult.summary = graphRAGResult.summary;
                }
                
                return transformedResult;
                
            } catch (error) {
                console.error('‚ùå GraphRAG analysis failed, using fallback:', error);
                // Fallback to enhanced analysis
                const fallbackResult = await performEnhancedAnalysis(file, 
                    graphRAGService.getExistingCategories(), 
                    graphRAGService.getPotentialNewCategories()
                );
                
                return {
                    category: {
                        name: fallbackResult.bestMatch?.name || "üìà Analytics & Data",
                        confidence: fallbackResult.confidence || 0.7,
                        reason: fallbackResult.bestMatch?.reason || "Fallback analysis due to service unavailability",
                        isNewCategory: fallbackResult.isNewCategory || false
                    },
                    entities: [
                        { name: "Content Marketing Strategy", type: "concept", confidence: 0.8 },
                        { name: "Digital Transformation", type: "theme", confidence: 0.7 }
                    ],
                    relationships: [
                        { source: "Content Marketing", target: "Digital Strategy", type: "supports", strength: 0.8 }
                    ],
                    keyInsights: [
                        "Document contains strategic planning elements",
                        "GraphRAG service temporarily unavailable - using enhanced fallback",
                        "Integration opportunities with existing content workflows"
                    ],
                    suggestedActions: [
                        `Add to knowledge base under ${fallbackResult.bestMatch?.name || "General"}`,
                        "Create cross-reference with related documents", 
                        "Retry GraphRAG analysis when service is available"
                    ],
                    reasoning: fallbackResult.factors || [],
                    isSimulated: true,
                    serviceStatus: 'fallback'
                };
            }
        }
        
        // Keep the original function structure but update the content
        function originalSimulateAIAnalysis(file) {
            
            const existingCategories = [
                { 
                    name: "üìä Market Research", 
                    confidence: 0.85, 
                    reason: "Contains market data and consumer insights",
                    keywords: ["market", "research", "survey", "consumer", "audience", "demographic", "trend", "analysis"],
                    fileTypes: ["xlsx", "csv", "pdf", "docx"],
                    minConfidence: 0.7
                },
                { 
                    name: "‚úçÔ∏è Content Strategy", 
                    confidence: 0.78, 
                    reason: "Includes content planning and editorial guidelines",
                    keywords: ["content", "blog", "editorial", "writing", "article", "copy", "seo", "publishing"],
                    fileTypes: ["docx", "txt", "md", "pdf"],
                    minConfidence: 0.6
                },
                { 
                    name: "üì± Social Media", 
                    confidence: 0.92, 
                    reason: "Social media metrics and campaign data detected",
                    keywords: ["social", "instagram", "tiktok", "facebook", "twitter", "linkedin", "engagement", "follower"],
                    fileTypes: ["png", "jpg", "jpeg", "pdf", "xlsx"],
                    minConfidence: 0.8
                },
                { 
                    name: "üìà Analytics & Data", 
                    confidence: 0.89, 
                    reason: "Performance metrics and statistical analysis",
                    keywords: ["analytics", "data", "kpi", "metrics", "performance", "dashboard", "report", "statistics"],
                    fileTypes: ["xlsx", "csv", "json", "pdf"],
                    minConfidence: 0.75
                },
                { 
                    name: "üéØ Campaign Planning", 
                    confidence: 0.74, 
                    reason: "Campaign objectives and target audience info",
                    keywords: ["campaign", "strategy", "plan", "launch", "marketing", "promotion", "advertising"],
                    fileTypes: ["pptx", "pdf", "docx"],
                    minConfidence: 0.65
                }
            ];
            
            // Potential new categories that AI might discover
            const potentialNewCategories = [
                { name: "üé® Brand Design", confidence: 0.88, reason: "Visual branding and design assets detected" },
                { name: "üìß Email Marketing", confidence: 0.82, reason: "Email campaign templates and automation workflows" },
                { name: "üé• Video Content", confidence: 0.90, reason: "Video production scripts and multimedia content" },
                { name: "üìû Customer Support", confidence: 0.75, reason: "Support documentation and customer service materials" },
                { name: "üí∞ Sales Materials", confidence: 0.83, reason: "Sales presentations and lead generation content" },
                { name: "üîç SEO & Keywords", confidence: 0.87, reason: "Search engine optimization and keyword research" },
                { name: "üì± Mobile App", confidence: 0.79, reason: "Mobile application development and UX content" },
                { name: "üõí E-commerce", confidence: 0.85, reason: "Product descriptions and online store content" },
                { name: "üìä Business Intelligence", confidence: 0.91, reason: "Business reporting and data visualization" },
                { name: "üéì Training & Education", confidence: 0.73, reason: "Educational materials and training content" }
            ];
            
            // Create a consistent hash from filename for deterministic results
            const filename = file.name.toLowerCase();
            let hash = 0;
            for (let i = 0; i < filename.length; i++) {
                const char = filename.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            
            // Enhanced multi-factor analysis
            const analysisResults = performEnhancedAnalysis(file, existingCategories, potentialNewCategories);
            
            console.log('üîç Analysis results:', analysisResults);
            
            let selectedCategory = analysisResults.bestMatch;
            selectedCategory.isNewCategory = analysisResults.isNewCategory;
            
            // Update reason with detailed analysis
            selectedCategory.reason = `${selectedCategory.reason} (Score: ${Math.round(analysisResults.confidence * 100)}%, based on ${analysisResults.factors.join(', ')})`;
            selectedCategory.confidence = analysisResults.confidence;
            
            return {
                category: selectedCategory,
                entities: [
                    "Australia Market", "Tech Industry", "B2B Strategy", 
                    "Content Marketing", "Social Media ROI"
                ],
                keywords: [
                    "market penetration", "audience engagement", "conversion rate",
                    "brand awareness", "competitive analysis"
                ],
                suggestedActions: [
                    "Add to knowledge base under " + selectedCategory.name,
                    "Create cross-reference with related documents",
                    "Schedule for team review",
                    "Include in next insight analysis"
                ]
            };
        }
        
        function performEnhancedAnalysis(file, existingCategories, potentialNewCategories) {
            const filename = file.name.toLowerCase();
            const fileExtension = filename.split('.').pop() || '';
            const fileSize = file.size;
            const allCategories = [...existingCategories, ...potentialNewCategories.map(cat => ({...cat, isNewCategory: true}))];
            
            console.log('üìä Analyzing file:', {filename, fileExtension, fileSize});
            
            let bestMatch = null;
            let bestScore = 0;
            let analysisFactors = [];
            
            // Score each category
            allCategories.forEach(category => {
                let score = 0;
                let factors = [];
                
                // 1. Keyword matching (40% weight)
                if (category.keywords) {
                    const keywordMatches = category.keywords.filter(keyword => 
                        filename.includes(keyword)
                    ).length;
                    const keywordScore = (keywordMatches / category.keywords.length) * 0.4;
                    score += keywordScore;
                    if (keywordMatches > 0) {
                        factors.push(`${keywordMatches} keyword matches`);
                    }
                }
                
                // 2. File type compatibility (30% weight)
                if (category.fileTypes && category.fileTypes.includes(fileExtension)) {
                    score += 0.3;
                    factors.push('compatible file type');
                }
                
                // 3. File size heuristics (15% weight)
                const sizeScore = getFileSizeScore(fileSize, category);
                score += sizeScore * 0.15;
                if (sizeScore > 0.5) {
                    factors.push('appropriate file size');
                }
                
                // 4. Pattern recognition (15% weight)
                const patternScore = getPatternScore(filename, category);
                score += patternScore * 0.15;
                if (patternScore > 0.5) {
                    factors.push('filename patterns');
                }
                
                // Apply minimum confidence threshold
                if (category.minConfidence && score < category.minConfidence) {
                    score *= 0.5; // Penalize low confidence matches
                }
                
                console.log(`üìã Category: ${category.name}, Score: ${score.toFixed(3)}, Factors: ${factors.join(', ')}`);
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMatch = {...category};
                    analysisFactors = factors;
                }
            });
            
            // If no good match found, use intelligent fallback
            if (bestScore < 0.3) {
                console.log('‚ö†Ô∏è Low confidence match, using intelligent fallback');
                bestMatch = getIntelligentFallback(file, existingCategories);
                analysisFactors = ['intelligent fallback based on file characteristics'];
                bestScore = 0.5;
            }
            
            return {
                bestMatch: bestMatch,
                confidence: Math.min(bestScore, 0.95), // Cap at 95%
                isNewCategory: bestMatch.isNewCategory || false,
                factors: analysisFactors
            };
        }
        
        function getFileSizeScore(fileSize, category) {
            // Different categories have different typical file sizes
            const sizeRanges = {
                "üìä Market Research": {min: 50000, max: 10000000}, // 50KB - 10MB
                "‚úçÔ∏è Content Strategy": {min: 5000, max: 500000},   // 5KB - 500KB
                "üì± Social Media": {min: 100000, max: 50000000},   // 100KB - 50MB
                "üìà Analytics & Data": {min: 10000, max: 100000000}, // 10KB - 100MB
                "üéØ Campaign Planning": {min: 100000, max: 20000000}  // 100KB - 20MB
            };
            
            const range = sizeRanges[category.name];
            if (!range) return 0.5; // Neutral score for unknown categories
            
            if (fileSize >= range.min && fileSize <= range.max) {
                return 1.0; // Perfect size match
            } else if (fileSize < range.min) {
                return Math.max(0.2, fileSize / range.min);
            } else {
                return Math.max(0.2, range.max / fileSize);
            }
        }
        
        function getPatternScore(filename, category) {
            // Advanced pattern recognition based on common naming conventions
            const patterns = {
                "üìä Market Research": [/research/i, /survey/i, /analysis/i, /report/i, /study/i],
                "‚úçÔ∏è Content Strategy": [/content/i, /blog/i, /article/i, /copy/i, /editorial/i],
                "üì± Social Media": [/social/i, /post/i, /campaign/i, /engagement/i],
                "üìà Analytics & Data": [/data/i, /analytics/i, /metrics/i, /dashboard/i, /kpi/i],
                "üéØ Campaign Planning": [/campaign/i, /strategy/i, /plan/i, /marketing/i, /launch/i]
            };
            
            const categoryPatterns = patterns[category.name] || [];
            const matches = categoryPatterns.filter(pattern => pattern.test(filename)).length;
            
            return matches > 0 ? Math.min(1.0, matches / categoryPatterns.length * 2) : 0;
        }
        
        function getIntelligentFallback(file, existingCategories) {
            const filename = file.name.toLowerCase();
            const fileExtension = filename.split('.').pop() || '';
            
            // Smart fallback based on file extension and basic patterns
            if (['xlsx', 'csv', 'json'].includes(fileExtension)) {
                return existingCategories.find(cat => cat.name === "üìà Analytics & Data") || existingCategories[0];
            } else if (['docx', 'txt', 'md'].includes(fileExtension)) {
                return existingCategories.find(cat => cat.name === "‚úçÔ∏è Content Strategy") || existingCategories[0];
            } else if (['pptx', 'ppt'].includes(fileExtension)) {
                return existingCategories.find(cat => cat.name === "üéØ Campaign Planning") || existingCategories[0];
            } else if (['png', 'jpg', 'jpeg', 'gif'].includes(fileExtension)) {
                return existingCategories.find(cat => cat.name === "üì± Social Media") || existingCategories[0];
            } else {
                // Default to first category
                return existingCategories[0];
            }
        }

        function showAIAnalysisResult(file, analysis) {
            // Create AI analysis modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.5); z-index: 9999;
                display: flex; align-items: center; justify-content: center;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white; padding: 32px; border-radius: 16px; max-width: 600px;
                    width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 25px 80px rgba(0,0,0,0.3);
                ">
                    <div style="display: flex; align-items: center; margin-bottom: 24px;">
                        <span style="font-size: 32px; margin-right: 12px;">ü§ñ</span>
                        <h2 style="margin: 0; color: #1f2937;">AI Analysis Complete</h2>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <h3 style="color: #374151; font-size: 16px; margin: 0 0 8px 0;">üìÑ File: ${file.name}</h3>
                    </div>
                    
                    <!-- GraphRAG Analysis Results -->
                    <div style="background: ${analysis.category.isNewCategory ? '#fef3c7' : '#f0f9ff'}; border-left: 4px solid ${analysis.category.isNewCategory ? '#f59e0b' : '#0ea5e9'}; padding: 16px; margin-bottom: 20px; border-radius: 0 8px 8px 0; position: relative;">
                        <h4 style="margin: 0 0 8px 0; color: ${analysis.category.isNewCategory ? '#92400e' : '#0c4a6e'};">
                            ${analysis.isSimulated ? 'üî¨ Enhanced AI Analysis' : 'üß† GraphRAG Intelligence'} 
                            ${analysis.category.isNewCategory ? 'üÜï New Category' : 'üéØ Classification'}
                        </h4>
                        <div style="font-weight: 600; color: ${analysis.category.isNewCategory ? '#d97706' : '#1e40af'}; font-size: 18px;">${analysis.category.name}</div>
                        <div style="font-size: 14px; color: ${analysis.category.isNewCategory ? '#a16207' : '#0369a1'}; margin-top: 4px;">
                            Confidence: ${Math.round(analysis.category.confidence * 100)}% - ${analysis.category.reason}
                        </div>
                        
                        <!-- Service Status Indicator -->
                        <div style="position: absolute; top: 16px; right: 16px; display: flex; align-items: center; font-size: 12px;">
                            <div style="width: 8px; height: 8px; border-radius: 50%; margin-right: 6px; background: ${
                                analysis.serviceStatus === 'connected' ? '#10b981' : 
                                analysis.serviceStatus === 'multi-agent-fallback' ? '#8b5cf6' : 
                                analysis.serviceStatus === 'fallback' ? '#f59e0b' : '#ef4444'
                            };"></div>
                            ${
                                analysis.serviceStatus === 'connected' ? 'GraphRAG' : 
                                analysis.serviceStatus === 'multi-agent-fallback' ? 'Multi-Agent' : 
                                analysis.serviceStatus === 'fallback' ? 'Enhanced' : 'Offline'
                            }
                            ${analysis.isMultiAgent ? ' ü§ñüîÑüî¨' : ''}
                        </div>
                        
                        ${analysis.category.isNewCategory ? `
                            <div style="background: rgba(251, 191, 36, 0.1); border-radius: 6px; padding: 12px; margin-top: 12px; border: 1px solid #fbbf24;">
                                <strong style="color: #92400e;">üìã New Category Action:</strong>
                                <div style="color: #a16207; font-size: 13px; margin-top: 4px;">
                                    This content doesn't fit existing categories. AI will create a new "${analysis.category.name}" section in your knowledge base.
                                </div>
                            </div>
                        ` : ''}
                    </div>
                    
                    ${analysis.isMultiAgent && analysis.multiAgentAnalysis ? `
                    <!-- Multi-Agent Analysis Section -->
                    <div style="background: linear-gradient(135deg, #8b5cf6, #7c3aed); color: white; padding: 20px; margin-bottom: 20px; border-radius: 12px; box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);">
                        <h4 style="margin: 0 0 16px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                            ü§ñ Multi-Agent Analysis Pipeline
                            <div style="background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 6px; font-size: 12px; margin-left: 12px;">
                                ${analysis.multiAgentAnalysis.fusedInsights?.activeAgents?.length || 0}/3 Active
                            </div>
                        </h4>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-bottom: 16px;">
                            ${['GraphAgent', 'HybridAgent', 'DeepResearchAgent'].map(agentName => {
                                const agent = analysis.multiAgentAnalysis[agentName.toLowerCase()] || analysis.multiAgentAnalysis[agentName.toLowerCase().replace('agent', 'Agent')];
                                const isActive = analysis.multiAgentAnalysis.fusedInsights?.activeAgents?.includes(agentName);
                                const icons = { GraphAgent: 'üï∏Ô∏è', HybridAgent: 'üîÑ', DeepResearchAgent: 'üîç' };
                                
                                return `
                                    <div style="background: rgba(255,255,255,0.15); padding: 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2);">
                                        <div style="display: flex; align-items: center; margin-bottom: 6px;">
                                            <span style="font-size: 16px; margin-right: 6px;">${icons[agentName]}</span>
                                            <span style="font-size: 12px; font-weight: 500;">${agentName.replace('Agent', '')}</span>
                                            <div style="margin-left: auto;">
                                                ${isActive ? 
                                                    '<div style="width: 6px; height: 6px; background: #10b981; border-radius: 50%;"></div>' : 
                                                    '<div style="width: 6px; height: 6px; background: #ef4444; border-radius: 50%;"></div>'
                                                }
                                            </div>
                                        </div>
                                        <div style="font-size: 10px; opacity: 0.8; line-height: 1.3;">
                                            ${isActive ? 
                                                (agent?.confidence ? `Confidence: ${Math.round(agent.confidence * 100)}%` : 'Active') : 
                                                'Inactive'
                                            }
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        
                        ${analysis.multiAgentAnalysis.fusedInsights?.fusedInsights?.length > 0 ? `
                        <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2);">
                            <h5 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 600;">üîÆ Fused Insights</h5>
                            <ul style="margin: 0; padding-left: 16px; font-size: 12px; line-height: 1.4;">
                                ${analysis.multiAgentAnalysis.fusedInsights.fusedInsights.map(insight => `
                                    <li style="margin-bottom: 4px; opacity: 0.9;">${insight}</li>
                                `).join('')}
                            </ul>
                        </div>
                        ` : ''}
                        
                        ${analysis.multiAgentAnalysis.fusedInsights?.agentConsensus ? `
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.2);">
                            <div style="font-size: 12px; opacity: 0.8;">
                                Consensus: ${analysis.multiAgentAnalysis.fusedInsights.agentConsensus.agreementLevel}
                            </div>
                            <div style="font-size: 12px; opacity: 0.8;">
                                Topics: ${analysis.multiAgentAnalysis.fusedInsights.agentConsensus.commonTopics?.length || 0}
                            </div>
                        </div>
                        ` : ''}
                    </div>
                    ` : ''}
                    
                    ${analysis.hasGraphReasoning && analysis.graphReasoning ? `
                    <!-- Graph-Based Reasoning Section -->
                    <div style="background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 20px; margin-bottom: 20px; border-radius: 12px; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);">
                        <h4 style="margin: 0 0 16px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                            üß† Graph-Based Reasoning
                            <div style="background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 6px; font-size: 12px; margin-left: 12px;">
                                Score: ${Math.round((analysis.graphReasoning.reasoningScore || 0) * 100)}%
                            </div>
                        </h4>
                        
                        ${analysis.graphReasoning.centralConcepts?.length > 0 ? `
                        <div style="background: rgba(255,255,255,0.15); padding: 12px; border-radius: 8px; margin-bottom: 12px; border: 1px solid rgba(255,255,255,0.2);">
                            <h5 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 600;">üéØ Central Concepts</h5>
                            <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                ${analysis.graphReasoning.centralConcepts.slice(0, 3).map(concept => `
                                    <div style="background: rgba(255,255,255,0.2); padding: 6px 10px; border-radius: 6px; font-size: 12px;">
                                        ${concept.label} (${concept.connectivity} connections)
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        ` : ''}
                        
                        ${analysis.enhancedInsights?.length > 0 ? `
                        <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2);">
                            <h5 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 600;">üí° Graph-Enhanced Insights</h5>
                            <ul style="margin: 0; padding-left: 16px; font-size: 12px; line-height: 1.4;">
                                ${analysis.enhancedInsights.slice(0, 3).map(insight => `
                                    <li style="margin-bottom: 4px; opacity: 0.9;">
                                        ${insight.content} 
                                        <span style="opacity: 0.7; font-size: 10px;">(${Math.round((insight.confidence || 0) * 100)}%)</span>
                                    </li>
                                `).join('')}
                            </ul>
                        </div>
                        ` : ''}
                        
                        ${analysis.reasoningPaths?.length > 0 ? `
                        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.2);">
                            <h5 style="margin: 0 0 8px 0; font-size: 12px; font-weight: 600; opacity: 0.9;">üîç Reasoning Path Preview</h5>
                            <div style="font-size: 11px; opacity: 0.8; line-height: 1.3;">
                                ${analysis.reasoningPaths[0].steps.slice(0, 2).join(' ‚Üí ')}...
                            </div>
                        </div>
                        ` : ''}
                    </div>
                    ` : ''}
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 20px;">
                        <div>
                            <h4 style="margin: 0 0 8px 0; color: #374151; font-size: 14px;">üîç Key Entities</h4>
                            <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                ${analysis.entities.map(entity => `
                                    <span style="background: #ddd6fe; color: #5b21b6; padding: 4px 8px; border-radius: 12px; font-size: 12px;">
                                        ${entity}
                                    </span>
                                `).join('')}
                            </div>
                        </div>
                        <div>
                            <h4 style="margin: 0 0 8px 0; color: #374151; font-size: 14px;">üè∑Ô∏è Keywords</h4>
                            <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                ${analysis.keywords.map(keyword => `
                                    <span style="background: #fed7d7; color: #c53030; padding: 4px 8px; border-radius: 12px; font-size: 12px;">
                                        ${keyword}
                                    </span>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 24px;">
                        <h4 style="margin: 0 0 8px 0; color: #374151; font-size: 14px;">üí° Suggested Actions</h4>
                        <ul style="margin: 0; padding-left: 20px; color: #4b5563;">
                            ${analysis.suggestedActions.map(action => `<li style="margin-bottom: 4px;">${action}</li>`).join('')}
                        </ul>
                    </div>
                    
                    <div style="display: flex; gap: 12px; justify-content: flex-end;">
                        <button onclick="this.closest('.modal').remove()" style="
                            background: #e5e7eb; color: #374151; border: none; padding: 10px 20px;
                            border-radius: 8px; cursor: pointer; font-weight: 500;
                        ">Cancel</button>
                        <button onclick="acceptAISuggestion('${file.name}', '${analysis.category.name}'); this.closest('.modal').remove()" style="
                            background: #667eea; color: white; border: none; padding: 10px 20px;
                            border-radius: 8px; cursor: pointer; font-weight: 600;
                        ">‚úÖ Accept & Add to Knowledge Base</button>
                    </div>
                    
                    <!-- Knowledge Graph Visualization Section -->
                    ${analysis.graphData && (analysis.graphData.nodes?.length > 0 || analysis.graphData.edges?.length > 0) ? `
                        <div style="margin: 24px 0; border-top: 1px solid #e5e7eb; padding-top: 20px;">
                            <h4 style="margin: 0 0 12px 0; color: #374151; font-size: 15px; font-weight: 600;">üï∏Ô∏è Knowledge Graph Visualization</h4>
                            <div id="graph-${Date.now()}" style="background: linear-gradient(135deg, #f9fafb, #f3f4f6); border: 2px solid #e5e7eb; border-radius: 8px; height: 280px; position: relative; overflow: hidden; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);">
                                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #6b7280;">
                                    <div style="font-size: 48px; margin-bottom: 12px; opacity: 0.6;">üï∏Ô∏è</div>
                                    <div style="font-size: 16px; font-weight: 600; color: #374151; margin-bottom: 6px;">Interactive Knowledge Graph</div>
                                    <div style="font-size: 13px; margin: 6px 0; color: #6b7280;">
                                        <span style="background: #ddd6fe; color: #7c3aed; padding: 2px 8px; border-radius: 12px; margin: 0 4px;">
                                            ${analysis.graphData.nodes?.length || 0} entities
                                        </span>
                                        <span style="background: #fecaca; color: #dc2626; padding: 2px 8px; border-radius: 12px; margin: 0 4px;">
                                            ${analysis.graphData.edges?.length || 0} relationships
                                        </span>
                                    </div>
                                    <button onclick="visualizeGraph('${Date.now()}', ${JSON.stringify(analysis.graphData).replace(/"/g, '&quot;')})" 
                                            style="margin-top: 12px; padding: 8px 20px; background: linear-gradient(135deg, #8b5cf6, #7c3aed); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; box-shadow: 0 2px 4px rgba(139, 92, 246, 0.2); transition: all 0.2s;">
                                        üéØ Visualize Knowledge Graph
                                    </button>
                                </div>
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
            
            modal.classList.add('modal');
            document.body.appendChild(modal);
        }

        window.acceptAISuggestion = function(filename, category) {
            console.log('üîÑ Processing AI suggestion for:', filename, category);
            
            // Check if this is a new category that needs to be created
            const newCategories = [
                "üé® Brand Design", "üìß Email Marketing", "üé• Video Content", "üìû Customer Support",
                "üí∞ Sales Materials", "üîç SEO & Keywords", "üì± Mobile App", "üõí E-commerce",
                "üìä Business Intelligence", "üéì Training & Education"
            ];
            
            const isNewCategory = newCategories.includes(category);
            
            if (isNewCategory) {
                console.log('üÜï Creating new category:', category);
                const success = createNewCategoryAndAddFile(filename, category);
                if (success) {
                    showNotification(`üéâ Created new category "${category}" and added "${filename}"!\nüìç ‰ΩçÁΩÆ: ${category} > ${filename}`);
                    console.log(`‚úÖ New category created and file added: ${category} > ${filename}`);
                } else {
                    showNotification(`‚ùå ÂàõÂª∫Êñ∞Á±ªÂà´Êó∂Âá∫Èîô`);
                }
            } else {
                // Existing category logic
                const categoryMapping = {
                    "üìä Market Research": "Marketing Strategy",
                    "‚úçÔ∏è Content Strategy": "Content Creation", 
                    "üì± Social Media": "Marketing Strategy",
                    "üìà Analytics & Data": "Content Creation",
                    "üéØ Campaign Planning": "Marketing Strategy"
                };
                
                const targetFolder = categoryMapping[category] || "Marketing Strategy";
                const success = addFileToKnowledgeTree(filename, category, targetFolder);
                
                if (success) {
                    showNotification(`üéâ Êñá‰ª∂ "${filename}" Â∑≤ÊàêÂäüÊ∑ªÂä†Âà∞Áü•ËØÜÂ∫ìÔºÅ\nüìç ‰ΩçÁΩÆ: ${targetFolder} > ${getSubfolderName(category)} > ${filename}`);
                    console.log(`‚úÖ File ${filename} added to knowledge tree: ${targetFolder} > ${getSubfolderName(category)} > ${filename}`);
                } else {
                    showNotification(`‚ùå Ê∑ªÂä†Êñá‰ª∂ "${filename}" Âà∞Áü•ËØÜÂ∫ìÊó∂Âá∫Èîô`);
                }
            }
        }
        
        function getSubfolderName(category) {
            const subfolders = {
                "üìä Market Research": "Â∏ÇÂú∫Á†îÁ©∂ÊñáÊ°£",
                "‚úçÔ∏è Content Strategy": "ÂÜÖÂÆπÁ≠ñÁï•ÊñáÊ°£", 
                "üì± Social Media": "Á§æ‰∫§Â™í‰ΩìÊñáÊ°£",
                "üìà Analytics & Data": "Êï∞ÊçÆÂàÜÊûêÊñáÊ°£",
                "üéØ Campaign Planning": "Ëê•ÈîÄÊ¥ªÂä®ÊñáÊ°£"
            };
            return subfolders[category] || "ÂÖ∂‰ªñÊñáÊ°£";
        }
        
        // Âà†Èô§‰∫ÜÈáçÂ§çÁöÑÈîôËØØÁâàÊú¨ÁöÑaddFileToKnowledgeTreeÂáΩÊï∞Ôºå‰ΩøÁî®7165Ë°åÁöÑÊ≠£Á°ÆÁâàÊú¨
        
        function createNewCategoryAndAddFile(filename, categoryName) {
            try {
                console.log('üèóÔ∏è Creating new main category:', categoryName);
                
                // Find the knowledge tree container
                const knowledgeTree = document.getElementById('knowledgeTree');
                if (!knowledgeTree) {
                    console.error('‚ùå Knowledge tree not found');
                    return false;
                }
                
                // Create the new main category folder
                const newMainCategory = document.createElement('div');
                newMainCategory.className = 'tree-node';
                newMainCategory.innerHTML = `
                    <div class="node-content" onclick="selectNode(this, event)" draggable="true" 
                         ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                         ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                        <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                        <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                        <div class="node-icon folder">üìÅ</div>
                        <div class="node-title" ondblclick="editNodeTitle(event, this)">${categoryName}</div>
                        <div class="node-actions">
                            <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                            <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                            <button class="node-action" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                        </div>
                    </div>
                    <div class="node-children expanded">
                        <div class="tree-node">
                            <div class="node-content" onclick="openFileWithLocalTool(event, this)" draggable="true" 
                                 ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                                 ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                                <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                                <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                                <div class="node-icon file">üìÑ</div>
                                <div class="node-title" ondblclick="editNodeTitle(event, this)">${filename}</div>
                                <div class="node-actions">
                                    <button class="action-btn" title="Edit" onclick="editNodeContent(event, this)">‚úèÔ∏è</button>
                                    <button class="action-btn" title="Delete" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                                </div>
                            </div>
                            <div class="node-children"></div>
                        </div>
                    </div>
                `;
                
                // Add the new category to the knowledge tree
                knowledgeTree.appendChild(newMainCategory);
                
                // Expand the new folder to show the file
                const expandBtn = newMainCategory.querySelector('.node-expand');
                if (expandBtn) {
                    expandBtn.textContent = '‚ñº';
                }
                
                // Initialize event handlers for the new elements
                updateEventHandlers(newMainCategory);
                
                console.log(`‚úÖ New category "${categoryName}" created with file "${filename}"`);
                return true;
                
            } catch (error) {
                console.error('‚ùå Error creating new category:', error);
                return false;
            }
        }
        
        function getOrCreateSubfolder(parentNode, subfolderName) {
            // Check if subfolder already exists
            const existingChildren = parentNode.querySelector('.node-children');
            if (existingChildren) {
                const childNodes = existingChildren.querySelectorAll('.tree-node');
                for (let child of childNodes) {
                    const titleElement = child.querySelector('.node-title');
                    if (titleElement && titleElement.textContent.trim() === subfolderName) {
                        return child; // Found existing subfolder
                    }
                }
            }
            
            // Create new subfolder
            const subfolderNode = document.createElement('div');
            subfolderNode.className = 'tree-node';
            subfolderNode.innerHTML = `
                <div class="node-content" onclick="selectNode(this, event)" draggable="true" 
                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                    <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                    <div class="node-icon folder">üìÅ</div>
                    <div class="node-title" ondblclick="editNodeTitle(event, this)">${subfolderName}</div>
                    <div class="node-actions">
                        <button class="action-btn" title="Add Content" onclick="addNodeContent(event, this)">üìù</button>
                        <button class="action-btn" title="Delete" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                    </div>
                </div>
                <div class="node-children"></div>
            `;
            
            // Add to parent's children
            let parentChildren = parentNode.querySelector('.node-children');
            if (!parentChildren) {
                parentChildren = document.createElement('div');
                parentChildren.className = 'node-children';
                parentNode.appendChild(parentChildren);
            }
            parentChildren.appendChild(subfolderNode);
            
            return subfolderNode;
        }
        
        function createFileNode(filename, category) {
            const fileNode = document.createElement('div');
            fileNode.className = 'tree-node';
            fileNode.innerHTML = `
                <div class="node-content" onclick="openFileWithLocalTool(event, this)" draggable="true" 
                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                    <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                    <div class="node-icon file">üìÑ</div>
                    <div class="node-title" ondblclick="editNodeTitle(event, this)">${filename}</div>
                    <div class="node-actions">
                        <button class="action-btn" title="Edit" onclick="editNodeContent(event, this)">‚úèÔ∏è</button>
                        <button class="action-btn" title="Delete" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                    </div>
                </div>
                <div class="node-children"></div>
            `;
            
            return fileNode;
        }
        
        function expandFoldersToShow(folderNode) {
            const expandBtn = folderNode.querySelector('.node-expand');
            const children = folderNode.querySelector('.node-children');
            
            if (expandBtn && children) {
                expandBtn.textContent = '‚ñº';
                children.classList.add('expanded');
                children.style.display = 'block';
            }
        }

    </script>

    <!-- Knowledge Base Panel (integrated) -->
    <div id="knowledgePanel" class="knowledge-panel">
        <div class="panel-header">
            <div class="panel-title">üìö Knowledge Base</div>
            <button class="close-btn" onclick="closeKnowledgePanel()">√ó</button>
        </div>

        <div class="panel-content" style="display: flex; gap: 20px;">

            <!-- ‰∏ªË¶ÅÂå∫ÂüüÔºöÁü•ËØÜÊ†ë -->
            <div class="tree-section" style="flex: 2; min-width: 500px;">
                <div class="tree-header">
                    <div style="font-weight: 600; font-size: 16px;">üìö Knowledge Tree</div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <button class="filter-btn" onclick="addNewFolder()">üìÅ Add Folder</button>
                    </div>
                </div>

                <div class="search-box">
                    <input type="text" class="search-input" placeholder="Search knowledge..." onkeyup="searchKnowledge(this.value)">
                    <button class="filter-btn">üîç</button>
                </div>

                <!-- Selected Documents Floating Panel -->
                <div id="selectedDocsPanel" style="
                    position: fixed; right: -350px; top: 50%; transform: translateY(-50%);
                    width: 320px; max-height: 70vh; overflow-y: auto;
                    background: white; border: 2px solid #e2e8f0; border-radius: 16px;
                    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
                    transition: right 0.4s ease; z-index: 1000; cursor: move;
                " draggable="false">
                    <!-- Expand/Collapse Button -->
                    <div style="
                        position: absolute; left: -40px; top: 20px;
                        width: 40px; height: 60px; background: white;
                        border: 2px solid #e2e8f0; border-right: none; border-radius: 8px 0 0 8px;
                        display: flex; align-items: center; justify-content: center;
                        cursor: pointer; transition: all 0.3s ease;
                    " onclick="toggleSelectedDocsPanel()" id="selectedDocsPanelToggle">
                        <span style="font-size: 18px; color: #6b7280;">üìã</span>
                    </div>
                    
                    <div style="padding: 20px;">
                        <!-- Draggable Header -->
                        <div id="selectedDocsPanelHeader" style="
                            margin: -20px -20px 16px -20px; padding: 16px 20px;
                            background: linear-gradient(135deg, #667eea, #764ba2);
                            border-radius: 16px 16px 0 0; cursor: move;
                            user-select: none; position: relative;
                        ">
                            <button onclick="toggleSelectedDocsPanel()" style="
                                position: absolute; top: 12px; right: 16px; 
                                background: rgba(255,255,255,0.2); border: none; width: 28px; height: 28px; 
                                border-radius: 50%; cursor: pointer; color: white; font-size: 16px;
                                display: flex; align-items: center; justify-content: center;
                                transition: all 0.2s ease;
                            " onmouseover="this.style.background='rgba(255,255,255,0.3)'" 
                               onmouseout="this.style.background='rgba(255,255,255,0.2)'">‚úï</button>
                            <h4 style="
                                margin: 0; color: white; font-size: 16px; 
                                font-weight: 700; display: flex; align-items: center; gap: 8px;
                            ">
                                üéØ Selected for Analysis
                                <span id="selectionCount" style="
                                    background: rgba(255,255,255,0.2); color: white; padding: 2px 8px; 
                                    border-radius: 12px; font-size: 12px; font-weight: 600;
                                ">0</span>
                            </h4>
                        </div>
                        <div id="selectedDocsCards" style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 20px; max-height: 300px; overflow-y: auto;">
                            <!-- Selected document cards will appear here -->
                        </div>
                        <div style="text-align: center; padding: 12px; color: #6b7280; font-size: 14px;" id="emptySelectionMsg">
                            Select documents from the knowledge tree to start analysis
                        </div>
                    </div>
                </div>

                <div class="knowledge-tree" id="knowledgeTree">
                    <!-- Marketing Strategy Folder -->
                    <div class="tree-node">
                        <div class="node-content" onclick="selectNode(this, event)" draggable="true" 
                             ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                             ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                            <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                            <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                            <div class="node-icon folder">üìÅ</div>
                            <div class="node-title" ondblclick="editNodeTitle(event, this)">Marketing Strategy</div>
                            <div class="node-actions">
                                <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                                <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                            </div>
                        </div>
                        <div class="node-children">
                            <div class="tree-node">
                                <div class="node-content" onclick="showNodeContent(event, this)" draggable="true" 
                                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                                    <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                                    <div class="node-icon file">üìÑ</div>
                                    <div class="node-title" ondblclick="editNodeTitle(event, this)">Êæ≥Ê¥≤Â∏ÇÂú∫Áî®Êà∑ÁîªÂÉèÂàÜÊûê</div>
                                    <div class="node-actions">
                                        <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                                        <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                                                <button class="node-action" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                                    </div>
                                </div>
                                <div class="node-tags">
                                    <span class="tag">Áî®Êà∑Ë∞ÉÁ†î</span>
                                    <span class="tag">Êæ≥Ê¥≤Â∏ÇÂú∫</span>
                                </div>
                                <div class="node-children"></div>
                            </div>
                            <div class="tree-node">
                                <div class="node-content" onclick="showNodeContent(event, this)" draggable="true" 
                                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                                    <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                                    <div class="node-icon file">üìÑ</div>
                                    <div class="node-title" ondblclick="editNodeTitle(event, this)">ÊÇâÂ∞ºÁßëÊäÄÂúàÁ´ûÂìÅÂàÜÊûê</div>
                                    <div class="node-actions">
                                        <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                                        <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                                                <button class="node-action" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                                    </div>
                                </div>
                                <div class="node-tags">
                                    <span class="tag">Á´ûÂìÅÂàÜÊûê</span>
                                    <span class="tag">ÁßëÊäÄË°å‰∏ö</span>
                                </div>
                                <div class="node-children"></div>
                            </div>
                            <div class="tree-node">
                                <div class="node-content" onclick="showNodeContent(event, this)" draggable="true" 
                                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                                    <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                                    <div class="node-icon file">üìÑ</div>
                                    <div class="node-title" ondblclick="editNodeTitle(event, this)">AIËê•ÈîÄÁ≠ñÁï•Ê°à‰æãÂ∫ì</div>
                                    <div class="node-actions">
                                        <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                                        <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                                                <button class="node-action" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                                    </div>
                                </div>
                                <div class="node-tags">
                                    <span class="tag">Ê°à‰æãÁ†îÁ©∂</span>
                                    <span class="tag">AIËê•ÈîÄ</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Content Creation Folder -->
                    <div class="tree-node">
                        <div class="node-content" onclick="selectNode(this, event)" draggable="true" 
                             ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                             ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                            <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                            <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                            <div class="node-icon folder">üìÅ</div>
                            <div class="node-title" ondblclick="editNodeTitle(event, this)">Content Creation</div>
                            <div class="node-actions">
                                <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                                <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                            </div>
                        </div>
                        <div class="node-children">
                            <div class="tree-node">
                                <div class="node-content" onclick="showNodeContent(event, this)" draggable="true" 
                                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                                    <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                                    <div class="node-icon file">üìÑ</div>
                                    <div class="node-title" ondblclick="editNodeTitle(event, this)">ÁàÜÊ¨æÊñáÊ°àÂÜô‰ΩúÊ®°Êùø</div>
                                    <div class="node-actions">
                                        <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                                        <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                                                <button class="node-action" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                                    </div>
                                </div>
                                <div class="node-tags">
                                    <span class="tag">ÊñáÊ°àÊ®°Êùø</span>
                                    <span class="tag">ÁàÜÊ¨æÂÖ¨Âºè</span>
                                </div>
                                <div class="node-children"></div>
                            </div>
                            <div class="tree-node">
                                <div class="node-content" onclick="showNodeContent(event, this)" draggable="true" 
                                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                                    <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                                    <div class="node-icon file">üìÑ</div>
                                    <div class="node-title" ondblclick="editNodeTitle(event, this)">AIÂÜô‰ΩúÊèêÁ§∫ËØçÂ∫ì</div>
                                    <div class="node-actions">
                                        <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                                        <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                                                <button class="node-action" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                                    </div>
                                </div>
                                <div class="node-tags">
                                    <span class="tag">AIÊèêÁ§∫ËØç</span>
                                    <span class="tag">ÂÜô‰ΩúÂä©Êâã</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Social Media Folder -->
                    <div class="tree-node">
                        <div class="node-content" onclick="selectNode(this, event)" draggable="true" 
                             ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                             ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                            <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                            <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                            <div class="node-icon folder">üìÅ</div>
                            <div class="node-title" ondblclick="editNodeTitle(event, this)">Social Media</div>
                            <div class="node-actions">
                                <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                                <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                            </div>
                        </div>
                        <div class="node-children">
                            <div class="tree-node">
                                <div class="node-content" onclick="openFileWithLocalTool(event, this)" draggable="true" 
                                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                                    <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                                    <div class="node-icon file">üìÑ</div>
                                    <div class="node-title" ondblclick="editNodeTitle(event, this)">LinkedInÊæ≥Ê¥≤B2BËøêËê•ÊåáÂçó</div>
                                    <div class="node-actions">
                                        <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                                        <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                                                <button class="node-action" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                                    </div>
                                </div>
                                <div class="node-tags">
                                    <span class="tag">LinkedIn</span>
                                    <span class="tag">B2BËê•ÈîÄ</span>
                                </div>
                                <div class="node-children"></div>
                            </div>
                            <div class="tree-node">
                                <div class="node-content" onclick="openFileWithLocalTool(event, this)" draggable="true" 
                                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                                    <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                                    <div class="node-icon file">üìÑ</div>
                                    <div class="node-title" ondblclick="editNodeTitle(event, this)">InstagramËßÜËßâËê•ÈîÄÁ¥†ÊùêÂ∫ì</div>
                                    <div class="node-actions">
                                        <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                                        <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                                                <button class="node-action" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                                    </div>
                                </div>
                                <div class="node-tags">
                                    <span class="tag">Instagram</span>
                                    <span class="tag">ËßÜËßâËê•ÈîÄ</span>
                                </div>
                                <div class="node-children"></div>
                            </div>
                            <div class="tree-node">
                                <div class="node-content" onclick="openFileWithLocalTool(event, this)" draggable="true" 
                                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                                    <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                                    <div class="node-icon file">üìÑ</div>
                                    <div class="node-title" ondblclick="editNodeTitle(event, this)">TikTokÁü≠ËßÜÈ¢ëËÑöÊú¨Ê®°Êùø</div>
                                    <div class="node-actions">
                                        <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                                        <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                                                <button class="node-action" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                                    </div>
                                </div>
                                <div class="node-tags">
                                    <span class="tag">TikTok</span>
                                    <span class="tag">Áü≠ËßÜÈ¢ë</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Analytics Folder -->
                    <div class="tree-node">
                        <div class="node-content" onclick="selectNode(this, event)" draggable="true" 
                             ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                             ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                            <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                            <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                            <div class="node-icon folder">üìÅ</div>
                            <div class="node-title" ondblclick="editNodeTitle(event, this)">Analytics & Data</div>
                            <div class="node-actions">
                                <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                                <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                            </div>
                        </div>
                        <div class="node-children">
                            <div class="tree-node">
                                <div class="node-content" onclick="showNodeContent(event, this)" draggable="true" 
                                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                                    <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                                    <div class="node-icon file">üìÑ</div>
                                    <div class="node-title" ondblclick="editNodeTitle(event, this)">ÂÜÖÂÆπËê•ÈîÄKPIÊåáÊ†á‰ΩìÁ≥ª</div>
                                    <div class="node-actions">
                                        <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                                        <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                                                <button class="node-action" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                                    </div>
                                </div>
                                <div class="node-tags">
                                    <span class="tag">KPI</span>
                                    <span class="tag">Êï∞ÊçÆÂàÜÊûê</span>
                                </div>
                                <div class="node-children"></div>
                            </div>
                            <div class="tree-node">
                                <div class="node-content" onclick="showNodeContent(event, this)" draggable="true" 
                                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">‚úì</div>
                                    <div class="node-expand" onclick="toggleNode(event, this)">‚ñ∂</div>
                                    <div class="node-icon file">üìÑ</div>
                                    <div class="node-title" ondblclick="editNodeTitle(event, this)">Google Analytics 4 ÈÖçÁΩÆÊåáÂçó</div>
                                    <div class="node-actions">
                                        <button class="node-action" onclick="addChildItem(event, this)">‚ûï</button>
                                        <button class="node-action" onclick="editNode(event, this)">‚úèÔ∏è</button>
                                                <button class="node-action" onclick="deleteNode(event, this)">üóëÔ∏è</button>
                                    </div>
                                </div>
                                <div class="node-tags">
                                    <span class="tag">GA4</span>
                                    <span class="tag">ÁΩëÁ´ôÂàÜÊûê</span>
                                </div>
                                <div class="node-children"></div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>

            <!-- Âè≥‰æßÔºöÁÆÄÂåñÈ¢ÑËßàÊèêÁ§∫ -->
            <div class="preview-section" id="contentPreviewSection" style="flex: 0 0 280px; border-left: 1px solid #e5e7eb; padding: 20px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                <div style="text-align: center; color: #6b7280;">
                    <div style="font-size: 32px; margin-bottom: 12px; opacity: 0.6;">üìÑ</div>
                    <h4 style="margin: 0 0 8px 0; font-size: 14px; color: #374151; font-weight: 600;">Select a document to preview</h4>
                    <p style="margin: 0; font-size: 12px; line-height: 1.4;">Click on any document in the knowledge tree to view its content here</p>
                </div>
            </div>
        </div>

        <div class="panel-footer">
            <div class="footer-actions">
                <button class="footer-btn" onclick="exportSelectedKnowledge()">üì§ Export Selected</button>
                <button id="mainInsightAnalysisBtn" class="footer-btn primary" onclick="startInsightAnalysis()" style="
                    background: linear-gradient(135deg, #667eea, #764ba2); 
                    color: white; font-weight: 700; padding: 12px 24px; 
                    font-size: 16px; border-radius: 8px; opacity: 0.5; 
                    cursor: not-allowed;
                " disabled>
                    üß† Start Insight Analysis
                </button>
            </div>
        </div>
    </div>

    <div id="panelOverlay" class="panel-overlay" onclick="closeKnowledgePanel()"></div>

    <style>
        /* Knowledge Base Panel Styles */
        .knowledge-panel { position: fixed; top: 0; right: -1200px; width: 1200px; height: 100vh; background: white; box-shadow: -5px 0 30px rgba(0, 0, 0, 0.2); transition: right 0.3s ease; z-index: 2000; display: flex; flex-direction: column; }
        .knowledge-panel.open { right: 0; }
        .panel-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.5); opacity: 0; visibility: hidden; transition: all 0.3s ease; z-index: 1999; }
        .panel-overlay.show { opacity: 1; visibility: visible; }
        .panel-header { background: linear-gradient(135deg, #8b5cf6, #6366f1); color: white; padding: 20px; display: flex; justify-content: space-between; align-items: center; }
        .panel-title { font-size: 18px; font-weight: 600; display: flex; align-items: center; gap: 10px; }
        .close-btn { background: none; border: none; color: white; font-size: 20px; cursor: pointer; padding: 5px; border-radius: 4px; transition: background 0.2s ease; }
        .close-btn:hover { background: rgba(255, 255, 255, 0.2); }
        .panel-content { flex: 1; overflow: hidden; display: flex; flex-direction: row; }
        .tree-section { flex: 2; padding: 20px; overflow-y: auto; }
        .tree-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
        .search-box { display: flex; gap: 8px; margin-bottom: 16px; }
        .search-input { flex: 1; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px; }
        .filter-btn { padding: 8px 12px; border: 1px solid #d1d5db; background: white; border-radius: 6px; cursor: pointer; font-size: 12px; }
        .knowledge-tree { background: #f9fafb; border-radius: 8px; padding: 12px; }
        .tree-node { margin: 4px 0; }
        .node-content { display: flex; align-items: center; padding: 8px; border-radius: 6px; cursor: pointer; transition: all 0.2s ease; gap: 8px; }
        .node-checkbox { width: 18px; height: 18px; border: 2px solid #9ca3af; border-radius: 3px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; }
        .node-checkbox.selected { background: #10b981; border-color: #10b981; color: white; }
        .preview-section { flex: 0 0 280px; border-left: 1px solid #e5e7eb; padding: 20px; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .node-content:hover { background: #e5e7eb; }
        .node-content[draggable="true"]:hover { cursor: grab; }
        .node-content.dragging { opacity: 0.5; transform: rotate(2deg); }
        .node-content.drag-over { background: #e0e7ff !important; border: 2px dashed #8b5cf6; }
        .node-expand { width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 12px; }
        .node-icon { width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; border-radius: 4px; font-size: 14px; }
        .node-icon.folder { background: #fef3c7; }
        .node-icon.file { background: #dbeafe; }
        .node-title { flex: 1; font-size: 14px; font-weight: 500; }
        .node-actions { opacity: 0; display: flex; gap: 4px; transition: opacity 0.2s ease; }
        .node-content:hover .node-actions { opacity: 1; }
        .node-action { width: 24px; height: 24px; border: none; background: none; cursor: pointer; border-radius: 4px; font-size: 12px; color: #6b7280; }
        .node-action:hover { background: #f3f4f6; color: #374151; }
        .node-select-btn { 
            width: 24px; 
            height: 24px; 
            border: none; 
            background: none; 
            cursor: pointer; 
            border-radius: 4px; 
            font-size: 14px; 
            color: #9ca3af; 
            transition: all 0.2s ease;
            opacity: 1 !important;
            display: inline-flex !important;
            align-items: center;
            justify-content: center;
            margin-left: 4px;
        }
        .node-select-btn:hover { background: #f3f4f6; }
        .node-select-btn[data-selected="true"] { color: #10b981; background: #d1fae5; }
        .node-select-btn[data-selected="false"] { color: #9ca3af; }
        .node-children { margin-left: 24px; display: none; }
        .node-children.expanded { display: block; }
        .node-tags { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 4px; }
        .tag { background: #f3f4f6; color: #6b7280; padding: 2px 6px; border-radius: 10px; font-size: 10px; }
        .templates-section { margin-top: 20px; }
        .templates-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px; }
        .template-card { background: white; border: 1px solid #e5e7eb; border-radius: 8px; padding: 12px; cursor: pointer; transition: all 0.2s ease; }
        .template-card:hover { border-color: #8b5cf6; box-shadow: 0 4px 12px rgba(139, 92, 246, 0.1); }
        .template-title { font-size: 12px; font-weight: 600; margin-bottom: 4px; }
        .template-desc { font-size: 10px; color: #6b7280; }
        .panel-footer { padding: 20px; border-top: 1px solid #e5e7eb; background: #f9fafb; }
        .footer-actions { display: flex; gap: 8px; }
        .footer-btn { flex: 1; padding: 10px; border: 1px solid #d1d5db; background: white; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 500; }
        .footer-btn.primary { background: linear-gradient(135deg, #8b5cf6, #6366f1); color: white; border: none; }
        @media (max-width: 768px) { .knowledge-panel { width: 100vw; right: -100vw; } }
        @keyframes slideInRight { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideInUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes rotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    </style>
    
    <script>
        // Ê∏≤ÊüìÁúüÊ≠£ÁöÑ‰∫§‰∫íÂºèD3.jsÁü•ËØÜÂõæË∞±
        function renderInteractiveKnowledgeGraph(graphData) {
            console.log('üé® Rendering interactive knowledge graph:', graphData);
            console.log('üîç Graph data structure:', {
                hasNodes: !!(graphData && graphData.nodes),
                nodeCount: graphData?.nodes?.length || 0,
                hasLinks: !!(graphData && graphData.links),
                linkCount: graphData?.links?.length || 0
            });
            
            const container = document.getElementById('knowledgeGraphContainer');
            console.log('üì¶ Container element:', container);
            console.log('üì¶ Container dimensions:', container ? `${container.offsetWidth}x${container.offsetHeight}` : 'N/A');
            
            if (!container) {
                console.error('‚ùå Knowledge graph container not found');
                return;
            }
            
            // Ê∏ÖÁ©∫ÂÆπÂô®
            container.innerHTML = '';
            console.log('üßπ Container cleared');
            
            // Â¶ÇÊûúÊ≤°ÊúâÂõæÊï∞ÊçÆÔºåÊòæÁ§∫Âç†‰ΩçÁ¨¶
            if (!graphData || !graphData.nodes || graphData.nodes.length === 0) {
                console.log('‚ö†Ô∏è No graph data available, showing placeholder');
                container.innerHTML = `
                    <div style="
                        display: flex; flex-direction: column; align-items: center; 
                        justify-content: center; height: 100%; color: #6b7280;
                    ">
                        <div style="font-size: 48px; margin-bottom: 16px;">üîç</div>
                        <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">Êï∞ÊçÆËß£Êûê‰∏≠</div>
                        <div style="font-size: 14px;">Ê≠£Âú®ÂàÜÊûê ${graphData?.metadata || 'Êú™Áü•'} Êï∞ÊçÆÁªìÊûÑ...</div>
                        <div style="font-size: 12px; margin-top: 8px; opacity: 0.7;">
                            Ë∞ÉËØï‰ø°ÊÅØ: nodes=${graphData?.nodes?.length || 0}, links=${graphData?.links?.length || 0}
                        </div>
                    </div>
                `;
                return;
            }
            
            console.log('‚úÖ Graph data validation passed, proceeding with rendering');
            
            // ÂõæË∞±Â∞∫ÂØ∏
            const width = container.offsetWidth;
            const height = 450;
            
            // ÂàõÂª∫SVGÁîªÂ∏É
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .style('background', '#fafafa')
                .style('border-radius', '8px');
            
            // Ê∑ªÂä†Áº©ÊîæÂäüËÉΩ
            const g = svg.append('g');
            const zoom = d3.zoom()
                .scaleExtent([0.5, 3])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });
            svg.call(zoom);
            
            // Â§ÑÁêÜÊï∞ÊçÆ
            const nodes = graphData.nodes.map(d => ({
                ...d,
                id: d.id,
                name: d.name || d.id,
                type: d.type || 'entity',
                category: d.category || 'default',
                weight: d.weight || 1
            }));
            
            const links = graphData.links.map(d => ({
                ...d,
                source: d.source,
                target: d.target,
                type: d.type || 'related',
                weight: d.weight || 1
            }));
            
            // È¢úËâ≤ÈÖçÁΩÆ
            const colorScale = {
                'entity': '#8b5cf6',     // Á¥´Ëâ≤ - ÂÆû‰Ωì
                'concept': '#06b6d4',    // ÈùíËâ≤ - Ê¶ÇÂøµ  
                'person': '#f59e0b',     // Ê©ôËâ≤ - ‰∫∫Áâ©
                'organization': '#10b981', // ÁªøËâ≤ - ÁªÑÁªá
                'product': '#ef4444',    // Á∫¢Ëâ≤ - ‰∫ßÂìÅ
                'default': '#6b7280'     // ÁÅ∞Ëâ≤ - ÈªòËÆ§
            };
            
            // ÂàõÂª∫Âäõ‰ªøÁúü
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(80).strength(0.8))
                .force('charge', d3.forceManyBody().strength(-200))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(25));
            
            // ÁªòÂà∂ËøûÊé•Á∫ø
            const link = g.append('g')
                .selectAll('line')
                .data(links)
                .enter().append('line')
                .attr('stroke', '#94a3b8')
                .attr('stroke-opacity', 0.6)
                .attr('stroke-width', d => Math.sqrt(d.weight * 2));
            
            // ÁªòÂà∂ËøûÊé•Á∫øÊ†áÁ≠æ
            const linkLabel = g.append('g')
                .selectAll('text')
                .data(links)
                .enter().append('text')
                .attr('font-size', 10)
                .attr('fill', '#64748b')
                .attr('text-anchor', 'middle')
                .text(d => d.type === 'co_occurs' ? '' : (d.type || ''));
            
            // ÁªòÂà∂ËäÇÁÇπ
            const node = g.append('g')
                .selectAll('circle')
                .data(nodes)
                .enter().append('circle')
                .attr('r', d => 8 + (d.weight || 1) * 4)
                .attr('fill', d => colorScale[d.type] || colorScale.default)
                .attr('stroke', '#fff')
                .attr('stroke-width', 2)
                .style('cursor', 'pointer')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            // ËäÇÁÇπÊ†áÁ≠æ
            const nodeLabel = g.append('g')
                .selectAll('text')
                .data(nodes)
                .enter().append('text')
                .attr('font-size', 11)
                .attr('font-weight', 'bold')
                .attr('fill', '#1f2937')
                .attr('text-anchor', 'middle')
                .attr('dy', '.35em')
                .text(d => d.name.length > 8 ? d.name.substring(0, 8) + '...' : d.name)
                .style('pointer-events', 'none');
            
            // Ê∑ªÂä†‰∫§‰∫íÊïàÊûú
            node.on('mouseover', function(event, d) {
                // È´ò‰∫ÆÂΩìÂâçËäÇÁÇπÂíåÁõ∏ÂÖ≥ËøûÊé•
                d3.select(this)
                    .transition()
                    .duration(200)
                    .attr('r', d => 12 + (d.weight || 1) * 4)
                    .attr('stroke-width', 3);
                
                // ÊòæÁ§∫ËØ¶ÁªÜ‰ø°ÊÅØ
                showNodeTooltip(event, d);
                
                // È´ò‰∫ÆÁõ∏ÂÖ≥ËøûÊé•
                link.style('stroke-opacity', l => 
                    l.source.id === d.id || l.target.id === d.id ? 1 : 0.2
                );
                
                // È´ò‰∫ÆÁõ∏ÂÖ≥ËäÇÁÇπ
                node.style('opacity', n => {
                    const connected = links.some(l => 
                        (l.source.id === d.id && l.target.id === n.id) ||
                        (l.target.id === d.id && l.source.id === n.id)
                    );
                    return n.id === d.id || connected ? 1 : 0.3;
                });
            })
            .on('mouseout', function(event, d) {
                // ÊÅ¢Â§çÂéüÂßãÊ†∑Âºè
                d3.select(this)
                    .transition()
                    .duration(200)
                    .attr('r', d => 8 + (d.weight || 1) * 4)
                    .attr('stroke-width', 2);
                
                hideNodeTooltip();
                
                // ÊÅ¢Â§çÊâÄÊúâËøûÊé•ÂíåËäÇÁÇπÁöÑÈÄèÊòéÂ∫¶
                link.style('stroke-opacity', 0.6);
                node.style('opacity', 1);
            })
            .on('click', function(event, d) {
                // ÁÇπÂáªËäÇÁÇπÊó∂ÁöÑËØ¶ÁªÜ‰ø°ÊÅØ
                showNodeDetails(d);
            });
            
            // ‰ªøÁúüÊõ¥Êñ∞
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                linkLabel
                    .attr('x', d => (d.source.x + d.target.x) / 2)
                    .attr('y', d => (d.source.y + d.target.y) / 2);
                
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                nodeLabel
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
            
            // ÊãñÊãΩÂáΩÊï∞
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            // Ê∑ªÂä†ÂõæË∞±ÊéßÂà∂ÊåâÈíÆ
            const controls = d3.select(container)
                .append('div')
                .style('position', 'absolute')
                .style('top', '10px')
                .style('right', '10px')
                .style('display', 'flex')
                .style('gap', '8px');
            
            // ÈáçÁΩÆËßÜÂõæÊåâÈíÆ
            controls.append('button')
                .style('width', '32px')
                .style('height', '32px')
                .style('border', 'none')
                .style('background', 'rgba(139, 69, 196, 0.9)')
                .style('color', 'white')
                .style('border-radius', '6px')
                .style('cursor', 'pointer')
                .style('font-size', '14px')
                .text('‚åÇ')
                .attr('title', 'ÈáçÁΩÆËßÜÂõæ')
                .on('click', function() {
                    svg.transition().duration(750).call(
                        zoom.transform,
                        d3.zoomIdentity
                    );
                });
            
            console.log('‚úÖ Interactive knowledge graph rendered successfully');
        }
        
        // ÊòæÁ§∫ËäÇÁÇπÊÇ¨ÂÅúÊèêÁ§∫
        function showNodeTooltip(event, node) {
            // ÁßªÈô§Â∑≤Â≠òÂú®ÁöÑÊèêÁ§∫
            hideNodeTooltip();
            
            const tooltip = d3.select('body')
                .append('div')
                .attr('id', 'node-tooltip')
                .style('position', 'absolute')
                .style('background', 'rgba(0, 0, 0, 0.8)')
                .style('color', 'white')
                .style('padding', '8px 12px')
                .style('border-radius', '6px')
                .style('font-size', '12px')
                .style('pointer-events', 'none')
                .style('z-index', '10000')
                .style('opacity', 0);
            
            tooltip.html(`
                <strong>${node.name}</strong><br>
                Á±ªÂûã: ${node.type || 'Êú™Áü•'}<br>
                ÊùÉÈáç: ${node.weight || 1}
            `)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 10) + 'px')
            .transition()
            .duration(200)
            .style('opacity', 1);
        }
        
        // ÈöêËóèËäÇÁÇπÊèêÁ§∫
        function hideNodeTooltip() {
            d3.select('#node-tooltip').remove();
        }
        
        // ÊòæÁ§∫ËäÇÁÇπËØ¶ÁªÜ‰ø°ÊÅØ
        function showNodeDetails(node) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0, 0, 0, 0.7); z-index: 15000;
                display: flex; align-items: center; justify-content: center;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white; border-radius: 12px; padding: 24px;
                    max-width: 400px; width: 90%; position: relative;
                    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
                ">
                    <button onclick="this.closest('div').parentElement.remove()" 
                            style="position: absolute; top: 12px; right: 12px; 
                                   background: none; border: none; font-size: 20px; 
                                   cursor: pointer; color: #6b7280;
                                   width: 28px; height: 28px; display: flex;
                                   align-items: center; justify-content: center;
                                   border-radius: 6px;">‚úï</button>
                    
                    <h3 style="margin: 0 0 16px 0; color: #1f2937; font-size: 18px;">
                        üîç ÂÆû‰ΩìËØ¶ÊÉÖ
                    </h3>
                    
                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        <div><strong>ÂêçÁß∞:</strong> ${node.name}</div>
                        <div><strong>Á±ªÂûã:</strong> <span style="background: #e0e7ff; color: #3730a3; padding: 2px 8px; border-radius: 12px; font-size: 12px;">${node.type || 'Êú™Áü•'}</span></div>
                        <div><strong>ÂàÜÁ±ª:</strong> ${node.category || 'ÈªòËÆ§'}</div>
                        <div><strong>ÈáçË¶ÅÂ∫¶:</strong> <span style="color: #059669;">${node.weight || 1}</span></div>
                        ${node.properties ? `<div><strong>ÂÖ∂‰ªñÂ±ûÊÄß:</strong><br><pre style="background: #f3f4f6; padding: 8px; border-radius: 4px; font-size: 11px; white-space: pre-wrap;">${JSON.stringify(node.properties, null, 2)}</pre></div>` : ''}
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // Á°Æ‰øùÂõæË∞±Ê∏≤ÊüìÂáΩÊï∞Âú®È°µÈù¢Âä†ËΩΩÂêéÂèØÁî®
        if (typeof window !== 'undefined') {
            // Á´ãÂç≥ÈáçÂÜôÂáΩÊï∞Ôºå‰∏çÁ≠âÂæÖDOMÂä†ËΩΩ
            const originalShow = window.showCrossDocumentResults;
            
            window.showCrossDocumentResults = function(results) {
                console.log('üéØ showCrossDocumentResults called with:', results);
                
                // Ë∞ÉÁî®ÂéüÂßãÂáΩÊï∞ÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
                if (originalShow) {
                    originalShow(results);
                }
                
                // Â§öÊ¨°Â∞ùËØïÊ∏≤ÊüìÂõæË∞±ÔºåÁ°Æ‰øùÊàêÂäü
                const attemptRender = (attempt = 1) => {
                    console.log(`üé® Render attempt ${attempt} with results:`, results);
                    
                    const container = document.getElementById('knowledgeGraphContainer');
                    if (container && results) {
                        // ‰ΩøÁî® generateGraphData ÁîüÊàêÂõæË∞±Êï∞ÊçÆ
                        const graphData = generateGraphData(results);
                        console.log('üìä Generated graph data for rendering:', graphData);
                        
                        if (graphData && graphData.nodes && graphData.nodes.length > 0) {
                            renderInteractiveKnowledgeGraph(graphData);
                            console.log('‚úÖ Knowledge graph rendered successfully on attempt', attempt);
                            return; // ÊàêÂäüÊ∏≤ÊüìÔºåÂÅúÊ≠¢ÈáçËØï
                        }
                    }
                    
                    if (attempt < 5) {
                        console.log(`‚è≥ Retrying render in ${attempt * 200}ms (attempt ${attempt + 1})`);
                        setTimeout(() => attemptRender(attempt + 1), attempt * 200);
                    } else {
                        console.error('‚ùå Failed to render knowledge graph after 5 attempts');
                        console.log('Container found:', !!container);
                        console.log('Results available:', !!results);
                        console.log('Results details:', results);
                    }
                };
                
                // Á´ãÂç≥Â∞ùËØï‰∏ÄÊ¨°ÔºåÁÑ∂ÂêéÂª∂ËøüÂ∞ùËØï
                attemptRender(1);
                setTimeout(() => attemptRender(2), 500);
                setTimeout(() => attemptRender(3), 1000);
            };
            
            console.log('üîß Knowledge graph renderer setup complete');
        }
    </script>
</body>
</html>