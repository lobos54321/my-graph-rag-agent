<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CreatorMind AI - Intelligent Content Workflow</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        /* Header */
        .header {
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 0;
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
            font-size: 18px;
            font-weight: 600;
        }

        .knowledge-btn {
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* Main Content */
        .main-content {
            max-width: 1200px;
            margin: 60px auto;
            padding: 0 20px;
        }

        /* Workflow Steps */
        .workflow-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 60px 40px;
            margin-bottom: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
        }

        .workflow-steps {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 60px;
            flex-wrap: wrap;
            gap: 20px;
        }

        .step {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            flex: 1;
            min-width: 100px;
        }

        .step-icon {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: #f8f9ff;
            border: 3px solid #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            margin-bottom: 16px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .step.active .step-icon {
            background: #10b981;
            border-color: #10b981;
            color: white;
            transform: scale(1.1);
        }

        .step-icon:hover {
            transform: scale(1.05);
            border-color: #8b5cf6;
        }

        .step-title {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 4px;
            text-align: center;
        }

        .step-desc {
            font-size: 12px;
            color: #6b7280;
            text-align: center;
        }

        /* Connector Lines */
        .step:not(:last-child)::after {
            content: '';
            position: absolute;
            top: 35px;
            right: -50%;
            width: 100%;
            height: 2px;
            background: #e5e7eb;
            z-index: -1;
        }

        .step.completed::after {
            background: #10b981;
        }

        /* Trending Analysis Section */
        .trending-section {
            background: linear-gradient(135deg, #ff6b6b, #ff8e53);
            border-radius: 16px;
            padding: 24px;
            color: white;
            margin: 24px 0;
            box-shadow: 0 8px 32px rgba(255, 107, 107, 0.3);
        }

        .trending-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .trending-title {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 20px;
            font-weight: 600;
        }

        .trending-status {
            background: rgba(255, 255, 255, 0.2);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
        }

        .trending-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .trending-card {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            padding: 16px;
            backdrop-filter: blur(10px);
        }

        .trending-card h4 {
            margin-bottom: 12px;
            font-size: 14px;
            opacity: 0.9;
        }

        .trend-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .trend-item:last-child {
            border-bottom: none;
        }

        .trend-name {
            font-size: 13px;
            font-weight: 500;
        }

        .trend-score {
            font-size: 12px;
            background: rgba(255, 255, 255, 0.3);
            padding: 2px 8px;
            border-radius: 10px;
        }

        .trending-insights {
            margin-top: 16px;
            padding: 16px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
        }

        .insight-tag {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            margin: 2px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        /* AI Assistant Section */
        .ai-assistant {
            text-align: center;
            margin-bottom: 40px;
        }

        .ai-title {
            font-size: 28px;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        /* Input Section */
        .input-section {
            background: rgba(139, 92, 246, 0.05);
            border: 2px dashed rgba(139, 92, 246, 0.3);
            border-radius: 16px;
            padding: 24px;
            transition: all 0.3s ease;
        }

        .input-section:hover {
            border-color: rgba(139, 92, 246, 0.5);
            background: rgba(139, 92, 246, 0.08);
        }

        .input-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .input-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 16px;
        }

        .input-info h3 {
            font-size: 16px;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 4px;
        }

        .input-info p {
            font-size: 14px;
            color: #6b7280;
        }

        .input-area {
            width: 100%;
            min-height: 120px;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 16px;
            font-size: 14px;
            line-height: 1.6;
            resize: vertical;
            transition: all 0.3s ease;
            background: white;
        }

        .input-area:focus {
            outline: none;
            border-color: #8b5cf6;
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 12px;
            margin-top: 20px;
            justify-content: flex-end;
        }

        .btn {
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(139, 92, 246, 0.3);
        }

        .btn-secondary {
            background: #f8f9ff;
            color: #8b5cf6;
            border: 1px solid #e5e7eb;
        }

        .btn-secondary:hover {
            background: #f3f4f6;
        }

        /* Results Section */
        .results-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            padding: 24px;
            margin-top: 30px;
            display: none;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .results-section.show {
            display: block;
            animation: slideInUp 0.5s ease;
        }

        @keyframes slideInUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .result-card {
            background: linear-gradient(135deg, #fef3c7, #fed7d7);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .result-score {
            font-size: 32px;
            font-weight: bold;
            color: #10b981;
            text-align: center;
            margin: 20px 0;
        }

        .result-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 16px 0;
        }

        .tag {
            background: rgba(255, 255, 255, 0.8);
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 500;
        }

        /* Loading Animation */
        .loading {
            text-align: center;
            padding: 40px;
            color: #6b7280;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #f3f4f6;
            border-top: 3px solid #8b5cf6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }
        
        @keyframes slideInFromRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOutToRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }
        
        @keyframes bounceIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.05); }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); opacity: 1; }
        }
        
        @keyframes slideInLeft {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        /* Multi-modal Input Styles */
        .input-mode-btn {
            background: none;
            border: 2px solid #e5e7eb;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 500;
        }
        
        .input-mode-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        
        .input-mode-btn:hover:not(.active) {
            border-color: #cbd5e1;
            background: #f8fafc;
        }
        
        .file-drop-zone.dragover {
            border-color: #667eea !important;
            background: #e0e7ff !important;
        }
        
        .multimodal-input-container.dragover {
            border-color: #667eea !important;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .workflow-steps {
                flex-direction: column;
                gap: 30px;
            }
            
            .step::after {
                display: none;
            }
            
            .main-content {
                margin: 30px auto;
                padding: 0 15px;
            }
            
            .workflow-container {
                padding: 40px 20px;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <div class="logo">
                🧠 CreatorMind AI
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main-content">
        <div class="workflow-container">
            <!-- Trending Analysis Section -->
            <div class="trending-section" id="trendingSection" style="display: none;">
                <div class="trending-header">
                    <div class="trending-title">
                        <span>🔥</span>
                        Hot Topic Analysis
                    </div>
                    <div class="trending-status">Live • Australian Market</div>
                </div>
                
                <div class="trending-grid">
                    <div class="trending-card">
                        <h4>🚀 Trending Topics</h4>
                        <div class="trend-item">
                            <span class="trend-name">AI Content Marketing</span>
                            <span class="trend-score">94%</span>
                        </div>
                        <div class="trend-item">
                            <span class="trend-name">Digital Transformation</span>
                            <span class="trend-score">87%</span>
                        </div>
                        <div class="trend-item">
                            <span class="trend-name">Sydney Tech Hub</span>
                            <span class="trend-score">76%</span>
                        </div>
                        <div class="trend-item">
                            <span class="trend-name">Remote Work Tools</span>
                            <span class="trend-score">68%</span>
                        </div>
                    </div>
                    
                    <div class="trending-card">
                        <h4>📊 Social Signals</h4>
                        <div class="trend-item">
                            <span class="trend-name">LinkedIn Engagement</span>
                            <span class="trend-score">+340%</span>
                        </div>
                        <div class="trend-item">
                            <span class="trend-name">Twitter Mentions</span>
                            <span class="trend-score">+250%</span>
                        </div>
                        <div class="trend-item">
                            <span class="trend-name">Reddit Discussions</span>
                            <span class="trend-score">+180%</span>
                        </div>
                        <div class="trend-item">
                            <span class="trend-name">YouTube Views</span>
                            <span class="trend-score">+150%</span>
                        </div>
                    </div>
                </div>
                
                <div class="trending-insights">
                    <strong>🧠 Smart Recommendations:</strong><br>
                    <span class="insight-tag">Focus on AI efficiency stories</span>
                    <span class="insight-tag">Target business decision makers</span>
                    <span class="insight-tag">Use local Sydney case studies</span>
                    <span class="insight-tag">Emphasize ROI metrics</span>
                    <span class="insight-tag">Post during 9-11 AM AEST</span>
                    <span class="insight-tag">Cross-post to LinkedIn first</span>
                </div>
            </div>

            <!-- Workflow Steps -->
            <div class="workflow-steps">
                <div class="step" data-step="knowledge" onclick="openKnowledgePanel()" style="cursor: pointer;">
                    <div class="step-icon">📚</div>
                    <div class="step-title">Knowledge</div>
                    <div class="step-desc">Choose relevant knowledge</div>
                </div>
                
                <div class="step active" data-step="input">
                    <div class="step-icon">📝</div>
                    <div class="step-title">Input</div>
                    <div class="step-desc">Content or documents</div>
                </div>
                
                <div class="step" data-step="analysis">
                    <div class="step-icon">🧠</div>
                    <div class="step-title">Analysis</div>
                    <div class="step-desc">Intelligent understanding</div>
                </div>
                
                <div class="step" data-step="research">
                    <div class="step-icon">🔍</div>
                    <div class="step-title">Research</div>
                    <div class="step-desc">Deep analysis</div>
                </div>
                
                <div class="step" data-step="trends">
                    <div class="step-icon">🔥</div>
                    <div class="step-title">Trends</div>
                    <div class="step-desc">Trend matching</div>
                </div>
                
                <div class="step" data-step="create">
                    <div class="step-icon">✨</div>
                    <div class="step-title">Create</div>
                    <div class="step-desc">Content generation</div>
                </div>
                
                <div class="step" data-step="optimize">
                    <div class="step-icon">🎯</div>
                    <div class="step-title">Optimize</div>
                    <div class="step-desc">Effect improvement</div>
                </div>
                
                <div class="step" data-step="video">
                    <div class="step-icon">🎬</div>
                    <div class="step-title">Video</div>
                    <div class="step-desc">Digital human</div>
                </div>
                
                <div class="step" data-step="publish">
                    <div class="step-icon">🚀</div>
                    <div class="step-title">Publish</div>
                    <div class="step-desc">Multi-platform push</div>
                </div>
            </div>

            <!-- AI Assistant Section -->
            <div class="ai-assistant">
                <h2 class="ai-title">
                    ✨ AI Smart Creative Assistant
                </h2>
                
                <div class="input-section">
                    <div class="input-header">
                        <div class="input-avatar">💬</div>
                        <div class="input-info">
                            <h3>Text Input</h3>
                            <p>Input your creative ideas, questions or content, AI will provide intelligent analysis and optimal processing solutions</p>
                        </div>
                    </div>
                    
                    <!-- Multi-modal Input Area -->
                    <div class="multimodal-input-container" style="
                        background: white; border: 2px solid #e2e8f0; border-radius: 16px;
                        padding: 20px; transition: border-color 0.3s ease;
                    ">
                        
                        <!-- Smart Input Area - Auto-detects content type -->
                        <div style="margin-bottom: 16px;">
                            <div style="
                                background: linear-gradient(135deg, #f8fafc, #e2e8f0);
                                padding: 8px; border-radius: 12px; text-align: center;
                                font-size: 14px; color: #6b7280; margin-bottom: 12px;
                            ">
                                🤖 Smart Input - Drop files, paste URLs, type text, or click voice button
                            </div>
                        </div>
                        
                        <!-- Unified Smart Input Area -->
                        <div id="smartInputArea" style="position: relative;">
                            <!-- Multi-purpose input area with file drop support -->
                            <div class="smart-input-container" style="
                                border: 2px dashed #cbd5e1; border-radius: 12px; 
                                background: #f8fafc; transition: all 0.3s ease;
                                position: relative; min-height: 200px;
                            " 
                            ondrop="handleSmartDrop(event)" 
                            ondragover="event.preventDefault(); this.style.borderColor='#3b82f6'; this.style.backgroundColor='#eff6ff';"
                            ondragleave="this.style.borderColor='#cbd5e1'; this.style.backgroundColor='#f8fafc';">
                                
                                <!-- Main text input area -->
                                <textarea 
                                    class="input-area" 
                                    id="contentInput"
                                    style="
                                        width: 100%; min-height: 180px; padding: 16px;
                                        border: none; background: transparent; resize: vertical;
                                        outline: none; font-size: 14px; line-height: 1.5;
                                    "
                                    placeholder="Smart Input - Type text, paste URLs, or drop files here...

🌐 URL Examples:
• YouTube: https://www.youtube.com/watch?v=dQw4w9WgXcQ
• Website: https://example.com
• Article: https://blog.example.com/post

📝 Text Examples:
📊 Marketing campaign strategy
✍️ Blog article draft  
📱 Social media content
🛍️ Product description
📈 Market analysis
🔗 https://example.com/article
📁 Drop files: PDF, Word, Excel, Images, Text files"
                                    oninput="handleSmartInput(this.value)"
                                ></textarea>
                                
                                <!-- File input (hidden) -->
                                <input type="file" id="fileInput" multiple 
                                       accept=".pdf,.doc,.docx,.xls,.xlsx,.txt,.png,.jpg,.jpeg,.gif,.md" 
                                       style="display: none;" 
                                       onchange="handleFileInput(this.files)">
                                
                                <!-- Smart input controls -->
                                <div style="
                                    position: absolute; bottom: 12px; right: 12px;
                                    display: flex; gap: 8px; align-items: center;
                                ">
                                    <!-- Voice input button -->
                                    <button id="voiceBtn" onclick="toggleVoiceRecording()" style="
                                        background: #f3f4f6; border: none; width: 36px; height: 36px;
                                        border-radius: 50%; cursor: pointer; color: #6b7280;
                                        display: flex; align-items: center; justify-content: center;
                                        transition: all 0.2s ease; font-size: 16px;
                                    " onmouseover="this.style.background='#e5e7eb'" 
                                       onmouseout="this.style.background='#f3f4f6'">🎤</button>
                                    
                                    <!-- File browse button -->
                                    <button onclick="document.getElementById('fileInput').click()" style="
                                        background: #f3f4f6; border: none; width: 36px; height: 36px;
                                        border-radius: 50%; cursor: pointer; color: #6b7280;
                                        display: flex; align-items: center; justify-content: center;
                                        transition: all 0.2s ease; font-size: 16px;
                                    " onmouseover="this.style.background='#e5e7eb'" 
                                       onmouseout="this.style.background='#f3f4f6'">📁</button>
                                </div>
                            </div>
                            
                            <!-- Uploaded files display area -->
                            <div id="uploadedFiles" style="margin-top: 16px;"></div>
                            
                            <!-- Voice transcript area -->
                            <div id="voiceTranscript" style="
                                background: #f8fafc; border: 1px solid #e5e7eb; 
                                border-radius: 8px; padding: 16px; margin-top: 16px;
                                min-height: 100px; display: none;
                            "></div>
                            
                            <!-- URL content area -->
                            <div id="urlContent" style="
                                background: #f8fafc; border: 1px solid #e5e7eb; 
                                border-radius: 8px; padding: 16px; margin-top: 16px;
                                min-height: 200px; display: none; max-height: 300px; overflow-y: auto;
                            "></div>
                        </div>
                    </div>
                    
                    <div class="action-buttons">
                        <button class="btn btn-primary" onclick="sendContent()" style="width: 100%; font-size: 16px; padding: 12px 24px;">
                            📤 Send
                        </button>
                    </div>
                </div>
            </div>

            <!-- Loading Section -->
            <div id="loading" class="loading" style="display: none;">
                <div class="loading-spinner"></div>
                <h3>🤖 AI Analysis in Progress...</h3>
                <p>Analyzing content with GPT-5 for Australian market...</p>
            </div>

            <!-- Results Section -->
            <div id="results" class="results-section">
                <div class="result-card">
                    <h3>🧠 AI Analysis Results</h3>
                    <div class="result-score">8.7/10</div>
                    <p><strong>Viral Potential Score</strong></p>
                    
                    <div class="result-tags">
                        <span class="tag">🎭 FOMO + Opportunity</span>
                        <span class="tag">🧠 Innovation Paradigm</span>
                        <span class="tag">👤 Aussie Marketers</span>
                        <span class="tag">⚡ Competitive Edge</span>
                    </div>
                    
                    <div style="margin-top: 20px;">
                        <strong>🎯 Target Audience:</strong><br>
                        Australian marketing professionals, content creators, agency owners (25-45 years)
                    </div>
                    
                    <div style="margin-top: 16px;">
                        <strong>📱 Best Channels:</strong><br>
                        LinkedIn, Twitter, Australian marketing communities, industry newsletters
                    </div>
                    
                    <div style="margin-top: 16px;">
                        <strong>🚀 Key Optimizations:</strong>
                        <ul style="margin-top: 8px; margin-left: 20px;">
                            <li>Add Australian case study metrics</li>
                            <li>Include local marketing leader quotes</li>
                            <li>Strengthen call-to-action</li>
                            <li>Add region-specific examples</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // 🔥 页面加载测试
        console.log('🔥 JavaScript开始执行');
        
        // 🧪 添加测试函数
        window.testDocumentPreview = function() {
            console.log('🧪 测试文档预览功能');
            
            // 测试章节数据
            const sectionsKeys = Object.keys(window).filter(key => key.startsWith('sections_'));
            console.log('🧪 找到的章节数据键:', sectionsKeys);
            
            sectionsKeys.forEach(key => {
                const sections = window[key];
                console.log(`🧪 ${key}: ${sections ? sections.length : 0} 个章节`);
                if (sections && sections.length > 0) {
                    console.log('🧪 第一个章节:', sections[0]);
                }
            });
            
            // 测试预览容器
            const container = document.getElementById('documentPreviewContent');
            console.log('🧪 预览容器存在:', !!container);
            if (container) {
                console.log('🧪 预览容器:', container);
            }
            
            // 测试showSectionContent函数
            console.log('🧪 showSectionContent函数存在:', typeof window.showSectionContent);
        };
        
        // 🔥 立即定义关键函数，避免语法错误影响
        window.openKnowledgePanel = function() {
            console.log('🚀 知识库面板打开');
            
            const panel = document.getElementById('knowledgePanel');
            const overlay = document.getElementById('panelOverlay');
            
            if (panel) {
                panel.classList.add('open');
                console.log('✅ 面板打开');
            } else {
                console.error('❌ 找不到知识库面板元素');
            }
            
            if (overlay) {
                overlay.classList.add('show');
                console.log('✅ 遮罩显示');
            } else {
                console.error('❌ 找不到遮罩元素');
            }
        };
        
        // 立即定义关闭函数
        window.closeKnowledgePanel = function() {
            const panel = document.getElementById('knowledgePanel');
            const overlay = document.getElementById('panelOverlay');
            
            if (panel) {
                panel.classList.remove('open');
            }
            if (overlay) {
                overlay.classList.remove('show');
            }
        };
        
        // 🔧 紧急修复 - 知识库函数定义
        window.testOpenPanel = function() {
            console.log('🧪 Test function called!');
            const panel = document.getElementById('knowledgePanel');
            if (panel) {
                panel.style.right = '0px';
                console.log('🧪 Panel forced open');
            } else {
                console.log('🧪 Panel not found');
            }
        }
        
        // 知识库函数已在页面顶部定义
        
        // 添加全局测试函数
        window.testPanel = function() {
            console.log('🧪 直接测试面板');
            const panel = document.getElementById('knowledgePanel');
            if (panel) {
                panel.style.right = '0px';
                panel.style.display = 'flex';
                console.log('强制显示面板');
            }
        }
        
        // Load demo content
        function loadDemoContent() {
            const demoContent = `The Australian digital marketing landscape is experiencing unprecedented growth, with AI-powered content tools driving 300% efficiency increases across Sydney and Melbourne agencies.

Recent case study: A Perth-based startup achieved 450% social media engagement growth through strategic AI implementation, maintaining authentic Aussie voice while leveraging automation.

Key insight: 78% of Australian consumers prefer brands demonstrating local market understanding. This creates opportunities for content creators who blend AI efficiency with cultural authenticity.

The challenge: How do we scale content production while preserving the casual, authentic tone that resonates with Australian audiences? The answer lies in strategic human-AI collaboration.`;
            
            document.getElementById('contentInput').value = demoContent;
            isManualInput = false; // Mark as automatic content
        }

        // Add event listeners to detect manual user input
        document.addEventListener('DOMContentLoaded', function() {
            const contentInput = document.getElementById('contentInput');
            if (contentInput) {
                // Detect manual typing
                contentInput.addEventListener('input', function(e) {
                    // Only mark as manual if the event is from user interaction
                    if (e.isTrusted) {
                        isManualInput = true;
                        
                        // 🔥 当用户开始输入新内容时，清理之前的结果
                        if (contentInput.value.trim().length > 0) {
                            clearPreviousResults();
                        }
                    }
                });
                
                // Detect manual paste
                contentInput.addEventListener('paste', function(e) {
                    if (e.isTrusted) {
                        isManualInput = true;
                    }
                });
                
                // Reset manual flag when content is cleared
                contentInput.addEventListener('focus', function() {
                    if (!contentInput.value.trim()) {
                        isManualInput = false;
                    }
                });
            }
        });

        // 🔥 清理之前的结果显示（不清理输入内容）
        function clearPreviousResults() {
            console.log('🧹 清理之前的结果显示');
            
            // 清空结果显示区域
            const resultsContainer = document.getElementById('results');
            if (resultsContainer) {
                resultsContainer.innerHTML = '';
            }
            
            // 清空URL内容区域
            const urlContent = document.getElementById('urlContent');
            if (urlContent) {
                urlContent.style.display = 'none';
                urlContent.innerHTML = '';
            }
            
            // 清空上传文件显示区域
            const uploadedFiles = document.getElementById('uploadedFiles');
            if (uploadedFiles) {
                uploadedFiles.innerHTML = '';
            }
            
            // 清空全局结果缓存
            window.lastAnalysisResult = null;
            window.lastProcessedContent = null;
            window.currentUploadedFiles = [];
            
            console.log('✅ 已清理之前的结果显示');
        }

        // Send content function (combines load demo and analyze)
        function sendContent() {
            const content = document.getElementById('contentInput').value.trim();
            if (!content) {
                alert('请输入内容后再发送');
                return;
            }
            
            // Check if content is from manual user input
            if (!isManualInput) {
                alert('请手动输入内容或修改现有内容后再发送。\n系统检测到当前内容来自自动加载，而非用户输入。');
                return;
            }
            
            // Call the existing analyze function
            analyzeContent();
        }

        // Analyze content with smart URL detection
        function analyzeContent() {
            const content = document.getElementById('contentInput').value.trim();
            if (!content) {
                alert('Please enter some content to analyze');
                return;
            }

            console.log('🔍 智能内容分析开始:', content.substring(0, 100) + '...');

            // Smart detection: Check if content is a URL
            if (isValidURL(content)) {
                console.log('🌐 检测到URL输入，使用URL分析模式');
                analyzeURL(content);
                return;
            }

            // If not URL, proceed with regular text analysis
            console.log('📝 检测到文本输入，使用文本分析模式');
            analyzeTextContent(content);
        }

        // URL validation function
        function isValidURL(string) {
            try {
                new URL(string);
                return true;
            } catch (_) {
                return false;
            }
        }

        // Analyze URL content
        async function analyzeURL(url) {
            console.log('🌐 开始URL分析:', url);
            
            // Update workflow step
            updateActiveStep('analysis');
            
            // Show loading
            document.getElementById('loading').style.display = 'block';
            document.getElementById('results').classList.remove('show');
            
            try {
                console.log('📡 发送URL到GraphRAG API...');
                
                // Call the URL scraping API
                const response = await fetch('http://localhost:8000/api/scrape', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ url: url })
                });
                
                const data = await response.json();
                console.log('📡 GraphRAG API响应状态:', response.status);
                console.log('✅ GraphRAG Agent分析完成!');
                console.log('🔍 完整分析结果:', data);
                
                if (data.status === 'success' && data.analysis) {
                    // Hide loading and show results
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('results').classList.add('show');
                    updateActiveStep('research');
                    
                    // Display URL analysis results
                    displayURLAnalysisResults(data.analysis, url);
                    
                    // 🔥 自动保存到知识树
                    const urlFile = new File([data.analysis.content], 
                        `url_${new URL(url).hostname}_${Date.now()}.txt`, 
                        { type: 'text/plain' });
                    urlFile.sourceUrl = url;
                    
                    await autoSaveToKnowledgeTree(urlFile, data);
                    console.log('✅ URL内容已自动保存到知识树');
                    
                } else {
                    throw new Error(data.message || data.error || 'URL分析失败');
                }
                
            } catch (error) {
                console.error('❌ URL分析错误:', error);
                document.getElementById('loading').style.display = 'none';
                alert('URL分析失败: ' + error.message + '\n请检查URL是否有效或服务是否正常运行');
            }
        }

        // Analyze regular text content (original function)
        async function analyzeTextContent(content) {
            console.log('📝 开始文本内容分析');
            
            // Analyze trends first
            const trendMatches = analyzeTrendsForContent(content);
            if (trendMatches.length > 0) {
                // Auto-trigger trending analysis
                setTimeout(() => {
                    showTrendingAnalysis();
                    updateTrendingInsightsForContent(trendMatches);
                }, 1000);
            }

            // Update workflow step
            updateActiveStep('analysis');
            
            // Show loading
            document.getElementById('loading').style.display = 'block';
            document.getElementById('results').classList.remove('show');
            
            try {
                console.log('📡 发送文本内容到GraphRAG API进行分析...');
                
                // Call the text analysis API
                const response = await fetch('http://localhost:8000/api/analyze-text', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ content: content })
                });
                
                const data = await response.json();
                console.log('📡 文本分析API响应状态:', response.status);
                console.log('✅ 文本分析完成!');
                console.log('🔍 完整分析结果:', data);
                
                if (data.status === 'success' && data.analysis) {
                    // Hide loading and show results
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('results').classList.add('show');
                    updateActiveStep('research');
                    
                    // Display text analysis results
                    displayTextAnalysisResults(data.analysis, content);
                    
                    // 🔥 自动保存到知识树
                    const textFile = new File([content], 
                        `manual_input_${Date.now()}.txt`, 
                        { type: 'text/plain' });
                    
                    await autoSaveToKnowledgeTree(textFile, data);
                    console.log('✅ 文本内容已自动保存到知识树');
                    
                } else {
                    throw new Error(data.message || data.error || '文本分析失败');
                }
                
            } catch (error) {
                console.error('❌ 文本分析错误:', error);
                console.log('⚠️ API调用失败，使用本地模拟分析');
                
                // 如果API失败，使用本地模拟分析
                await performLocalTextAnalysis(content);
            }
        }
        
        // 本地文本分析（当API不可用时的后备方案）
        async function performLocalTextAnalysis(content) {
            console.log('🔧 使用本地模拟分析');
            
            // 简单的本地分析逻辑
            const entities = extractEntitiesFromText(content);
            const concepts = extractConceptsFromText(content);
            
            const localAnalysis = {
                content: content,
                entities: entities,
                concepts: concepts,
                confidence: 0.7,
                source: 'local_analysis'
            };
            
            // 模拟分析结果
            const mockResult = {
                status: 'success',
                analysis: localAnalysis,
                positionSuggestion: {
                    primarySuggestion: {
                        path: '文本内容/用户输入/手动输入'
                    }
                }
            };
            
            setTimeout(async () => {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('results').classList.add('show');
                updateActiveStep('research');
                
                // Display local analysis results
                displayTextAnalysisResults(localAnalysis, content);
                
                // 🔥 自动保存到知识树
                const textFile = new File([content], 
                    `manual_input_${Date.now()}.txt`, 
                    { type: 'text/plain' });
                
                await autoSaveToKnowledgeTree(textFile, mockResult);
                console.log('✅ 文本内容已自动保存到知识树（本地分析）');
                
            }, 2000);
        }
        
        // 简单的实体提取
        function extractEntitiesFromText(text) {
            const entities = [];
            
            // 检测人名（简单的中英文人名模式）
            const namePattern = /[A-Z][a-z]+\s+[A-Z][a-z]+|[\u4e00-\u9fa5]{2,4}(?:先生|女士|教授|博士)?/g;
            let matches = text.match(namePattern);
            if (matches) {
                entities.push(...matches.slice(0, 5));
            }
            
            // 检测组织机构
            const orgPattern = /[A-Z][A-Za-z]*(?:\s+[A-Z][A-Za-z]*)*(?:\s+(?:Inc|Corp|LLC|Ltd|Company|University|School))?/g;
            matches = text.match(orgPattern);
            if (matches) {
                entities.push(...matches.filter(m => m.length > 3).slice(0, 3));
            }
            
            // 检测中文关键词
            const chineseKeywords = text.match(/[\u4e00-\u9fa5]{2,6}/g);
            if (chineseKeywords) {
                const filtered = chineseKeywords.filter(k => 
                    !['这个', '那个', '我们', '他们', '可以', '应该', '因为', '所以', '但是', '如果', '虽然', '然而'].includes(k)
                );
                entities.push(...filtered.slice(0, 5));
            }
            
            return [...new Set(entities)].slice(0, 10); // 去重并限制数量
        }
        
        // 简单的概念提取
        function extractConceptsFromText(text) {
            const concepts = [];
            
            // 技术概念
            const techConcepts = ['AI', '人工智能', '机器学习', '深度学习', '算法', '数据', '系统', '平台', '技术', '开发', '编程', '代码'];
            techConcepts.forEach(concept => {
                if (text.includes(concept)) {
                    concepts.push(concept);
                }
            });
            
            // 商业概念
            const businessConcepts = ['管理', '营销', '策略', '市场', '客户', '服务', '产品', '品牌', '价值', '创新'];
            businessConcepts.forEach(concept => {
                if (text.includes(concept)) {
                    concepts.push(concept);
                }
            });
            
            // 学习概念
            const learningConcepts = ['学习', '教育', '培训', '知识', '技能', '经验', '方法', '理论', '实践'];
            learningConcepts.forEach(concept => {
                if (text.includes(concept)) {
                    concepts.push(concept);
                }
            });
            
            return [...new Set(concepts)].slice(0, 8); // 去重并限制数量
        }
        
        // Display text analysis results
        function displayTextAnalysisResults(analysis, originalContent) {
            console.log('🎨 显示文本分析结果:', analysis);
            
            // Update the results section with real analysis data
            const resultsContainer = document.getElementById('results');
            if (resultsContainer) {
                // Create analysis summary
                const content = analysis.content || originalContent;
                const entities = analysis.entities || [];
                const concepts = analysis.concepts || [];
                
                // Add text-specific results display
                const textResultsHtml = `
                    <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 12px; margin: 20px 0;">
                        <h3>📝 文本分析结果</h3>
                        <div style="margin: 10px 0;">
                            <strong>📄 内容长度:</strong> ${content.length} 字符
                        </div>
                        <div style="margin: 10px 0;">
                            <strong>🏷️ 提取实体:</strong> ${entities.length} 个
                            ${entities.slice(0,8).map(e => `<span style="background: #8b5cf6; color: white; padding: 2px 6px; border-radius: 4px; font-size: 12px; margin: 2px;">${e}</span>`).join('')}
                        </div>
                        <div style="margin: 10px 0;">
                            <strong>💡 识别概念:</strong> ${concepts.length} 个
                            ${concepts.slice(0,6).map(c => `<span style="background: #10b981; color: white; padding: 2px 6px; border-radius: 4px; font-size: 12px; margin: 2px;">${c}</span>`).join('')}
                        </div>
                        <div style="margin: 10px 0;">
                            <strong>📝 完整内容:</strong>
                            <div style="background: rgba(0,0,0,0.1); padding: 15px; border-radius: 8px; font-size: 13px; max-height: 400px; overflow-y: auto; margin-top: 5px; white-space: pre-wrap;">
                                ${content}
                            </div>
                        </div>
                        <div style="margin: 10px 0; font-size: 12px; color: rgba(255,255,255,0.7);">
                            ${analysis.source === 'local_analysis' ? '🔧 本地分析结果' : '🤖 AI分析结果'}
                        </div>
                    </div>
                `;
                
                // Insert text results at the beginning of the results container
                resultsContainer.insertAdjacentHTML('afterbegin', textResultsHtml);
            }
            
            console.log('✅ 文本分析结果显示完成');
        }

        // Display URL analysis results
        function displayURLAnalysisResults(analysis, originalUrl) {
            console.log('🎨 显示URL分析结果:', analysis);
            
            // Update the results section with real analysis data
            const resultsContainer = document.getElementById('results');
            if (resultsContainer) {
                // Create analysis summary
                const content = analysis.content || '';
                const entities = analysis.entities || [];
                const concepts = analysis.concepts || [];
                
                // Add URL-specific results display
                const urlResultsHtml = `
                    <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 12px; margin: 20px 0;">
                        <h3>🌐 URL分析结果</h3>
                        <div style="margin: 10px 0;">
                            <strong>📊 分析URL:</strong> ${originalUrl}
                        </div>
                        <div style="margin: 10px 0;">
                            <strong>📄 内容长度:</strong> ${content.length} 字符
                        </div>
                        <div style="margin: 10px 0;">
                            <strong>🏷️ 提取实体:</strong> ${entities.length} 个
                            ${entities.slice(0,5).map(e => `<span style="background: #8b5cf6; color: white; padding: 2px 6px; border-radius: 4px; font-size: 12px; margin: 2px;">${e}</span>`).join('')}
                        </div>
                        <div style="margin: 10px 0;">
                            <strong>💡 识别概念:</strong> ${concepts.length} 个
                            ${concepts.slice(0,5).map(c => `<span style="background: #10b981; color: white; padding: 2px 6px; border-radius: 4px; font-size: 12px; margin: 2px;">${c}</span>`).join('')}
                        </div>
                        <div style="margin: 10px 0;">
                            <strong>📝 完整内容:</strong>
                            <div style="background: rgba(0,0,0,0.1); padding: 15px; border-radius: 8px; font-size: 13px; max-height: 400px; overflow-y: auto; margin-top: 5px; white-space: pre-wrap;">
                                ${content}
                            </div>
                        </div>
                    </div>
                `;
                
                // Insert URL results at the beginning of the results container
                resultsContainer.insertAdjacentHTML('afterbegin', urlResultsHtml);
            }
            
            console.log('✅ URL分析结果显示完成');
        }

        function updateTrendingInsightsForContent(matches) {
            const insightsContainer = document.querySelector('.trending-insights');
            if (insightsContainer && matches.length > 0) {
                let matchesText = matches.map(m => `${m.trend} (${m.score}% match)`).join(', ');
                const additionalInsight = document.createElement('div');
                additionalInsight.style.marginTop = '12px';
                additionalInsight.style.padding = '12px';
                additionalInsight.style.background = 'rgba(255, 255, 255, 0.15)';
                additionalInsight.style.borderRadius = '8px';
                additionalInsight.innerHTML = `
                    <strong>🎯 Content-Trend Matches:</strong><br>
                    <span class="insight-tag">${matchesText}</span>
                    <span class="insight-tag">Viral potential: High</span>
                    <span class="insight-tag">Best time: Peak engagement hours</span>
                `;
                insightsContainer.appendChild(additionalInsight);
            }
        }

        // Make key functions global for HTML onclick attributes
        window.selectNode = selectNode;
        window.toggleNode = toggleNode;
        window.editNodeTitle = editNodeTitle;

        // Update active step
        function updateActiveStep(stepName) {
            // Remove active class from all steps
            document.querySelectorAll('.step').forEach(step => {
                step.classList.remove('active');
            });
            
            // Add completed class to previous steps and active to current
            const steps = ['knowledge', 'input', 'analysis', 'research', 'trends', 'create', 'optimize', 'video', 'publish'];
            const currentIndex = steps.indexOf(stepName);
            
            steps.forEach((step, index) => {
                const stepElement = document.querySelector(`[data-step="${step}"]`);
                if (index < currentIndex) {
                    stepElement.classList.add('completed');
                } else if (index === currentIndex) {
                    stepElement.classList.add('active');
                }
            });
        }

        // Toggle knowledge base
        function toggleKnowledgeBase() {
            openKnowledgePanel();
        }

        // Trending Analysis Functions
        function showTrendingAnalysis() {
            const trendingSection = document.getElementById('trendingSection');
            
            // Show trending section
            trendingSection.style.display = 'block';
            
            // Update trends step to active
            const trendsStep = document.querySelector('[data-step="trends"]');
            trendsStep.classList.add('active');
            
            // Simulate real-time data update
            setTimeout(() => {
                updateTrendingData();
            }, 1500);
        }

        function updateTrendingData() {
            // Simulate real-time trending data updates
            const trendItems = document.querySelectorAll('.trend-item');
            trendItems.forEach((item, index) => {
                const scoreElement = item.querySelector('.trend-score');
                if (scoreElement) {
                    // Add slight random variation to scores
                    const currentScore = scoreElement.textContent;
                    if (currentScore.includes('%')) {
                        const baseScore = parseInt(currentScore);
                        const variation = Math.floor(Math.random() * 4) - 2; // -2 to +2
                        const newScore = Math.max(0, Math.min(100, baseScore + variation));
                        scoreElement.textContent = newScore + '%';
                    }
                }
            });
        }

        function analyzeTrendsForContent(content) {
            // Analyze content against trending topics
            const trends = [
                'AI Content Marketing',
                'Digital Transformation', 
                'Sydney Tech Hub',
                'Remote Work Tools'
            ];
            
            const matches = [];
            trends.forEach(trend => {
                const trendWords = trend.toLowerCase().split(' ');
                const contentLower = content.toLowerCase();
                let matchScore = 0;
                
                trendWords.forEach(word => {
                    if (contentLower.includes(word)) {
                        matchScore += 25;
                    }
                });
                
                if (matchScore > 0) {
                    matches.push({
                        trend: trend,
                        score: Math.min(100, matchScore + Math.floor(Math.random() * 20))
                    });
                }
            });
            
            return matches;
        }

        // Step click handlers
        document.querySelectorAll('.step').forEach(step => {
            step.addEventListener('click', function() {
                const stepName = this.getAttribute('data-step');
                
                // Special handling for knowledge step
                if (stepName === 'knowledge') {
                    toggleKnowledgeBase();
                }
                
                // Special handling for trends step
                if (stepName === 'trends') {
                    showTrendingAnalysis();
                }
                
                // Special handling for video step
                if (stepName === 'video') {
                    showDigitalHumanVideoGenerator();
                }
                
                updateActiveStep(stepName);
            });
        });

        // Unified DOM initialization
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🚀 DOM loaded, initializing app...');
            console.log('🔍 Current URL:', window.location.href);
            console.log('🔍 Document title:', document.title);
            
            // 🔥 重要：重置所有全局锁状态
            window.isProcessingFiles = false;
            window.lastProcessedSignature = null;
            console.log('✅ 重置全局文件处理状态');
            
            // 添加拖拽测试
            window.testDrag = function() {
                console.log('🧪 测试拖拽功能');
                const container = document.querySelector('.multimodal-input-container');
                console.log('输入容器存在:', !!container);
                
                if (container) {
                    console.log('容器元素:', container);
                    console.log('容器事件监听器数量:', getEventListeners ? getEventListeners(container) : '无法检测');
                }
            };
            
            // Add global click detector for debugging
            document.addEventListener('click', function(e) {
                console.log('🖱️ GLOBAL CLICK:', e.target);
                if (e.target.closest('[data-step="knowledge"]')) {
                    console.log('🎯 Click detected on knowledge step!');
                }
            });
            
            // Add global drag detector for debugging
            document.addEventListener('dragenter', function(e) {
                console.log('🌍 GLOBAL DRAGENTER:', e.target);
            });
            document.addEventListener('dragover', function(e) {
                console.log('🌍 GLOBAL DRAGOVER:', e.target);
            });
            document.addEventListener('drop', function(e) {
                console.log('🌍 GLOBAL DROP:', e.target, 'Files:', e.dataTransfer?.files?.length);
            });
            
            // 🔄 重要：初始化时恢复知识树
            setTimeout(async () => {
                console.log('🔄 页面初始化，恢复知识树...');
                await regenerateKnowledgeTree();
                
                const existingNodes = document.querySelectorAll('#knowledgeTree .tree-node');
                existingNodes.forEach(node => {
                    updateEventHandlers(node);
                });
            }, 100);
            
            // Make knowledge step clickable with enhanced debugging
            const knowledgeStep = document.querySelector('[data-step="knowledge"]');
            console.log('🔍 Looking for knowledge step:', knowledgeStep);
            console.log('🔍 Available steps:', document.querySelectorAll('.step'));
            console.log('🔍 Available data-step elements:', document.querySelectorAll('[data-step]'));
            
            if (knowledgeStep) {
                console.log('✅ Knowledge step found, adding event listeners...');
                knowledgeStep.style.cursor = 'pointer';
                
                // Add multiple event listeners for better debugging
                knowledgeStep.addEventListener('click', function(e) {
                    console.log('📚 Knowledge step CLICKED via addEventListener!', e.target);
                    console.log('📚 Event details:', {
                        type: e.type,
                        target: e.target,
                        currentTarget: e.currentTarget,
                        bubbles: e.bubbles,
                        cancelable: e.cancelable
                    });
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('📚 Calling openKnowledgePanel...');
                    openKnowledgePanel();
                });
                
                // Also add mousedown for more debugging
                knowledgeStep.addEventListener('mousedown', function(e) {
                    console.log('🖱️ Knowledge step MOUSEDOWN detected!', e.target);
                });
                
                knowledgeStep.addEventListener('mouseup', function(e) {
                    console.log('🖱️ Knowledge step MOUSEUP detected!', e.target);
                });
                
                console.log('✅ All event listeners added to knowledge step');
            } else {
                console.error('❌ Knowledge step not found!');
                // Let's also search for it manually to see what's available
                console.log('🔍 Available steps:', document.querySelectorAll('.step'));
                console.log('🔍 Available data-step elements:', document.querySelectorAll('[data-step]'));
            }
            
            // Initialize draggable panel
            const panel = document.getElementById('selectedDocsPanel');
            const header = document.getElementById('selectedDocsPanelHeader');
            
            if (header && panel) {
                header.addEventListener('mousedown', function(e) {
                    isDragging = true;
                    const rect = panel.getBoundingClientRect();
                    dragOffset.x = e.clientX - rect.left;
                    dragOffset.y = e.clientY - rect.top;
                    
                    panel.style.transition = 'none';
                    document.body.style.userSelect = 'none';
                });
                
                document.addEventListener('mousemove', function(e) {
                    if (!isDragging) return;
                    
                    const newX = e.clientX - dragOffset.x;
                    const newY = e.clientY - dragOffset.y;
                    
                    const maxX = window.innerWidth - panel.offsetWidth;
                    const maxY = window.innerHeight - panel.offsetHeight;
                    
                    const constrainedX = Math.max(0, Math.min(newX, maxX));
                    const constrainedY = Math.max(0, Math.min(newY, maxY));
                    
                    panel.style.left = constrainedX + 'px';
                    panel.style.top = constrainedY + 'px';
                    panel.style.right = 'auto';
                    panel.style.transform = 'none';
                });
                
                document.addEventListener('mouseup', function() {
                    if (isDragging) {
                        isDragging = false;
                        panel.style.transition = 'right 0.4s ease';
                        document.body.style.userSelect = '';
                    }
                });
            }
            
            // Initialize file input
            const fileInput = document.getElementById('fileInput');
            if (fileInput) {
                fileInput.addEventListener('change', function(e) {
                    if (e.target.files.length > 0) {
                        processUploadedFiles(e.target.files);
                    }
                });
            }
            
            console.log('✅ App initialization complete');
            
            // Initialize UI states
            updateSelectionUI();
            
            // Add test functions to window for debugging
            window.testFunctions = function() {
                console.log('🧪 Testing all functions...');
                
                // Test panel opening
                console.log('🔍 Testing knowledge panel...');
                const panel = document.getElementById('knowledgePanel');
                const overlay = document.getElementById('panelOverlay');
                console.log('Panel exists:', !!panel);
                console.log('Overlay exists:', !!overlay);
                
                // Test checkboxes
                console.log('🔍 Testing checkboxes...');
                const checkboxes = document.querySelectorAll('.node-checkbox');
                console.log('Total checkboxes found:', checkboxes.length);
                
                // Test export button
                console.log('🔍 Testing export button...');
                const exportBtn = document.querySelector('[onclick="exportSelectedKnowledge()"]');
                console.log('Export button exists:', !!exportBtn);
                
                return {
                    panel: !!panel,
                    overlay: !!overlay,
                    checkboxes: checkboxes.length,
                    exportButton: !!exportBtn
                };
            };
            
            // Automatically run test
            setTimeout(() => {
                const testResults = window.testFunctions();
                console.log('🧪 Test results:', testResults);
            }, 1000);
            
            // Add global drag and drop support to the input container
            const inputContainer = document.querySelector('.multimodal-input-container');
            console.log('🔍 Input container found:', inputContainer);
            
            if (inputContainer) {
                console.log('📁 Adding global drag support to input container');
                
                // Prevent default drag behaviors on window
                window.addEventListener('dragenter', function(e) {
                    e.preventDefault();
                }, false);
                window.addEventListener('dragover', function(e) {
                    e.preventDefault();
                }, false);
                window.addEventListener('drop', function(e) {
                    e.preventDefault();
                }, false);
                
                inputContainer.addEventListener('dragenter', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('🔍 DRAG ENTER - adding dragover class and visual feedback!');
                    console.log('🔍 Event target:', e.target);
                    console.log('🔍 Current target:', e.currentTarget);
                    this.classList.add('dragover');
                    this.style.borderColor = '#667eea !important';
                    this.style.backgroundColor = '#f0f9ff !important';
                    this.style.border = '3px dashed #667eea !important';
                    
                    // Add a temporary visual indicator inside the input container
                    if (!document.getElementById('dragIndicator')) {
                        const indicator = document.createElement('div');
                        indicator.id = 'dragIndicator';
                        indicator.style.cssText = `
                            position: absolute;
                            top: 50%; left: 50%; transform: translate(-50%, -50%);
                            background: rgba(102, 126, 234, 0.95); color: white; padding: 12px 20px;
                            border-radius: 8px; z-index: 1000; font-size: 14px; font-weight: bold;
                            pointer-events: none; white-space: nowrap;
                        `;
                        indicator.textContent = '🎯 Drop files here!';
                        this.style.position = 'relative';
                        this.appendChild(indicator);
                    }
                });
                
                inputContainer.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.dataTransfer.dropEffect = 'copy';
                    console.log('🔍 Drag over');
                    this.classList.add('dragover');
                    this.style.borderColor = '#667eea';
                    this.style.backgroundColor = '#f0f9ff';
                });
                
                inputContainer.addEventListener('dragleave', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    // Only remove if leaving the container entirely
                    if (!inputContainer.contains(e.relatedTarget)) {
                        console.log('🔍 DRAG LEAVE - removing dragover class and visual feedback!');
                        this.classList.remove('dragover');
                        this.style.borderColor = '#e2e8f0';
                        this.style.backgroundColor = 'white';
                        this.style.border = '2px solid #e2e8f0';
                        
                        // Remove visual indicator
                        const indicator = document.getElementById('dragIndicator');
                        if (indicator) {
                            indicator.remove();
                        }
                    }
                });
                
                inputContainer.addEventListener('drop', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('🔍 INPUT CONTAINER DROP - 检查文件');
                    
                    // Remove visual feedback
                    this.classList.remove('dragover');
                    this.style.borderColor = '#e2e8f0';
                    this.style.backgroundColor = 'white';
                    this.style.border = '2px solid #e2e8f0';
                    
                    // Remove visual indicator
                    const indicator = document.getElementById('dragIndicator');
                    if (indicator) {
                        indicator.remove();
                    }
                    
                    const files = e.dataTransfer.files;
                    console.log('📁 Files dropped on input container:', files.length);
                    console.log('🔍 Current processing state:', window.isProcessingFiles);
                    
                    if (files.length > 0) {
                        console.log('✅ Processing dropped files...');
                        
                        // 🔥 强制重置处理状态，确保拖拽可以工作
                        if (window.isProcessingFiles) {
                            console.log('⚠️ 检测到处理中状态，强制重置');
                            window.isProcessingFiles = false;
                            window.lastProcessedSignature = null;
                        }
                        
                        switchInputMode('file');
                        console.log('🎯 调用 processUploadedFiles...');
                        processUploadedFiles(files);
                    } else {
                        console.log('❌ No files in drop event');
                    }
                });
                
                // Also add support to the file drop zone specifically
                const fileDropZone = document.querySelector('.file-drop-zone');
                if (fileDropZone) {
                    console.log('📁 Adding drag support to file drop zone');
                    
                    fileDropZone.addEventListener('dragenter', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('🎯 File drop zone - drag enter');
                        this.style.borderColor = '#667eea';
                        this.style.backgroundColor = '#e0e7ff';
                    });
                    
                    fileDropZone.addEventListener('dragover', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.dataTransfer.dropEffect = 'copy';
                    });
                    
                    fileDropZone.addEventListener('dragleave', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        if (!this.contains(e.relatedTarget)) {
                            this.style.borderColor = '#cbd5e1';
                            this.style.backgroundColor = '#f8fafc';
                        }
                    });
                    
                    fileDropZone.addEventListener('drop', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('🎯 File drop zone - drop detected!');
                        this.style.borderColor = '#cbd5e1';
                        this.style.backgroundColor = '#f8fafc';
                        
                        const files = e.dataTransfer.files;
                        console.log('📁 Files dropped on zone:', files.length);
                        if (files.length > 0) {
                            switchInputMode('file');
                            processUploadedFiles(files);
                        }
                    });
                }
            } else {
                console.error('❌ Input container not found!');
            }
            
            // Also use event delegation for better reliability
            document.addEventListener('click', function(event) {
                // Handle node content clicks for file nodes
                if (event.target.closest('.node-content') && 
                    !event.target.classList.contains('node-action') &&
                    !event.target.closest('.node-actions')) {
                    
                    const nodeContent = event.target.closest('.node-content');
                    const nodeIcon = nodeContent.querySelector('.node-icon');
                    
                    // Only show content for file nodes (not folders)
                    if (nodeIcon && nodeIcon.classList.contains('file')) {
                        console.log('File node clicked via delegation');
                        showNodeContent(event, nodeContent);
                        return;
                    }
                }
                
                if (event.target.classList.contains('node-action')) {
                    const buttonText = event.target.textContent || event.target.innerHTML;
                    console.log('🎯 Node action clicked via delegation:', buttonText, event.target);
                    
                    if (buttonText.includes('✏️')) {
                        editNode(event, event.target);
                    } else if (buttonText.includes('🗑️')) {
                        console.log('🗑️ Delete detected via delegation, calling deleteNode');
                        deleteNode(event, event.target);
                    } else if (buttonText.includes('➕')) {
                        addChildItem(event, event.target);
                    } else {
                        console.log('🤔 Unknown button text:', buttonText);
                    }
                } else if (event.target.classList.contains('node-select-btn')) {
                    // Handle selection button clicks
                    toggleSelection(event, event.target);
                }
            });
        });
        
        // Node selection function for checkboxes
        window.toggleNodeSelection = function(event, checkboxElement) {
            console.log('🎯 toggleNodeSelection called!', event, checkboxElement);
            event.stopPropagation(); // Prevent triggering node content click
            
            const isSelected = checkboxElement.classList.contains('selected');
            const nodeContent = checkboxElement.closest('.node-content');
            const title = nodeContent.querySelector('.node-title').textContent;
            const treeNode = nodeContent.closest('.tree-node');
            const isFolder = nodeContent.querySelector('.node-icon').classList.contains('folder');
            
            console.log(`🔍 Node: ${title}, Selected: ${isSelected}, IsFolder: ${isFolder}`);
            
            if (isSelected) {
                // Deselect this node
                deselectNodeCheckbox(checkboxElement, title);
                
                // If it's a folder, deselect all children
                if (isFolder) {
                    deselectAllChildren(treeNode);
                }
            } else {
                // Select this node
                selectNodeCheckbox(checkboxElement, title, nodeContent);
                
                // If it's a folder, select all children
                if (isFolder) {
                    selectAllChildren(treeNode);
                }
            }
            
            // Update UI to show selected count
            updateSelectionUI();
        }
        
        function selectNodeCheckbox(checkboxElement, title, nodeContent) {
            checkboxElement.classList.add('selected');
            checkboxElement.textContent = '✓';
            console.log(`✅ Selected: ${title}`);
            
            // Add to global selectedNodes array
            if (typeof selectedNodes !== 'undefined') {
                if (!selectedNodes.includes(title)) {
                    selectedNodes.push(title);
                    // Also add to selectedNodesData if it exists
                    if (typeof selectedNodesData !== 'undefined') {
                        // 🔥 获取真实文件内容用于分析
                        let fileContent = nodeContentStore[title] || '';
                        
                        // 如果是上传的文件，尝试从存储中获取textContent
                        const treeNode = nodeContent.closest('.tree-node');
                        const storageKey = treeNode?.getAttribute('data-file-storage-key');
                        if (storageKey && !fileContent) {
                            try {
                                const fileDataStr = localStorage.getItem(storageKey);
                                if (fileDataStr) {
                                    const fileData = JSON.parse(fileDataStr);
                                    fileContent = fileData.textContent || '';
                                }
                            } catch (error) {
                                console.log('⚠️ 无法从文件存储获取内容:', error);
                            }
                        }
                        
                        selectedNodesData[title] = {
                            content: fileContent || getSampleContent(title) || '',
                            type: nodeContent.querySelector('.node-icon').classList.contains('folder') ? 'folder' : 'file',
                            element: nodeContent
                        };
                    }
                }
            }
        }
        
        function deselectNodeCheckbox(checkboxElement, title) {
            checkboxElement.classList.remove('selected');
            checkboxElement.textContent = '✓';
            console.log(`🔲 Deselected: ${title}`);
            
            // Remove from global selectedNodes array
            if (typeof selectedNodes !== 'undefined') {
                selectedNodes = selectedNodes.filter(name => name !== title);
                // Also remove from selectedNodesData if it exists
                if (typeof selectedNodesData !== 'undefined') {
                    delete selectedNodesData[title];
                }
            }
        }
        
        function selectAllChildren(parentTreeNode) {
            const childrenContainer = parentTreeNode.querySelector('.node-children');
            if (childrenContainer) {
                const childNodes = childrenContainer.querySelectorAll('.tree-node');
                childNodes.forEach(childNode => {
                    const childCheckbox = childNode.querySelector('.node-checkbox');
                    const childNodeContent = childNode.querySelector('.node-content');
                    const childTitle = childNodeContent.querySelector('.node-title').textContent;
                    
                    if (childCheckbox && !childCheckbox.classList.contains('selected')) {
                        selectNodeCheckbox(childCheckbox, childTitle, childNodeContent);
                        
                        // If this child is also a folder, recursively select its children
                        const childIsFolder = childNodeContent.querySelector('.node-icon').classList.contains('folder');
                        if (childIsFolder) {
                            selectAllChildren(childNode);
                        }
                    }
                });
            }
        }
        
        function deselectAllChildren(parentTreeNode) {
            const childrenContainer = parentTreeNode.querySelector('.node-children');
            if (childrenContainer) {
                const childNodes = childrenContainer.querySelectorAll('.tree-node');
                childNodes.forEach(childNode => {
                    const childCheckbox = childNode.querySelector('.node-checkbox');
                    const childNodeContent = childNode.querySelector('.node-content');
                    const childTitle = childNodeContent.querySelector('.node-title').textContent;
                    
                    if (childCheckbox && childCheckbox.classList.contains('selected')) {
                        deselectNodeCheckbox(childCheckbox, childTitle);
                        
                        // If this child is also a folder, recursively deselect its children
                        const childIsFolder = childNodeContent.querySelector('.node-icon').classList.contains('folder');
                        if (childIsFolder) {
                            deselectAllChildren(childNode);
                        }
                    }
                });
            }
        }
        
        function updateSelectionUI() {
            const selectedCount = document.querySelectorAll('.node-checkbox.selected').length;
            console.log(`📊 Total selected nodes: ${selectedCount}`);
            
            // Enable/disable the insight analysis button based on selection
            const insightButton = document.querySelector('button[onclick="startInsightAnalysis()"]');
            if (insightButton) {
                if (selectedCount > 0) {
                    // Enable button
                    insightButton.disabled = false;
                    insightButton.style.opacity = '1';
                    insightButton.style.cursor = 'pointer';
                    insightButton.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
                    console.log('✅ Insight Analysis button enabled');
                } else {
                    // Disable button
                    insightButton.disabled = true;
                    insightButton.style.opacity = '0.5';
                    insightButton.style.cursor = 'not-allowed';
                    insightButton.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
                    console.log('❌ Insight Analysis button disabled');
                }
            }
            
            // Update selected nodes display if function exists
            if (typeof updateSelectedDocsDisplay === 'function') {
                updateSelectedDocsDisplay();
            }
            
            // Log the selection
            if (selectedCount > 0) {
                console.log('Selected nodes:', typeof selectedNodes !== 'undefined' ? selectedNodes : []);
            }
        }
        
        // Knowledge Base Panel Functions (integrated) - Global scope
        let isRecording = false;
        let selectedNode = null;

        // Knowledge Graph Visualization
        window.visualizeGraph = function(graphId, graphData) {
            console.log('🕸️ Visualizing knowledge graph:', graphId, graphData);
            
            const container = document.getElementById(`graph-${graphId}`);
            if (!container) {
                console.error('Graph container not found');
                return;
            }
            
            // Clear existing content
            container.innerHTML = '';
            
            // Create SVG for graph visualization
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '300');
            svg.style.background = 'white';
            
            // Simple force-directed layout simulation
            const nodes = graphData.nodes || [];
            const edges = graphData.edges || [];
            
            if (nodes.length === 0) {
                container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #6b7280;">No graph data available</div>';
                return;
            }
            
            // Position nodes in a simple layout
            const width = container.offsetWidth || 400;
            const height = 300;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Position nodes in a circle if multiple, or center if single
            nodes.forEach((node, index) => {
                if (nodes.length === 1) {
                    node.x = centerX;
                    node.y = centerY;
                } else {
                    const angle = (2 * Math.PI * index) / nodes.length;
                    const radius = Math.min(width, height) * 0.3;
                    node.x = centerX + radius * Math.cos(angle);
                    node.y = centerY + radius * Math.sin(angle);
                }
            });
            
            // Draw edges
            edges.forEach(edge => {
                const sourceNode = nodes.find(n => n.id === edge.source);
                const targetNode = nodes.find(n => n.id === edge.target);
                
                if (sourceNode && targetNode) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', sourceNode.x);
                    line.setAttribute('y1', sourceNode.y);
                    line.setAttribute('x2', targetNode.x);
                    line.setAttribute('y2', targetNode.y);
                    line.setAttribute('stroke', '#8b5cf6');
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('opacity', '0.6');
                    svg.appendChild(line);
                    
                    // Add edge label
                    if (edge.label) {
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', (sourceNode.x + targetNode.x) / 2);
                        text.setAttribute('y', (sourceNode.y + targetNode.y) / 2);
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('font-size', '10');
                        text.setAttribute('fill', '#6b7280');
                        text.textContent = edge.label;
                        svg.appendChild(text);
                    }
                }
            });
            
            // Draw nodes
            nodes.forEach(node => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', node.x);
                circle.setAttribute('cy', node.y);
                circle.setAttribute('r', node.size || 20);
                circle.setAttribute('fill', node.color || '#8b5cf6');
                circle.setAttribute('stroke', 'white');
                circle.setAttribute('stroke-width', '2');
                circle.style.cursor = 'pointer';
                
                // Add hover effect
                circle.addEventListener('mouseenter', function() {
                    this.setAttribute('r', (node.size || 20) + 5);
                });
                circle.addEventListener('mouseleave', function() {
                    this.setAttribute('r', node.size || 20);
                });
                
                svg.appendChild(circle);
                
                // Add node label
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', node.x);
                text.setAttribute('y', node.y + 5);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', '12');
                text.setAttribute('font-weight', 'bold');
                text.setAttribute('fill', 'white');
                text.textContent = node.label || node.id;
                svg.appendChild(text);
            });
            
            container.appendChild(svg);
            
            // Add graph controls
            const controls = document.createElement('div');
            controls.style.cssText = 'position: absolute; top: 8px; right: 8px; display: flex; gap: 4px;';
            
            const resetBtn = document.createElement('button');
            resetBtn.textContent = '🔄';
            resetBtn.style.cssText = 'width: 24px; height: 24px; border: none; background: rgba(139, 92, 246, 0.8); color: white; border-radius: 4px; cursor: pointer; font-size: 12px;';
            resetBtn.title = 'Reset View';
            resetBtn.onclick = () => visualizeGraph(graphId, graphData);
            
            const fullscreenBtn = document.createElement('button');
            fullscreenBtn.textContent = '⛶';
            fullscreenBtn.style.cssText = 'width: 24px; height: 24px; border: none; background: rgba(139, 92, 246, 0.8); color: white; border-radius: 4px; cursor: pointer; font-size: 12px;';
            fullscreenBtn.title = 'Fullscreen';
            fullscreenBtn.onclick = () => {
                const modal = document.createElement('div');
                modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.8); z-index: 10000; display: flex; align-items: center; justify-content: center;';
                
                const modalContent = document.createElement('div');
                modalContent.style.cssText = 'width: 90vw; height: 90vh; background: white; border-radius: 8px; position: relative;';
                
                const closeBtn = document.createElement('button');
                closeBtn.textContent = '✕';
                closeBtn.style.cssText = 'position: absolute; top: 8px; right: 8px; width: 32px; height: 32px; border: none; background: #ef4444; color: white; border-radius: 4px; cursor: pointer;';
                closeBtn.onclick = () => modal.remove();
                
                modalContent.appendChild(closeBtn);
                modalContent.innerHTML += `<div id="fullscreen-graph-${graphId}" style="width: 100%; height: 100%; padding: 40px;"></div>`;
                
                modal.appendChild(modalContent);
                document.body.appendChild(modal);
                
                // Render full-size graph
                setTimeout(() => {
                    const fullContainer = document.getElementById(`fullscreen-graph-${graphId}`);
                    if (fullContainer) {
                        visualizeGraphInContainer(fullContainer, graphData);
                    }
                }, 100);
            };
            
            controls.appendChild(resetBtn);
            controls.appendChild(fullscreenBtn);
            container.appendChild(controls);
        }
        
        function visualizeGraphInContainer(container, graphData) {
            // Similar to visualizeGraph but adapted for different container sizes
            container.innerHTML = '';
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            
            const nodes = graphData.nodes || [];
            const edges = graphData.edges || [];
            
            const width = container.offsetWidth;
            const height = container.offsetHeight;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Position and draw similar to visualizeGraph but with larger dimensions
            nodes.forEach((node, index) => {
                if (nodes.length === 1) {
                    node.x = centerX;
                    node.y = centerY;
                } else {
                    const angle = (2 * Math.PI * index) / nodes.length;
                    const radius = Math.min(width, height) * 0.25;
                    node.x = centerX + radius * Math.cos(angle);
                    node.y = centerY + radius * Math.sin(angle);
                }
            });
            
            // Draw edges and nodes (similar code as above but scaled)
            edges.forEach(edge => {
                const sourceNode = nodes.find(n => n.id === edge.source);
                const targetNode = nodes.find(n => n.id === edge.target);
                
                if (sourceNode && targetNode) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', sourceNode.x);
                    line.setAttribute('y1', sourceNode.y);
                    line.setAttribute('x2', targetNode.x);
                    line.setAttribute('y2', targetNode.y);
                    line.setAttribute('stroke', '#8b5cf6');
                    line.setAttribute('stroke-width', '3');
                    line.setAttribute('opacity', '0.6');
                    svg.appendChild(line);
                }
            });
            
            nodes.forEach(node => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', node.x);
                circle.setAttribute('cy', node.y);
                circle.setAttribute('r', (node.size || 20) * 1.5);
                circle.setAttribute('fill', node.color || '#8b5cf6');
                circle.setAttribute('stroke', 'white');
                circle.setAttribute('stroke-width', '3');
                svg.appendChild(circle);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', node.x);
                text.setAttribute('y', node.y + 8);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', '16');
                text.setAttribute('font-weight', 'bold');
                text.setAttribute('fill', 'white');
                text.textContent = node.label || node.id;
                svg.appendChild(text);
            });
            
            container.appendChild(svg);
        }

        // 知识库函数已在上面定义，避免重复

        // 测试函数 - 直接强制打开面板
        window.testOpenPanel = function() {
            console.log('🧪 Testing panel opening...');
            const panel = document.getElementById('knowledgePanel');
            if (panel) {
                panel.style.right = '0px';
                panel.style.display = 'flex';
                console.log('🧪 Panel forced to be visible');
            }
            const overlay = document.getElementById('panelOverlay');
            if (overlay) {
                overlay.style.opacity = '1';
                overlay.style.visibility = 'visible';
                console.log('🧪 Overlay forced to be visible');
            }
        }

        window.closeKnowledgePanel = function() {
            const panel = document.getElementById('knowledgePanel');
            const overlay = document.getElementById('panelOverlay');
            console.log('🚪 closeKnowledgePanel called!', {panel, overlay});
            if (panel) panel.classList.remove('open');
            if (overlay) overlay.classList.remove('show');
        }

        window.toggleKnowledgePanel = function() {
            const panel = document.getElementById('knowledgePanel');
            if (panel && panel.classList.contains('open')) {
                closeKnowledgePanel();
            } else {
                openKnowledgePanel();
            }
        }




        function toggleNode(event, element) {
            event.stopPropagation();
            const children = element.closest('.tree-node').querySelector('.node-children');
            const isExpanded = children.classList.contains('expanded');
            
            if (isExpanded) {
                children.classList.remove('expanded');
                element.innerHTML = '▶';
            } else {
                children.classList.add('expanded');
                element.innerHTML = '▼';
            }
        }

        function selectNode(element, event = null) {
            const isMultiSelect = event && (event.ctrlKey || event.metaKey);
            const title = element.querySelector('.node-title').textContent;
            
            if (isMultiSelect) {
                // Multi-select mode
                if (element.classList.contains('selected')) {
                    // Deselect
                    element.classList.remove('selected');
                    selectedNodes = selectedNodes.filter(node => node !== title);
                    delete selectedNodesData[title];
                } else {
                    // Add to selection
                    element.classList.add('selected');
                    selectedNodes.push(title);
                    selectedNodesData[title] = {
                        content: nodeContentStore[title] || getSampleContent(title) || '',
                        type: element.querySelector('.node-icon').classList.contains('folder') ? 'folder' : 'file',
                        element: element
                    };
                }
            } else {
                // Single select mode - clear all others first
                document.querySelectorAll('.node-content.selected').forEach(node => {
                    node.classList.remove('selected');
                });
                selectedNodes = [];
                selectedNodesData = {};
                
                // Select current node
                element.classList.add('selected');
                selectedNodes.push(title);
                // 🔥 获取真实文件内容用于分析
                let fileContent = nodeContentStore[title] || '';
                
                // 如果是上传的文件，尝试从存储中获取textContent
                const treeNode = element.closest('.tree-node');
                const storageKey = treeNode?.getAttribute('data-file-storage-key');
                if (storageKey && !fileContent) {
                    try {
                        const fileDataStr = localStorage.getItem(storageKey);
                        if (fileDataStr) {
                            const fileData = JSON.parse(fileDataStr);
                            fileContent = fileData.textContent || '';
                            console.log('✅ 获取到文件存储内容用于分析:', fileContent.length, '字符');
                        }
                    } catch (error) {
                        console.log('⚠️ 无法从文件存储获取内容:', error);
                    }
                }
                
                selectedNodesData[title] = {
                    content: fileContent || getSampleContent(title) || '',
                    type: element.querySelector('.node-icon').classList.contains('folder') ? 'folder' : 'file',
                    element: element
                };
                
                // If this is a folder, also select all its children
                if (selectedNodesData[title].type === 'folder') {
                    const parentNode = element.parentElement;
                    const childrenContainer = parentNode.querySelector('.node-children');
                    if (childrenContainer) {
                        const children = childrenContainer.querySelectorAll('.node-content');
                        children.forEach(child => {
                            const childTitle = child.querySelector('.node-title').textContent;
                            child.classList.add('selected');
                            selectedNodes.push(childTitle);
                            selectedNodesData[childTitle] = {
                                content: nodeContentStore[childTitle] || getSampleContent(childTitle) || '',
                                type: child.querySelector('.node-icon').classList.contains('folder') ? 'folder' : 'file',
                                element: child
                            };
                        });
                    }
                }
            }
            
            // Update analysis button state (function placeholder)
            // updateAnalysisButtonState(); // 临时禁用，避免错误
            
            selectedNode = element;
            console.log('Selected nodes for analysis:', selectedNodes);
        }

        // Toggle selected docs floating panel
        window.toggleSelectedDocsPanel = function() {
            const panel = document.getElementById('selectedDocsPanel');
            const toggle = document.getElementById('selectedDocsPanelToggle');
            const isExpanded = panel.style.right === '0px';
            
            if (isExpanded) {
                panel.style.right = '-350px';
                toggle.querySelector('span').textContent = '📋';
            } else {
                panel.style.right = '0px';
                toggle.querySelector('span').textContent = '✕';
            }
        }

        // Make selected docs panel draggable
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        

        // Update selected documents display
        function updateSelectedDocsDisplay() {
            const selectedPanel = document.getElementById('selectedDocsPanel');
            const cardsContainer = document.getElementById('selectedDocsCards');
            const selectionCount = document.getElementById('selectionCount');
            const emptyMsg = document.getElementById('emptySelectionMsg');
            const toggle = document.getElementById('selectedDocsPanelToggle');
            
            if (selectedNodes.length > 0) {
                // Show floating panel
                selectedPanel.style.right = '0px';
                if (toggle) {
                    toggle.querySelector('span').textContent = '✕';
                    // Add notification animation to toggle button
                    toggle.style.background = '#e0e7ff';
                    setTimeout(() => {
                        toggle.style.background = 'white';
                    }, 1000);
                }
                
                // Update selection count
                if (selectionCount) {
                    selectionCount.textContent = selectedNodes.length;
                }
                
                // Hide empty message
                if (emptyMsg) {
                    emptyMsg.style.display = 'none';
                }
                
                // Update cards container
                cardsContainer.innerHTML = selectedNodes.map(nodeName => {
                    const nodeData = selectedNodesData[nodeName];
                    const nodeType = nodeData ? nodeData.type : 'file';
                    const icon = nodeType === 'folder' ? '📁' : '📄';
                    
                    return `
                        <div style="
                            display: flex; align-items: center; justify-content: space-between;
                            background: linear-gradient(135deg, #f8fafc, #ffffff); 
                            border: 1px solid #e2e8f0; border-radius: 12px; 
                            padding: 12px 16px; font-size: 14px; 
                            animation: bounceIn 0.5s ease;
                            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                            transition: all 0.3s ease;
                        ">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 16px;">${icon}</span>
                                <span style="color: #374151; font-weight: 500;">${nodeName}</span>
                            </div>
                            <button onclick="removeFromSelection('${nodeName}')" style="
                                background: none; border: none; color: #ef4444; 
                                cursor: pointer; font-size: 16px; padding: 4px; border-radius: 4px;
                                transition: background 0.2s ease;
                            " onmouseover="this.style.background='#fee2e2'" onmouseout="this.style.background='none'">✕</button>
                        </div>
                    `;
                }).join('');
                
                // Enable main analysis button in footer
                const mainAnalysisBtn = document.getElementById('mainInsightAnalysisBtn');
                if (mainAnalysisBtn) {
                    mainAnalysisBtn.disabled = false;
                    mainAnalysisBtn.style.opacity = '1';
                    mainAnalysisBtn.style.cursor = 'pointer';
                }
            } else {
                // Hide floating panel
                selectedPanel.style.right = '-350px';
                if (toggle) {
                    toggle.querySelector('span').textContent = '📋';
                    toggle.style.background = 'white';
                }
                
                // Reset count and show empty message
                if (selectionCount) {
                    selectionCount.textContent = '0';
                }
                if (emptyMsg) {
                    emptyMsg.style.display = 'block';
                }
                
                // Clear cards container
                cardsContainer.innerHTML = '';
                
                // Disable main analysis button in footer
                const mainAnalysisBtn = document.getElementById('mainInsightAnalysisBtn');
                if (mainAnalysisBtn) {
                    mainAnalysisBtn.disabled = true;
                    mainAnalysisBtn.style.opacity = '0.5';
                    mainAnalysisBtn.style.cursor = 'not-allowed';
                }
            }
        }

        // Remove document from selection
        window.removeFromSelection = function(nodeName) {
            selectedNodes = selectedNodes.filter(name => name !== nodeName);
            delete selectedNodesData[nodeName];
            
            // Remove visual selection from tree - find the select button and update it
            const allNodes = document.querySelectorAll('.node-content');
            allNodes.forEach(node => {
                const title = node.querySelector('.node-title').textContent;
                if (title === nodeName) {
                    const selectBtn = node.querySelector('.node-select-btn');
                    if (selectBtn) {
                        selectBtn.setAttribute('data-selected', 'false');
                    }
                }
            });
            
            updateSelectedDocsDisplay();
        }

        // Start insight analysis for selected nodes
        window.startInsightAnalysis = function() {
            console.log('🔍 startInsightAnalysis function called!');
            console.log('🔍 Selected nodes:', selectedNodes);
            console.log('🔍 Selected nodes count:', selectedNodes.length);
            
            if (selectedNodes.length === 0) {
                showNotification('⚠️ Please select documents to analyze');
                return;
            }
            
            console.log('🔍 Starting cross-document insight analysis for:', selectedNodes);
            
            // Test GraphRAG connection before starting
            testGraphRAGConnection().then(isConnected => {
                if (isConnected) {
                    showNotification('🔗 GraphRAG服务已连接，开始深度分析...');
                } else {
                    showNotification('⚠️ GraphRAG服务离线，将使用基础分析模式');
                }
                
                // Show loading modal for cross-document analysis
                showCrossDocumentAnalysisModal(isConnected);
                
                // Start analysis process
                setTimeout(() => {
                    performCrossDocumentAnalysis();
                }, 3000);
            });
        }

        // Test GraphRAG service connection
        async function testGraphRAGConnection() {
            try {
                const response = await fetch('http://127.0.0.1:8000/api/graphrag/health', {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });
                return response.ok;
            } catch (error) {
                console.log('GraphRAG连接测试失败:', error);
                return false;
            }
        }

        // Show cross-document analysis loading modal
        function showCrossDocumentAnalysisModal(isGraphRAGConnected = false) {
            const modal = document.createElement('div');
            modal.id = 'crossDocAnalysisModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.8); z-index: 6000; display: flex; 
                align-items: center; justify-content: center;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white; padding: 50px; border-radius: 20px; 
                    max-width: 600px; text-align: center; box-shadow: 0 25px 80px rgba(0,0,0,0.4);
                    position: relative;
                ">
                    <button onclick="document.getElementById('crossDocAnalysisModal').remove()" style="
                        position: absolute; top: 16px; right: 16px; 
                        background: #f3f4f6; border: none; width: 32px; height: 32px; 
                        border-radius: 50%; cursor: pointer; color: #6b7280; font-size: 18px;
                        display: flex; align-items: center; justify-content: center;
                        transition: all 0.2s ease;
                    " onmouseover="this.style.background='#e5e7eb'; this.style.color='#374151'" 
                       onmouseout="this.style.background='#f3f4f6'; this.style.color='#6b7280'">✕</button>
                    
                    <div style="margin-bottom: 30px;">
                        <div style="
                            width: 80px; height: 80px; border: 5px solid #e5e7eb; 
                            border-top: 5px solid #667eea; border-radius: 50%; 
                            animation: spin 1.2s linear infinite; margin: 0 auto 20px;
                        "></div>
                        <h2 style="margin: 0; color: #1f2937; font-size: 24px;">🔍 Deep Insight Analysis</h2>
                    </div>
                    
                    <div style="margin-bottom: 30px;">
                        <p style="color: #6b7280; margin: 0; font-size: 16px; line-height: 1.5;">
                            Analyzing <strong>${selectedNodes.length}</strong> documents<br>
                            Discovering internal relationships and hidden connections...
                        </p>
                    </div>
                    
                    <div style="
                        background: #f8fafc; border-radius: 12px; padding: 20px; 
                        text-align: left; font-size: 14px; color: #4b5563;
                    ">
                        <div id="analysisProgressSteps">
                            ✓ Loading selected documents (${selectedNodes.length} files)<br>
                            ⏳ Building unified knowledge graph...<br>
                            ⏳ Identifying cross-document entity relationships...<br>
                            ⏳ Discovering hidden patterns and trends...<br>
                            ⏳ Generating insight report...<br>
                        </div>
                    </div>
                    
                    <div style="margin-top: 20px; font-size: 12px; color: #9ca3af;">
                        ${isGraphRAGConnected ? 
                            '✅ Powered by Real GraphRAG Technology • Advanced Entity & Relationship Mining' : 
                            '⚠️ Using Fallback Analysis Mode • GraphRAG Service Unavailable'
                        }
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Progressive loading simulation
            setTimeout(() => updateAnalysisProgress(
                `✓ Loading selected documents (${selectedNodes.length} files)<br>✓ Building unified knowledge graph...<br>⏳ Identifying cross-document entity relationships...<br>⏳ Discovering hidden patterns and trends...<br>⏳ Generating insight report...<br>`
            ), 1000);
            
            setTimeout(() => updateAnalysisProgress(
                `✓ Loading selected documents (${selectedNodes.length} files)<br>✓ Building unified knowledge graph...<br>✓ Identifying cross-document entity relationships...<br>⏳ Discovering hidden patterns and trends...<br>⏳ Generating insight report...<br>`
            ), 2000);
            
            setTimeout(() => updateAnalysisProgress(
                `✓ Loading selected documents (${selectedNodes.length} files)<br>✓ Building unified knowledge graph...<br>✓ Identifying cross-document entity relationships...<br>✓ Discovering hidden patterns and trends...<br>⏳ Generating insight report...<br>`
            ), 2800);
        }

        function updateAnalysisProgress(html) {
            const progressElement = document.getElementById('analysisProgressSteps');
            if (progressElement) {
                progressElement.innerHTML = html;
            }
        }

        // Perform cross-document analysis
        async function performCrossDocumentAnalysis() {
            // Remove loading modal
            const loadingModal = document.getElementById('crossDocAnalysisModal');
            if (loadingModal) {
                document.body.removeChild(loadingModal);
            }
            
            try {
                // Generate cross-document analysis results (now async)
                const analysisResults = await generateCrossDocumentInsights();
                
                // Debug log
                console.log('Generated analysis results:', analysisResults);
                
                // Update workflow to Analysis step
                updateActiveStep('analysis');
                
                // Show comprehensive results
                showCrossDocumentResults(analysisResults);
                
                console.log('Called showCrossDocumentResults');
            } catch (error) {
                console.error('分析过程出错:', error);
                showNotification('❌ 分析过程中出现错误，请重试');
            }
        }

        // Generate cross-document insights using real GraphRAG API
        async function generateCrossDocumentInsights() {
            const documentTitles = selectedNodes.join(', ');
            const documentCount = selectedNodes.length;
            
            try {
                // 收集所有选中文档的内容
                const documentContents = await collectSelectedDocumentContents();
                
                // 调用真实的GraphRAG API
                const graphragResults = await callGraphRAGAPI(documentContents);
                
                // 处理API响应
                return processGraphRAGResults(graphragResults, documentCount, selectedNodes);
                
            } catch (error) {
                console.error('GraphRAG API调用失败:', error);
                // 降级到模拟数据
                return generateFallbackInsights(documentCount, selectedNodes);
            }
        }

        // 收集选中文档的实际内容
        async function collectSelectedDocumentContents() {
            const contents = [];
            
            for (const docTitle of selectedNodes) {
                try {
                    // 从localStorage或其他存储获取文档内容
                    const content = localStorage.getItem(`document_content_${docTitle}`) || 
                                  await fetchDocumentContent(docTitle);
                    
                    if (content) {
                        contents.push({
                            title: docTitle,
                            content: content,
                            type: 'text'
                        });
                    }
                } catch (error) {
                    console.warn(`无法获取文档内容: ${docTitle}`, error);
                }
            }
            
            return contents;
        }

        // 调用GraphRAG API
        async function callGraphRAGAPI(documentContents) {
            const combinedText = documentContents.map(doc => 
                `=== ${doc.title} ===\n${doc.content}`
            ).join('\n\n');

            console.log('调用GraphRAG API，文本长度:', combinedText.length);

            // 创建一个File对象来发送文本内容
            const textBlob = new Blob([combinedText], { type: 'text/plain' });
            const formData = new FormData();
            formData.append('file', textBlob, `combined_docs_${Date.now()}.txt`);

            const response = await fetch('http://127.0.0.1:8000/api/graphrag/analyze', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                throw new Error(`GraphRAG API错误: ${response.status}`);
            }

            return await response.json();
        }

        // 处理GraphRAG API结果
        function processGraphRAGResults(apiResponse, documentCount, selectedDocs) {
            console.log('🔍 处理GraphRAG API响应:', apiResponse);
            
            // 处理真实GraphRAG API响应格式
            const analysis = apiResponse.analysis || {};
            const entities = analysis.entities || [];
            const concepts = analysis.concepts || [];
            const relationships = analysis.relationships || [];
            
            // 生成更易读的概览
            const entityCount = entities.length || 0;
            const relationshipCount = relationships.length || 0;
            let overviewText;
            
            if (entityCount > 20 && relationshipCount > 50) {
                overviewText = `🎯 深度分析完成！在您的 ${documentCount} 份文档中，我们识别出 ${entityCount} 个关键概念实体和 ${relationshipCount} 种关系连接。这表明您的内容体系结构丰富，主题覆盖广泛，具有很好的知识深度。`;
            } else if (entityCount > 10 && relationshipCount > 20) {
                overviewText = `📊 分析结果展现了良好的内容结构。从 ${documentCount} 份文档中提取出 ${entityCount} 个核心概念和 ${relationshipCount} 个关联关系，显示您的内容在特定领域有较好的集中度和相关性。`;
            } else if (entityCount > 0) {
                overviewText = `🔍 初步分析完成。在 ${documentCount} 份文档中发现 ${entityCount} 个概念实体和 ${relationshipCount} 个关系连接。虽然规模不大，但为后续内容扩展提供了清晰的方向。`;
            } else {
                overviewText = `📋 分析了 ${documentCount} 份文档，但提取的实体和关系数量有限。建议增加更多内容丰富的文档，或检查文档内容的完整性。`;
            }
            
            return {
                summary: {
                    documentCount: documentCount,
                    documents: selectedDocs,
                    overview: overviewText,
                    keyConnections: [
                        `✅ 成功分析${documentCount}个文档`,
                        `🎯 提取${entityCount}个关键实体`,
                        `🤖 AI分析置信度: ${Math.round((analysis.confidence || 0.85) * 100)}%`,
                        `📊 内容分析: ${analysis.content ? '完成' : '待处理'}`
                    ],
                    isReal: true // 标记这是真实分析
                },
                hiddenPatterns: [
                    {
                        pattern: '实体分析',
                        description: `从文档中提取了${entityCount}个关键实体`,
                        strength: Math.min(entityCount / 20, 1.0),
                        documents: selectedDocs.slice(0, 2),
                        insight: `AI分析识别出${entityCount}个专业概念和实体`
                    }
                ],
                crossDocumentRelations: entities.map((entity, i) => ({
                    source: entity,
                    target: entities[(i + 1) % entities.length] || entity,
                    type: 'related',
                    strength: 0.7
                })).slice(0, 5),
                unseenOpportunities: [
                    {
                        opportunity: 'AI分析完成',
                        description: `成功分析${documentCount}个文档，提取${entityCount}个实体`,
                        impact: 'high',
                        confidence: analysis.confidence || 0.85,
                        actionable: '继续添加更多文档以扩展知识图谱'
                    }
                ],
                networkAnalysis: {
                    totalNodes: entityCount,
                    totalEdges: relationshipCount,
                    avgClustering: 0.5,
                    networkDensity: relationshipCount > 0 ? relationshipCount / (entityCount * (entityCount - 1) / 2) : 0,
                    centralNodes: entities.slice(0, 3),
                    communityCount: Math.ceil(entityCount / 5)
                },
                recommendations: [
                    '🎉 GraphRAG分析已完成',
                    '📈 实体提取成功',
                    '🔍 继续添加文档以扩展分析',
                    '📊 查看知识图谱可视化结果'
                ],
                // 为知识图谱生成数据
                entities: entities,
                concepts: concepts,
                relationships: relationships, // 添加关系数据
                graphData: {
                    nodes: entities.map((entity, i) => ({
                        id: entity,
                        name: entity,
                        type: 'entity',
                        group: 2
                    })).concat(concepts.map((concept, i) => ({
                        id: concept,
                        name: concept,
                        type: 'concept',
                        group: 1
                    }))),
                    links: relationships.map((rel, i) => ({
                        source: rel.source,
                        target: rel.target,
                        type: rel.type || 'related',
                        description: rel.description || '',
                        value: 0.8
                    }))
                }
            };
        }

        // 降级到模拟数据的函数
        function generateFallbackInsights(documentCount, selectedDocs) {
            console.warn('使用模拟数据作为GraphRAG降级方案');
            
            // 生成丰富的模拟实体和关系数据
            const mockEntities = [
                'GraphRAG系统', '知识图谱', 'RAG技术', 'LLM模型', '向量搜索',
                '实体提取', '关系识别', '数据分析', '内容理解', '智能问答',
                '文档处理', '语义分析', '信息检索', '深度学习', '自然语言处理'
            ];
            
            const mockRelations = [
                { source: 'GraphRAG系统', target: '知识图谱', type: 'uses', strength: 0.9 },
                { source: 'RAG技术', target: 'LLM模型', type: 'combines', strength: 0.8 },
                { source: '实体提取', target: '关系识别', type: 'enables', strength: 0.7 },
                { source: '文档处理', target: '语义分析', type: 'includes', strength: 0.6 },
                { source: '知识图谱', target: '智能问答', type: 'supports', strength: 0.8 }
            ];
            
            return {
                summary: {
                    documentCount: documentCount,
                    documents: selectedDocs,
                    overview: `⚠️ GraphRAG服务不可用，使用基础分析模式。发现 ${mockEntities.length} 个概念实体和 ${mockRelations.length} 个潜在关联。`,
                    keyConnections: [
                        '文档间存在主题重叠和概念关联',
                        '基于关键词分析发现内容相关性', 
                        '建议启用GraphRAG服务获得深度洞察',
                        '当前分析为简化版本，功能受限'
                    ],
                    isReal: false // 标记这是降级分析
                },
                hiddenPatterns: [
                    {
                        pattern: 'GraphRAG技术栈',
                        description: '涉及图数据库、向量搜索、语言模型等核心技术组件。',
                        strength: 0.8,
                        documents: selectedDocs.slice(0, 2),
                        insight: '技术文档显示了完整的RAG系统架构设计。'
                    },
                    {
                        pattern: '知识图谱构建',
                        description: '包含实体提取、关系识别、图谱存储等关键环节。',
                        strength: 0.7,
                        documents: selectedDocs.slice(1, 3),
                        insight: '展现了系统化的知识图谱构建流程。'
                    }
                ],
                crossDocumentRelations: mockRelations,
                mockEntities: mockEntities, // 添加实体数据
                unseenOpportunities: [
                    {
                        opportunity: '升级分析系统',
                        description: '启用GraphRAG服务以获得真正的实体关系分析和知识图谱构建',
                        impact: 'high',
                        confidence: 1.0,
                        actionable: '检查GraphRAG服务状态并重新配置API连接'
                    }
                ],
                networkAnalysis: {
                    totalNodes: mockEntities.length,
                    totalEdges: mockRelations.length,
                    avgClustering: 0.6,
                    networkDensity: mockRelations.length / (mockEntities.length * (mockEntities.length - 1) / 2),
                    centralNodes: ['GraphRAG系统', '知识图谱', 'RAG技术'],
                    communityCount: 3
                },
                recommendations: [
                    '🔧 检查并启动GraphRAG服务 (http://localhost:8000)',
                    '🔗 确保API连接正常工作',
                    '⚡ 重新运行分析以获得完整功能',
                    '📊 升级到真实的知识图谱分析'
                ]
            };
        }

        // 辅助函数：提取关键连接
        function extractKeyConnections(graphData, graphAnalysis) {
            if (!graphData || !graphData.links) return ['GraphRAG分析正在处理中...'];
            
            const connections = [];
            const strongLinks = graphData.links.filter(link => link.weight > 0.7);
            
            strongLinks.slice(0, 4).forEach(link => {
                const sourceNode = graphData.nodes.find(n => n.id === link.source);
                const targetNode = graphData.nodes.find(n => n.id === link.target);
                
                if (sourceNode && targetNode) {
                    connections.push(`强关联: ${sourceNode.name} ${link.type || '关联'} ${targetNode.name} (置信度: ${Math.round(link.weight * 100)}%)`);
                }
            });
            
            return connections.length > 0 ? connections : ['已识别实体间关系，正在深度分析中...'];
        }

        // 辅助函数：提取关键洞察（改进可读性）
        function extractHiddenPatterns(graphData, graphAnalysis) {
            const patterns = [];
            
            // 1. 语义社区分析（新的GraphRAG功能）
            if (graphAnalysis?.communities && graphAnalysis.communities.length > 0) {
                graphAnalysis.communities.forEach((community, index) => {
                    if (community.size >= 2 && community.semanticScore > 0.5) {
                        patterns.push({
                            pattern: `语义社区: ${community.theme}`,
                            description: `发现了一个语义一致性为 ${(community.semanticScore * 100).toFixed(1)}% 的专业概念集群，包含 ${community.size} 个高度相关实体。该社区围绕"${community.centralNode?.name || '核心概念'}"构建。`,
                            insight: `🎯 深度洞察：这个语义社区表明您在"${community.theme}"方面有系统性的知识积累。建议以"${community.centralNode?.name}"为核心，创建专题内容系列，充分发挥您在该领域的专业优势。`,
                            confidence: community.semanticScore,
                            actionable: `创建${community.theme}专题系列，深化核心概念"${community.centralNode?.name}"的内容价值`
                        });
                    }
                });
            }
            
            // 2. 概念推理路径分析（GraphRAG核心功能）
            if (graphAnalysis?.pathAnalysis && graphAnalysis.pathAnalysis.length > 0) {
                const topPaths = graphAnalysis.pathAnalysis.slice(0, 3);
                topPaths.forEach((pathData, index) => {
                    patterns.push({
                        pattern: `概念推理链: ${pathData.start} → ${pathData.end}`,
                        description: `GraphRAG分析发现了一条置信度为 ${(pathData.confidence * 100).toFixed(1)}% 的概念推理路径：${pathData.path.join(' → ')}。${pathData.insight}`,
                        insight: `🔗 推理洞察：这条路径揭示了您内容中的隐性逻辑连接。通过这种概念链式思考，可以创建更具说服力和逻辑性的内容框架。`,
                        confidence: pathData.confidence,
                        actionable: `基于此推理路径创建逻辑性内容，引导读者从"${pathData.start}"理解到"${pathData.end}"`
                    });
                });
            }
            
            // 3. 知识缺口发现（GraphRAG独特功能）
            if (graphAnalysis?.knowledgeGaps && graphAnalysis.knowledgeGaps.length > 0) {
                const criticalGaps = graphAnalysis.knowledgeGaps.filter(gap => gap.priority === 'high').slice(0, 2);
                criticalGaps.forEach((gap, index) => {
                    patterns.push({
                        pattern: `知识缺口: ${gap.concept || gap.concept1}`,
                        description: gap.description,
                        insight: `⚡ 机会洞察：${gap.suggestion}。这种知识缺口往往是内容创作的黄金机会，填补这些空白可以显著提升您内容体系的完整性。`,
                        confidence: 0.8,
                        actionable: gap.suggestion
                    });
                });
            }
            
            // 4. 传统集群分析（向后兼容）
            if (graphAnalysis?.clusters && graphAnalysis.clusters.length > 0) {
                graphAnalysis.clusters.forEach((cluster, index) => {
                    if (cluster.length > 2) {
                        const clusterName = cluster[0]?.name || '概念集群';
                        const clusterSize = cluster.length;
                        
                        // 根据集群大小生成更有意义的描述
                        let description, insight;
                        
                        if (clusterSize >= 10) {
                            description = `这是一个包含 ${clusterSize} 个概念的大型主题集群，表明该领域在您的文档中有丰富的内容覆盖。`;
                            insight = `💡 建议：这个主题集群可以作为您内容策略的核心支柱，值得深入挖掘和系统化整理。可以考虑制作专题系列内容。`;
                        } else if (clusterSize >= 5) {
                            description = `发现了一个中等规模的概念集群，包含 ${clusterSize} 个相关概念，显示出良好的主题连贯性。`;
                            insight = `💡 建议：这个主题有足够的内容深度，可以考虑创建专门的内容分类或标签，便于读者系统性学习。`;
                        } else {
                            description = `识别出一个紧密的小型概念集群，包含 ${clusterSize} 个高度相关的概念。`;
                            insight = `💡 建议：这些概念联系紧密，可以在单篇文章中综合讨论，或作为其他内容的补充说明。`;
                        }
                        
                        patterns.push({
                            pattern: `${clusterName.includes('集群') ? clusterName : clusterName + '主题集群'}`,
                            description: description,
                            strength: Math.min(0.95, 0.6 + clusterSize * 0.05),
                            documents: cluster.slice(0, 3).map(node => node.name || '相关文档'),
                            insight: insight
                        });
                    }
                });
            }
            
            // 如果没有找到聚类，生成基于连接度的模式
            if (patterns.length === 0 && graphData?.nodes) {
                const highDegreeNodes = graphData.nodes
                    .map(node => ({
                        ...node,
                        degree: graphData.links.filter(link => 
                            link.source === node.id || link.target === node.id
                        ).length
                    }))
                    .filter(node => node.degree > 2)
                    .sort((a, b) => b.degree - a.degree);

                if (highDegreeNodes.length > 0) {
                    patterns.push({
                        pattern: '核心概念枢纽效应',
                        description: `发现 "${highDegreeNodes[0].name}" 作为核心概念，连接了 ${highDegreeNodes[0].degree} 个相关实体。`,
                        strength: Math.min(0.9, 0.5 + highDegreeNodes[0].degree * 0.1),
                        documents: ['跨文档分析'],
                        insight: '核心概念可作为内容架构的中心节点，指导相关内容的组织和扩展。'
                    });
                }
            }
            
            return patterns.length > 0 ? patterns : [
                {
                    pattern: '基础文档关联',
                    description: '通过GraphRAG分析发现了文档间的基础语义关联。',
                    strength: 0.6,
                    documents: ['分析文档'],
                    insight: '建议增加更多相关文档以发现更深层的关系模式。'
                }
            ];
        }

        // 辅助函数：提取跨文档关系
        function extractCrossDocumentRelations(graphData) {
            if (!graphData || !graphData.links) return [];
            
            return graphData.links.slice(0, 5).map(link => {
                const sourceNode = graphData.nodes?.find(n => n.id === link.source);
                const targetNode = graphData.nodes?.find(n => n.id === link.target);
                
                return {
                    source: sourceNode?.name || 'Unknown Entity',
                    target: targetNode?.name || 'Unknown Entity',
                    relation: link.type || 'related_to',
                    strength: link.weight || 0.5,
                    description: `通过GraphRAG分析发现的${link.type || '关联'}关系`
                };
            });
        }

        // 辅助函数：生成机会点（增强GraphRAG功能）
        function generateOpportunities(graphAnalysis) {
            const opportunities = [];
            
            // 1. 基于语义社区的机会
            if (graphAnalysis?.communities && graphAnalysis.communities.length > 0) {
                const topCommunity = graphAnalysis.communities[0];
                opportunities.push({
                    opportunity: `语义社区深化: ${topCommunity.theme}`,
                    description: `最高质量的语义社区（一致性: ${(topCommunity.semanticScore * 100).toFixed(1)}%）可作为内容策略的重点突破口。该社区围绕"${topCommunity.centralNode?.name}"构建，具有${topCommunity.size}个相关实体。`,
                    impact: 'high',
                    confidence: topCommunity.semanticScore,
                    actionable: `以"${topCommunity.centralNode?.name}"为核心，创建${topCommunity.theme}专题内容系列，充分挖掘该领域的内容价值`
                });
            }
            
            // 2. 基于知识缺口的机会
            if (graphAnalysis?.knowledgeGaps && graphAnalysis.knowledgeGaps.length > 0) {
                const highPriorityGaps = graphAnalysis.knowledgeGaps.filter(gap => gap.priority === 'high');
                if (highPriorityGaps.length > 0) {
                    const topGap = highPriorityGaps[0];
                    opportunities.push({
                        opportunity: `知识缺口填补: ${topGap.concept || topGap.concept1}`,
                        description: `GraphRAG分析发现高优先级知识缺口：${topGap.description}。这种缺口往往是内容创作的黄金机会。`,
                        impact: 'high',
                        confidence: 0.9,
                        actionable: topGap.suggestion
                    });
                }
            }
            
            // 3. 基于概念路径的机会
            if (graphAnalysis?.pathAnalysis && graphAnalysis.pathAnalysis.length > 0) {
                const bestPath = graphAnalysis.pathAnalysis[0];
                opportunities.push({
                    opportunity: `概念推理链利用: ${bestPath.start} ⇒ ${bestPath.end}`,
                    description: `发现了高置信度（${(bestPath.confidence * 100).toFixed(1)}%）的概念推理路径。这种逻辑连接可以用于创建更具说服力的内容框架。`,
                    impact: 'medium',
                    confidence: bestPath.confidence,
                    actionable: `基于此推理路径创建逻辑性内容，引导读者从"${bestPath.start}"理解到"${bestPath.end}"`
                });
            }
            
            // 4. 基于中心性分析的机会（传统功能）
            if (graphAnalysis?.centrality?.topNodes) {
                const topNode = graphAnalysis.centrality.topNodes[0];
                if (topNode) {
                    opportunities.push({
                        opportunity: `核心概念驱动: ${topNode[1].name}`,
                        description: `"${topNode[1].name}"在您的知识网络中具有最高的中心性（度数: ${topNode[1].degree}），可作为内容扩展的核心支点。`,
                        impact: 'high',
                        confidence: 0.8,
                        actionable: `围绕"${topNode[1].name}"构建内容矩阵，形成主题聚类效应`
                    });
                }
            }
            
            // 5. 基于网络密度的机会
            if (graphAnalysis?.insights) {
                const sparseInsight = graphAnalysis.insights.find(i => i.type === 'sparse_connections');
                if (sparseInsight) {
                    opportunities.push({
                        opportunity: '知识网络密化',
                        description: sparseInsight.description + '。这意味着存在大量的连接机会。',
                        impact: 'medium',
                        confidence: 0.7,
                        actionable: sparseInsight.actionable
                    });
                }
            }
            
            return opportunities.length > 0 ? opportunities : [
                {
                    opportunity: '基础GraphRAG分析',
                    description: '当前分析为基础结果，可通过增加更多相关文档来激活更多高级GraphRAG功能',
                    impact: 'medium',
                    confidence: 0.6,
                    actionable: '收集更多相关文档，使系统能够识别更复杂的语义社区、推理路径和知识缺口'
                }
            ];
        }

        // 辅助函数：计算网络密度
        function calculateNetworkDensity(graphData) {
            if (!graphData || !graphData.nodes || !graphData.links) return 0;
            
            const nodeCount = graphData.nodes.length;
            const linkCount = graphData.links.length;
            const maxPossibleLinks = nodeCount * (nodeCount - 1) / 2;
            
            return maxPossibleLinks > 0 ? linkCount / maxPossibleLinks : 0;
        }

        // 辅助函数：提取中心节点
        function extractCentralNodes(graphAnalysis) {
            if (graphAnalysis?.centrality?.topNodes) {
                return graphAnalysis.centrality.topNodes
                    .slice(0, 5)
                    .map(([nodeId, nodeData]) => nodeData.name);
            }
            return [];
        }

        // 辅助函数：生成可操作的推荐建议
        function generateRecommendations(graphAnalysis, insightCard) {
            const recommendations = [];
            
            // 基于图谱核心节点的建议
            if (graphAnalysis?.centrality?.topNodes?.length > 0) {
                const topNode = graphAnalysis.centrality.topNodes[0][1];
                const nodeName = topNode.name;
                const degree = topNode.degree || 0;
                
                recommendations.push(
                    `🎯 深化核心主题：${nodeName}是您内容体系的关键枢纽，与${degree}个概念相关联。建议围绕此主题创建系列内容或专题`
                );
            }
            
            // 基于集群分析的建议
            if (graphAnalysis?.clusters?.length > 0) {
                const clusterCount = graphAnalysis.clusters.length;
                const avgClusterSize = Math.round(
                    graphAnalysis.clusters.reduce((sum, cluster) => sum + cluster.length, 0) / clusterCount
                );
                
                if (clusterCount >= 3) {
                    recommendations.push(
                        `📚 内容分类优化：发现${clusterCount}个主题集群，每个集群平均包含${avgClusterSize}个概念。建议为每个集群创建专门的内容分类`
                    );
                } else {
                    recommendations.push(
                        `🔗 主题关联加强：目前只有${clusterCount}个主题集群，建议增加不同主题间的关联内容，提高内容体系的连贯性`
                    );
                }
            }
            
            // 基于网络密度的建议
            const networkStats = calculateNetworkDensity({ 
                nodes: graphAnalysis?.nodes || [], 
                links: graphAnalysis?.links || [] 
            });
            
            if (networkStats && !isNaN(networkStats) && networkStats > 0.6) {
                recommendations.push(
                    `💎 内容体系成熟：您的知识网络密度很高(${Math.round(networkStats * 100)}%)，适合开发高级内容如案例研究、深度分析等`
                );
            } else if (networkStats && !isNaN(networkStats) && networkStats < 0.3) {
                recommendations.push(
                    `🌱 填补知识空白：网络密度较低(${Math.round(networkStats * 100)}%)，建议识别缺失的连接点，创建桥接内容`
                );
            }
            
            // 基于AI洞察卡片的建议
            if (insightCard?.viralPrediction) {
                const { targetAudience, bestChannel, viralScore } = insightCard.viralPrediction;
                
                if (targetAudience) {
                    recommendations.push(
                        `👥 精准定位受众：内容最适合${targetAudience}群体，建议深入研究该群体的具体需求和痛点`
                    );
                }
                
                if (bestChannel) {
                    recommendations.push(
                        `📱 优化发布策略：${bestChannel}是最佳发布渠道，建议根据平台特点调整内容格式和发布时机`
                    );
                }
                
                if (viralScore && !isNaN(viralScore) && viralScore >= 7) {
                    recommendations.push(
                        `🚀 传播潜力较高：内容传播评分${viralScore}/10，建议投入更多推广资源，制作配套的传播素材`
                    );
                } else if (viralScore && !isNaN(viralScore) && viralScore < 5) {
                    recommendations.push(
                        `⚡ 提升传播力：传播评分${viralScore}/10，建议优化标题吸引力、增加视觉元素、强化情感共鸣点`
                    );
                }
            }
            
            // 基于内容优化建议
            if (insightCard?.optimizationSuggestions?.length > 0) {
                const topSuggestion = insightCard.optimizationSuggestions[0];
                recommendations.push(`💡 内容优化重点：${topSuggestion}`);
            }
            
            // 确保至少有基础建议
            if (recommendations.length < 3) {
                recommendations.push(
                    '📈 持续扩展：定期添加新文档到知识库，让GraphRAG分析结果更加准确和全面',
                    '🔍 深度挖掘：关注图谱中连接较少的节点，这些往往是新内容创作的机会点',
                    '🎯 策略迭代：基于分析结果调整内容策略，每月重新运行分析追踪改进效果'
                );
            }
            
            return recommendations.slice(0, 5); // 限制为最多5个建议
        }

        // 辅助函数：安全格式化百分比，防止NaN显示
        function safePercent(value, defaultValue = 0) {
            const num = Number(value);
            return isNaN(num) ? defaultValue : Math.round(num * 100);
        }

        // 辅助函数：获取文档内容
        async function fetchDocumentContent(docTitle) {
            // 这里可以添加从服务器获取文档内容的逻辑
            // 目前返回示例内容
            return `${docTitle} 的示例内容用于GraphRAG分析...`;
        }

        // Show cross-document analysis results
        function showCrossDocumentResults(results) {
            console.log('showCrossDocumentResults called with:', results);
            console.log('Creating results panel...');
            
            // Close knowledge panel and return to main page
            const knowledgePanel = document.getElementById('knowledgePanel');
            const overlay = document.getElementById('panelOverlay');
            if (knowledgePanel) knowledgePanel.classList.remove('open');
            if (overlay) overlay.classList.remove('show');
            
            // Add blinking animation to analysis step
            const analysisStep = document.querySelector('[data-step="analysis"]');
            if (analysisStep) {
                analysisStep.style.animation = 'pulse 1.5s ease-in-out infinite';
            }
            
            // Create comprehensive results panel
            const resultsPanel = document.createElement('div');
            resultsPanel.id = 'crossDocumentResultsPanel';
            resultsPanel.style.cssText = `
                position: fixed; top: 0; right: 0; width: 100vw; height: 100vh; 
                background: white; z-index: 5000; overflow-y: auto;
                animation: slideInFromRight 0.6s ease-out;
            `;
            
            resultsPanel.innerHTML = `
                <div style="min-height: 100vh;">
                    <!-- Compact Header -->
                    <div style="
                        background: linear-gradient(135deg, #2d1b69, #11047a); 
                        color: white; padding: 20px 30px; position: relative;
                    ">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <h1 style="margin: 0; font-size: 24px; font-weight: 700;">
                                    🔍 Cross-Document Insight Analysis
                                </h1>
                                <p style="margin: 8px 0 0; opacity: 0.85; font-size: 14px;">
                                    Deep Analysis of ${results.summary.documentCount} Documents • ${results.summary.isReal ? 'Real GraphRAG' : 'Basic Analysis'}
                                </p>
                            </div>
                            <button onclick="closeCrossDocumentResults()" style="
                                background: rgba(255,255,255,0.2); color: white; border: none;
                                width: 40px; height: 40px; border-radius: 50%; cursor: pointer; font-size: 18px;
                                transition: all 0.2s ease;
                            " onmouseover="this.style.background='rgba(255,255,255,0.3)'"
                               onmouseout="this.style.background='rgba(255,255,255,0.2)'">✕</button>
                        </div>
                    </div>
                    
                    <!-- Content Section -->
                    <div style="padding: 50px;">
                        <!-- Analysis Status Indicator -->
                        <div style="margin-bottom: 30px;">
                            ${results.summary.isReal ? 
                                `<div style="
                                    background: linear-gradient(135deg, #10b981, #059669); 
                                    color: white; padding: 16px 24px; border-radius: 12px; 
                                    display: flex; align-items: center; gap: 12px; font-weight: 600;
                                ">
                                    <span style="font-size: 20px;">✅</span>
                                    <div>
                                        <div style="font-size: 16px;">Real GraphRAG Analysis Active</div>
                                        <div style="font-size: 13px; opacity: 0.9;">Using advanced entity extraction and relationship mapping</div>
                                    </div>
                                </div>` : 
                                `<div style="
                                    background: linear-gradient(135deg, #f59e0b, #d97706); 
                                    color: white; padding: 16px 24px; border-radius: 12px; 
                                    display: flex; align-items: center; gap: 12px; font-weight: 600;
                                ">
                                    <span style="font-size: 20px;">⚠️</span>
                                    <div>
                                        <div style="font-size: 16px;">Fallback Mode - GraphRAG Service Unavailable</div>
                                        <div style="font-size: 13px; opacity: 0.9;">Using basic analysis due to API connection issues</div>
                                    </div>
                                </div>`
                            }
                        </div>

                        <!-- Executive Summary -->
                        <section style="margin-bottom: 40px;">
                            <h2 style="color: #1a202c; margin-bottom: 20px; font-size: 24px; font-weight: 700;">
                                📊 Analysis Overview
                            </h2>
                            <div style="
                                background: linear-gradient(135deg, #667eea, #764ba2); 
                                color: white; padding: 32px; border-radius: 16px; margin-bottom: 24px;
                            ">
                                <p style="margin: 0; font-size: 18px; line-height: 1.6;">
                                    ${results.summary.overview}
                                </p>
                            </div>
                            
                            <!-- Key Connections -->
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 16px;">
                                ${results.summary.keyConnections.map(connection => `
                                    <div style="
                                        background: #f8fafc; border-left: 5px solid #667eea; 
                                        padding: 20px; border-radius: 0 12px 12px 0;
                                    ">
                                        <div style="color: #2d3748; font-size: 15px; line-height: 1.5;">
                                            🔗 ${connection}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </section>

                        <!-- Network Stats -->
                        <section style="margin-bottom: 40px;">
                            <h2 style="color: #1a202c; margin-bottom: 20px; font-size: 24px; font-weight: 700;">
                                🕸️ Network Analysis
                            </h2>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                                <div style="background: #667eea; color: white; padding: 24px; border-radius: 12px; text-align: center;">
                                    <div style="font-size: 32px; font-weight: bold; margin-bottom: 8px;">${results.networkAnalysis.totalNodes}</div>
                                    <div style="font-size: 14px; opacity: 0.9;">Entity Nodes</div>
                                </div>
                                <div style="background: #764ba2; color: white; padding: 24px; border-radius: 12px; text-align: center;">
                                    <div style="font-size: 32px; font-weight: bold; margin-bottom: 8px;">${results.networkAnalysis.totalEdges}</div>
                                    <div style="font-size: 14px; opacity: 0.9;">Relationships</div>
                                </div>
                                <div style="background: #f093fb; color: white; padding: 24px; border-radius: 12px; text-align: center;">
                                    <div style="font-size: 32px; font-weight: bold; margin-bottom: 8px;">${results.networkAnalysis.communityCount}</div>
                                    <div style="font-size: 14px; opacity: 0.9;">Communities</div>
                                </div>
                                <div style="background: #4facfe; color: white; padding: 24px; border-radius: 12px; text-align: center;">
                                    <div style="font-size: 32px; font-weight: bold; margin-bottom: 8px;">${Math.round((results.networkAnalysis.networkDensity || 0) * 100)}%</div>
                                    <div style="font-size: 14px; opacity: 0.9;">Network Density</div>
                                </div>
                            </div>
                        </section>

                        <!-- Knowledge Graph Visualization -->
                        <section style="margin-bottom: 40px;">
                            <h2 style="color: #1a202c; margin-bottom: 20px; font-size: 24px; font-weight: 700;">
                                🧠 Interactive Knowledge Graph
                            </h2>
                            <div style="
                                background: #f8fafc; border: 2px solid #e2e8f0; 
                                border-radius: 16px; padding: 24px; min-height: 500px; position: relative;
                            ">
                                <div id="knowledgeGraphContainer" style="width: 100%; height: 450px; position: relative;">
                                    <!-- D3.js Knowledge Graph will be rendered here -->
                                </div>
                                <div style="
                                    position: absolute; bottom: 16px; right: 16px; 
                                    background: rgba(255,255,255,0.9); padding: 12px; border-radius: 8px;
                                    font-size: 12px; color: #6b7280; display: flex; align-items: center; gap: 16px;
                                ">
                                    <div><span style="display: inline-block; width: 12px; height: 12px; background: #667eea; border-radius: 50%; margin-right: 6px;"></span>Documents</div>
                                    <div><span style="display: inline-block; width: 12px; height: 12px; background: #f093fb; border-radius: 50%; margin-right: 6px;"></span>Concepts</div>
                                    <div><span style="display: inline-block; width: 12px; height: 12px; background: #4facfe; border-radius: 50%; margin-right: 6px;"></span>Relationships</div>
                                </div>
                            </div>
                        </section>

                        <!-- Hidden Patterns Discovery -->
                        <section style="margin-bottom: 40px;">
                            <h2 style="color: #1a202c; margin-bottom: 20px; font-size: 24px; font-weight: 700;">
                                🔮 Hidden Patterns Discovery
                            </h2>
                            ${results.hiddenPatterns.map(pattern => `
                                <div style="
                                    background: white; border: 2px solid #e2e8f0; 
                                    padding: 28px; border-radius: 16px; margin-bottom: 20px;
                                    box-shadow: 0 4px 12px rgba(0,0,0,0.05);
                                ">
                                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 16px;">
                                        <h3 style="margin: 0; color: #2d3748; font-size: 18px; font-weight: 600;">
                                            🧩 ${pattern.pattern}
                                        </h3>
                                        <span style="
                                            background: #667eea; color: white; padding: 6px 16px; 
                                            border-radius: 20px; font-size: 12px; font-weight: 600; margin-left: auto;
                                        ">
                                            Strength: ${Math.round((pattern.strength || 0) * 100)}%
                                        </span>
                                    </div>
                                    <p style="color: #4a5568; line-height: 1.7; margin-bottom: 16px; font-size: 15px;">
                                        ${pattern.description}
                                    </p>
                                    <div style="
                                        background: #e8f4fd; border-left: 4px solid #3b82f6; 
                                        padding: 16px 20px; border-radius: 0 8px 8px 0; margin-bottom: 12px;
                                    ">
                                        <strong style="color: #1d4ed8;">💡 Key Insight:</strong>
                                        <span style="color: #1e40af; margin-left: 8px;">
                                            ${pattern.insight}
                                        </span>
                                    </div>
                                    <div style="font-size: 13px; color: #6b7280;">
                                        <strong>Confidence:</strong> ${pattern.confidence && !isNaN(pattern.confidence) ? (pattern.confidence * 100).toFixed(1) + '%' : 'N/A'}
                                        ${pattern.actionable ? ` | <strong>Action:</strong> ${pattern.actionable}` : ''}
                                    </div>
                                </div>
                            `).join('')}
                        </section>

                        <!-- Strategic Recommendations -->
                        <section style="margin-bottom: 40px;">
                            <h2 style="color: #1a202c; margin-bottom: 20px; font-size: 24px; font-weight: 700;">
                                🎯 Strategic Recommendations
                            </h2>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 20px;">
                                ${results.recommendations.map((rec, index) => `
                                    <div style="
                                        background: linear-gradient(135deg, #667eea, #764ba2); 
                                        color: white; padding: 24px; border-radius: 16px;
                                        position: relative; overflow: hidden;
                                    ">
                                        <div style="
                                            position: absolute; top: 16px; right: 16px;
                                            width: 32px; height: 32px; background: rgba(255,255,255,0.2);
                                            border-radius: 50%; display: flex; align-items: center; 
                                            justify-content: center; font-weight: bold; font-size: 14px;
                                        ">
                                            ${index + 1}
                                        </div>
                                        <div style="font-size: 16px; line-height: 1.6; padding-right: 40px;">
                                            ${rec}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </section>
                    </div>
                    
                    <!-- Action Buttons -->
                    <section style="text-align: center; padding: 40px;">
                        <button onclick="proceedToResearch()" style="
                            background: linear-gradient(135deg, #2d1b69, #11047a); 
                            color: white; border: none; padding: 16px 32px; 
                            border-radius: 12px; font-size: 16px; font-weight: 700; 
                            cursor: pointer; margin-right: 16px; 
                            box-shadow: 0 8px 25px rgba(45, 27, 105, 0.3);
                        ">
                            🚀 Proceed to Research Phase
                        </button>
                        <button onclick="saveInsightResults()" style="
                            background: white; color: #2d1b69; border: 2px solid #2d1b69; 
                            padding: 16px 32px; border-radius: 12px; font-size: 16px; 
                            font-weight: 700; cursor: pointer; margin-right: 16px;
                        ">
                            💾 Save Results
                        </button>
                        <button onclick="exportDetailedReport()" style="
                            background: #f59e0b; color: white; border: none; 
                            padding: 16px 32px; border-radius: 12px; font-size: 16px; 
                            font-weight: 700; cursor: pointer;
                        ">
                            📊 Export Report
                        </button>
                    </section>
                </div>
            `;
            
            console.log('Appending results panel to body...');
            document.body.appendChild(resultsPanel);
            console.log('Results panel appended successfully!');
            
            // Initialize knowledge graph after panel is added
            setTimeout(() => {
                console.log('Attempting to render knowledge graph...');
                renderKnowledgeGraph(results);
            }, 500);
        }

        // Render knowledge graph using D3.js
        function renderKnowledgeGraph(results) {
            console.log('renderKnowledgeGraph called with results:', results);
            
            // Check if D3.js is loaded
            if (typeof d3 === 'undefined') {
                console.error('D3.js is not loaded! Adding fallback...');
                // Create a simple fallback visualization
                renderFallbackGraph(results);
                return;
            }
            
            const container = document.getElementById('knowledgeGraphContainer');
            console.log('Container found:', container);
            if (!container) {
                console.error('knowledgeGraphContainer not found!');
                return;
            }

            // Clear previous content
            d3.select('#knowledgeGraphContainer').selectAll('*').remove();
            console.log('Cleared previous content');

            const width = container.offsetWidth;
            const height = container.offsetHeight;

            // Create SVG
            const svg = d3.select('#knowledgeGraphContainer')
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            // Generate graph data based on analysis results
            const graphData = generateGraphData(results);

            // Create force simulation
            const simulation = d3.forceSimulation(graphData.nodes)
                .force('link', d3.forceLink(graphData.links).id(d => d.id).distance(80))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(25));

            // Create links
            const link = svg.append('g')
                .attr('stroke', '#999')
                .attr('stroke-opacity', 0.6)
                .selectAll('line')
                .data(graphData.links)
                .enter().append('line')
                .attr('stroke-width', d => Math.sqrt(d.value) * 2);

            // Create nodes
            const node = svg.append('g')
                .attr('stroke', '#fff')
                .attr('stroke-width', 1.5)
                .selectAll('circle')
                .data(graphData.nodes)
                .enter().append('circle')
                .attr('r', d => d.type === 'document' ? 12 : 8)
                .attr('fill', d => {
                    if (d.type === 'document') return '#667eea';
                    if (d.type === 'concept') return '#f093fb';
                    return '#4facfe';
                })
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            // Add labels
            const label = svg.append('g')
                .selectAll('text')
                .data(graphData.nodes)
                .enter().append('text')
                .attr('text-anchor', 'middle')
                .attr('dy', '.35em')
                .attr('font-size', '10px')
                .attr('fill', '#333')
                .text(d => {
                    const displayText = d.name || d.id;
                    return displayText.length > 12 ? displayText.substring(0, 12) + '...' : displayText;
                });

            // Update positions on tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y - 18);
            });

            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }

            // Add zoom behavior
            svg.call(d3.zoom()
                .extent([[0, 0], [width, height]])
                .scaleExtent([0.3, 3])
                .on('zoom', (event) => {
                    svg.selectAll('g').attr('transform', event.transform);
                }));
        }

        // Generate graph data from analysis results
        function generateGraphData(results) {
            console.log('🔍 generateGraphData called with results:', results);
            
            // 如果有真实的GraphRAG数据，直接使用
            if (results.graphData && results.graphData.nodes && results.graphData.links) {
                console.log('✅ 使用真实GraphRAG数据生成图谱');
                return {
                    nodes: results.graphData.nodes.map(node => ({
                        id: node.id,
                        name: node.name,
                        type: node.type || 'entity',
                        category: node.category || 'general',
                        group: getGroupByType(node.type || 'entity'),
                        weight: node.weight || 1
                    })),
                    links: results.graphData.links.map(link => ({
                        source: link.source,
                        target: link.target,
                        type: link.type || 'related',
                        value: link.weight || 0.5,
                        label: link.type || 'related'
                    }))
                };
            }
            
            // 降级到基于分析结果的模拟图谱
            console.log('🔄 使用模拟数据生成图谱');
            const nodes = [];
            const links = [];
            
            // Add document nodes
            if (results.summary && results.summary.documents) {
                results.summary.documents.forEach((doc, index) => {
                    nodes.push({
                        id: `doc_${index}`,
                        name: doc.length > 50 ? doc.substring(0, 50) + '...' : doc,
                        type: 'document',
                        group: 1,
                        fullName: doc
                    });
                });
            }
            
            // Add entity nodes from mockEntities if available
            if (results.mockEntities) {
                results.mockEntities.forEach((entity, index) => {
                    nodes.push({
                        id: `entity_${index}`,
                        name: entity,
                        type: 'entity',
                        group: 2,
                        fullName: entity
                    });
                });
            }
            
            // Add concept nodes from hidden patterns
            if (results.hiddenPatterns) {
                results.hiddenPatterns.forEach((pattern, index) => {
                    const conceptId = `concept_${index}`;
                    nodes.push({
                        id: conceptId,
                        name: pattern.pattern,
                        type: 'concept',
                        group: 3,
                        fullName: pattern.pattern
                    });
                    
                    // Link concepts to related documents
                    if (pattern.documents) {
                        pattern.documents.forEach((doc, docIndex) => {
                            links.push({
                                source: `doc_${docIndex}`,
                                target: conceptId,
                                value: pattern.strength || 0.5,
                                type: 'contains',
                                label: 'contains'
                            });
                        });
                    }
                });
            }
            
            // Add cross-document relations
            if (results.crossDocumentRelations) {
                results.crossDocumentRelations.forEach((relation, index) => {
                    // Find or create source and target nodes
                    let sourceNode = nodes.find(n => n.name === relation.source || n.fullName === relation.source);
                    let targetNode = nodes.find(n => n.name === relation.target || n.fullName === relation.target);
                    
                    if (!sourceNode) {
                        sourceNode = {
                            id: `rel_source_${index}`,
                            name: relation.source,
                            type: 'entity',
                            group: 4,
                            fullName: relation.source
                        };
                        nodes.push(sourceNode);
                    }
                    
                    if (!targetNode) {
                        targetNode = {
                            id: `rel_target_${index}`,
                            name: relation.target,
                            type: 'entity',
                            group: 4,
                            fullName: relation.target
                        };
                        nodes.push(targetNode);
                    }
                    
                    links.push({
                        source: sourceNode.id,
                        target: targetNode.id,
                        value: relation.strength || 0.7,
                        type: relation.type || 'related',
                        label: relation.type || 'related'
                    });
                });
            }
            
            console.log(`📊 Generated graph data: ${nodes.length} nodes, ${links.length} links`);
            
            return {
                nodes: nodes,
                links: links
            };
        }

        // 根据实体类型分配组别（用于颜色分组）
        function getGroupByType(type) {
            const typeGroups = {
                'document': 1,
                'concept': 2,
                'entity': 3,
                'person': 4,
                'organization': 5,
                'product': 6
            };
            return typeGroups[type] || 3;
        }

        // Fallback graph rendering if D3.js fails to load
        function renderFallbackGraph(results) {
            console.log('Rendering fallback graph...');
            const container = document.getElementById('knowledgeGraphContainer');
            if (!container) return;
            
            container.innerHTML = `
                <div style="
                    display: flex; flex-direction: column; align-items: center; 
                    justify-content: center; height: 100%; text-align: center; padding: 20px;
                ">
                    <div style="
                        display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); 
                        gap: 20px; width: 100%; max-width: 600px;
                    ">
                        ${results.summary.documents.map((doc, index) => `
                            <div style="
                                background: #667eea; color: white; padding: 12px; 
                                border-radius: 8px; font-size: 12px; text-align: center;
                                animation: bounceIn 0.5s ease ${index * 0.1}s both;
                            ">
                                📄 ${doc.length > 15 ? doc.substring(0, 15) + '...' : doc}
                            </div>
                        `).join('')}
                        
                        ${results.hiddenPatterns.map((pattern, index) => `
                            <div style="
                                background: #f093fb; color: white; padding: 12px; 
                                border-radius: 8px; font-size: 12px; text-align: center;
                                animation: bounceIn 0.5s ease ${(results.summary.documents.length + index) * 0.1}s both;
                            ">
                                🧩 ${pattern.pattern.length > 15 ? pattern.pattern.substring(0, 15) + '...' : pattern.pattern}
                            </div>
                        `).join('')}
                    </div>
                    
                    <div style="margin-top: 20px; color: #6b7280; font-size: 14px;">
                        Knowledge Graph: ${results.networkAnalysis.totalNodes} nodes, ${results.networkAnalysis.totalEdges} relationships
                    </div>
                </div>
            `;
        }

        // Support functions for cross-document results
        window.closeCrossDocumentResults = function() {
            const panel = document.getElementById('crossDocumentResultsPanel');
            if (panel) {
                panel.style.animation = 'slideOutToRight 0.4s ease-in forwards';
                setTimeout(() => {
                    document.body.removeChild(panel);
                }, 400);
            }
            
            // Stop analysis step blinking animation
            const analysisStep = document.querySelector('[data-step="analysis"]');
            if (analysisStep) {
                analysisStep.style.animation = '';
            }
        }

        window.proceedToResearch = function() {
            updateActiveStep('research');
            closeCrossDocumentResults();
            showNotification('🔍 Proceeding to Market Research Phase');
        }

        window.saveInsightResults = function() {
            // Save results to knowledge base
            const timestamp = new Date().toLocaleString();
            const resultTitle = `Cross-Document_Insight_Analysis_${selectedNodes.length}docs_${timestamp}`;
            
            showNotification('💾 Insight analysis results saved to knowledge base');
        }

        window.exportDetailedReport = function() {
            showNotification('📊 Detailed report export feature in development...');
        }

        // Add new folder
        function addNewFolder() {
            const folderName = prompt('Enter folder name:');
            if (!folderName) return;
            
            const newFolder = createTreeNode(folderName, 'folder', true);
            const tree = document.getElementById('knowledgeTree');
            tree.appendChild(newFolder);
            
            // Ensure event handlers are properly attached
            updateEventHandlers(newFolder);
            
            showNotification(`Folder "${folderName}" added! 📁`);
        }

        // Add new item 
        function addNewItem() {
            const itemName = prompt('Enter item name:');
            if (!itemName) return;
            
            let parentNode = document.getElementById('knowledgeTree');
            
            // If a folder is selected, add to that folder
            if (selectedNode) {
                const selectedTreeNode = selectedNode.closest('.tree-node');
                const isFolder = selectedTreeNode.querySelector('.node-icon.folder');
                if (isFolder) {
                    let childrenContainer = selectedTreeNode.querySelector('.node-children');
                    if (!childrenContainer) {
                        childrenContainer = document.createElement('div');
                        childrenContainer.className = 'node-children expanded';
                        selectedTreeNode.appendChild(childrenContainer);
                        // Update expand icon
                        const expandIcon = selectedTreeNode.querySelector('.node-expand');
                        expandIcon.innerHTML = '▼';
                        expandIcon.setAttribute('onclick', 'toggleNode(event, this)');
                    }
                    parentNode = childrenContainer;
                    childrenContainer.classList.add('expanded');
                }
            }
            
            const newItem = createTreeNode(itemName, 'file', false);
            parentNode.appendChild(newItem);
            
            // Ensure event handlers are properly attached
            updateEventHandlers(newItem);
            
            showNotification(`Item "${itemName}" added! 📄`);
        }

        // Create tree node element
        function createTreeNode(name, type, hasChildren) {
            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'tree-node';
            
            const isFolder = type === 'folder';
            const icon = isFolder ? '📁' : '📄';
            const iconClass = isFolder ? 'folder' : 'file';
            const expandHtml = hasChildren ? '<div class="node-expand" onclick="toggleNode(event, this)">▶</div>' : '<div class="node-expand"></div>';
            
            // All nodes get selection buttons, folders also get + button
            const actionsHtml = isFolder ? 
                `<div class="node-actions">
                    <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                    <button class="node-action" onclick="editNode(event, this)">✏️</button>
                    <button class="node-select-btn" onclick="toggleSelection(event, this)" data-selected="false">✓</button>
                    <button class="node-action" onclick="deleteNode(event, this)">🗑️</button>
                </div>` :
                `<div class="node-actions">
                    <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                    <button class="node-action" onclick="editNode(event, this)">✏️</button>
                    <button class="node-select-btn" onclick="toggleSelection(event, this)" data-selected="false">✓</button>
                    <button class="node-action" onclick="deleteNode(event, this)">🗑️</button>
                </div>`;
            
            const onclickHandler = isFolder ? 'selectNode(this)' : 'showNodeContent(event, this)';
            
            nodeDiv.innerHTML = `
                <div class="node-content" onclick="${onclickHandler}" draggable="true" 
                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                    <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                    <div class="node-icon ${iconClass}">${icon}</div>
                    <div class="node-title" ondblclick="editNodeTitle(event, this)">${name}</div>
                    <div class="node-actions">
                        <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                        <button class="node-action" onclick="editNode(event, this)">✏️</button>
                        <button class="node-action" onclick="deleteNode(event, this)">🗑️</button>
                    </div>
                </div>
                <div class="node-children"></div>
            `;
            
            // 确保事件处理器正确绑定
            updateEventHandlers(nodeDiv);
            
            return nodeDiv;
        }

        // Show node content when clicking on file nodes
        window.showNodeContent = function(event, nodeContent) {
            console.log('🎯 showNodeContent called - 显示内容到右侧预览区');
            
            // Don't trigger if clicking on action buttons
            if (event.target.classList.contains('node-action') || 
                event.target.closest('.node-actions')) {
                console.log('Click was on action button, returning');
                return;
            }
            
            event.stopPropagation();
            const title = nodeContent.querySelector('.node-title').textContent;
            console.log('📖 显示文件内容到预览区:', title);
            
            // 获取预览区域元素
            const contentPreview = document.getElementById('contentPreview');
            const closePreviewBtn = document.getElementById('closePreview');
            
            if (!contentPreview) {
                console.error('未找到内容预览区域');
                return;
            }
            
            // 获取文件内容
            const nodeElement = nodeContent.closest('.tree-node');
            let displayContent = '';
            let fileAnalysis = null;
            
            // 🔥 优先从DOM元素的data属性获取内容
            if (nodeElement && nodeElement.hasAttribute('data-file-content')) {
                displayContent = nodeElement.getAttribute('data-file-content');
                console.log('✅ Found content from DOM element, length:', displayContent.length);
            }
            
            if (!displayContent) {
                // 🔥 从文件存储中获取textContent
                const storageKey = nodeElement?.getAttribute('data-file-storage-key');
                if (storageKey) {
                    try {
                        const fileDataStr = localStorage.getItem(storageKey);
                        if (fileDataStr) {
                            const fileData = JSON.parse(fileDataStr);
                            if (fileData.textContent) {
                                displayContent = fileData.textContent;
                                console.log('✅ Found textContent from file storage:', displayContent.length, '字符');
                            }
                        }
                    } catch (error) {
                        console.log('⚠️ 无法从文件存储获取内容:', error);
                    }
                }
            }
            
            if (!displayContent) {
                // 备用：从localStorage知识库中获取
                displayContent = getContentFromKnowledgeBase(title);
                console.log('📋 Content from knowledge base:', displayContent ? 'Found' : 'Not found');
            }
            
            if (!displayContent) {
                // 备用：从内存存储中获取
                displayContent = nodeContentStore[title];
                console.log('📋 Content from memory store:', displayContent ? 'Found' : 'Not found');
            }
            
            // 🧠 检查是否有GraphRAG分析数据
            const analysisDB = JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}');
            console.log('🔍 查找GraphRAG数据，文件名:', title);
            
            const sortedKeys = Object.keys(analysisDB).sort((a, b) => {
                const timestampA = a.split('_').pop() || '0';
                const timestampB = b.split('_').pop() || '0';
                return parseInt(timestampB) - parseInt(timestampA);
            });
            
            for (const key of sortedKeys) {
                if (key.startsWith(title + '_') || key === title) {
                    fileAnalysis = analysisDB[key];
                    console.log('✅ 找到GraphRAG分析数据:', key);
                    break;
                }
            }
            
            if (!displayContent) {
                // 最后才使用占位符内容
                console.log('📋 Using placeholder content for:', title);
                displayContent = getSampleContent(title);
            } else {
                console.log('📋 Found real content, length:', displayContent.length);
                // Convert plain text to HTML for display
                displayContent = displayContent.replace(/\n/g, '<br>').replace(/•/g, '&bull;');
            }
            
            // 显示关闭按钮
            closePreviewBtn.style.display = 'block';
            
            // 根据是否有GraphRAG分析数据决定显示内容
            if (fileAnalysis && fileAnalysis.extractedContent) {
                console.log('🎨 显示GraphRAG分析界面');
                contentPreview.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <h2 style="margin: 0 0 16px 0; color: #1f2937; display: flex; align-items: center; gap: 12px; font-size: 20px;">
                            📄 ${title}
                        </h2>
                    </div>
                    
                    <!-- AI分析摘要 -->
                    <div style="
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                        color: white; padding: 20px; border-radius: 12px; margin-bottom: 20px;
                        max-height: 250px; overflow-y: auto;
                    ">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 16px;">
                            <div style="
                                background: rgba(255,255,255,0.2); width: 32px; height: 32px; 
                                border-radius: 50%; display: flex; align-items: center; justify-content: center;
                                font-size: 16px;
                            ">🧠</div>
                            <h3 style="margin: 0; font-size: 16px; font-weight: 600;">AI深度分析摘要</h3>
                        </div>
                        
                        <div style="background: rgba(255,255,255,0.1); border-radius: 10px; padding: 18px; margin-bottom: 15px;">
                            <h4 style="color: white; margin: 0 0 10px 0; font-size: 16px;">📊 Core Insights:</h4>
                            <div style="color: rgba(255,255,255,0.9); font-size: 14px; line-height: 1.7;">
                                ${fileAnalysis.extractedContent}
                            </div>
                        </div>
                        
                        <div style="background: rgba(255,255,255,0.1); border-radius: 10px; padding: 18px;">
                            <h4 style="color: white; margin: 0 0 15px 0; font-size: 16px;">🧠 GraphRAG智能分析结果：</h4>
                            <div style="color: rgba(255,255,255,0.9); font-size: 14px; line-height: 1.6;">
                                <div style="margin-bottom: 12px;">
                                    <strong style="color: white;">🏷️ 识别的概念：</strong><br>
                                    ${fileAnalysis.concepts?.join(' • ') || 'No concept information available'}
                                </div>
                                <div style="margin-bottom: 12px;">
                                    <strong style="color: white;">👥 识别的实体：</strong><br>
                                    ${fileAnalysis.entities?.join(' • ') || 'No entity information available'}
                                </div>
                                <div style="margin-bottom: 12px;">
                                    <strong style="color: white;">📍 建议分类路径：</strong><br>
                                    ${fileAnalysis.positionSuggestion?.primarySuggestion?.path || 'No path suggestion available'}
                                </div>
                                <div>
                                    <strong style="color: white;">🎯 分析置信度：</strong><br>
                                    ${Math.round((fileAnalysis.confidence || 0) * 100)}%
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 文档结构与内容 -->
                    <div style="display: grid; grid-template-columns: 350px 1fr; gap: 16px; height: 400px;">
                        <!-- 左侧文档结构 -->
                        <div style="
                            background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 16px; 
                            overflow: hidden; display: flex; flex-direction: column;
                        ">
                            <div style="
                                background: #e2e8f0; padding: 16px 20px; 
                                border-bottom: 1px solid #d1d5db;
                            ">
                                <h4 style="margin: 0; color: #1f2937; font-size: 16px; font-weight: 600;">📋 Document Outline</h4>
                            </div>
                            <div style="flex: 1; padding: 16px; overflow-y: auto; max-height: 350px;">
                                <div style="margin-bottom: 16px;">
                                    <div style="
                                        background: #e0f2fe; color: #0c4a6e; padding: 12px; 
                                        border-radius: 8px; font-size: 13px; text-align: center;
                                    ">
                                        📊 AI分析内容 • ${fileAnalysis.extractedContent.split(' ').length} 词
                                    </div>
                                </div>
                                <div onclick="showSectionInPreview('full', '${title}')" style="
                                    padding: 12px; margin-bottom: 8px; border-radius: 8px; 
                                    background: white; border: 1px solid #e2e8f0; cursor: pointer;
                                    transition: all 0.2s ease;
                                " onmouseover="this.style.backgroundColor='#f0f9ff'; this.style.borderColor='#3b82f6'" 
                                   onmouseout="this.style.backgroundColor='white'; this.style.borderColor='#e2e8f0'">
                                    <div style="
                                        display: flex; justify-content: space-between; align-items: flex-start; 
                                        margin-bottom: 6px;
                                    ">
                                        <span style="
                                            font-weight: 600; color: #1f2937; font-size: 13px;
                                        ">Full Analysis Content</span>
                                        <span style="
                                            font-size: 11px; color: #6b7280;
                                        ">${fileAnalysis.extractedContent.length} characters</span>
                                    </div>
                                    <div style="
                                        color: #4b5563; font-size: 12px; line-height: 1.4;
                                    ">${fileAnalysis.extractedContent.substring(0, 60)}...</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- 右侧内容预览 -->
                        <div style="
                            background: white; border: 1px solid #e2e8f0; border-radius: 16px;
                            overflow: hidden; display: flex; flex-direction: column;
                        ">
                            <div style="
                                background: #f8fafc; padding: 16px 20px; 
                                border-bottom: 1px solid #e2e8f0;
                            ">
                                <h4 style="margin: 0; color: #1f2937; font-size: 16px; font-weight: 600;">👁️ Content Preview</h4>
                            </div>
                            <div id="documentPreviewContent_${title}" style="
                                flex: 1; padding: 20px; overflow-y: auto; max-height: 350px;
                                line-height: 1.8; color: #374151; font-size: 16px;
                            ">
                                <div style="text-align: center; padding: 40px 20px; color: #9ca3af;">
                                    <div style="font-size: 48px; margin-bottom: 16px;">📖</div>
                                    <h3 style="margin: 0 0 12px 0; color: #6b7280;">点击左侧查看内容</h3>
                                    <p style="margin: 0; font-size: 14px;">
                                        点击左侧"完整分析内容"查看AI深度分析
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                console.log('📋 显示简单文本内容');
                contentPreview.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <h2 style="margin: 0 0 16px 0; color: #1f2937; display: flex; align-items: center; gap: 12px; font-size: 20px;">
                            📄 ${title}
                        </h2>
                    </div>
                    <div style="
                        background: white; border-radius: 12px; padding: 24px; 
                        line-height: 1.6; font-size: 15px; color: #374151; border: 1px solid #e5e7eb;
                    ">
                        ${displayContent}
                    </div>
                    <div style="margin-top: 20px; display: flex; gap: 12px;">
                        <button onclick="editNodeFromPreview('${title}')" style="
                            padding: 10px 20px; border: 2px solid #8b5cf6; 
                            background: white; color: #8b5cf6; border-radius: 8px; cursor: pointer; font-weight: 500;
                        ">✏️ Edit Content</button>
                    </div>
                `;
            }
        }

        // Clear content preview
        window.clearContentPreview = function() {
            const contentPreview = document.getElementById('contentPreview');
            const closePreviewBtn = document.getElementById('closePreview');
            
            if (contentPreview) {
                contentPreview.innerHTML = `
                    <div class="empty-preview" style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: #6b7280; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 16px;">📄</div>
                        <h3 style="margin: 0 0 8px 0; font-size: 18px; color: #374151;">Select a document to preview</h3>
                        <p style="margin: 0; font-size: 14px;">Click on any document in the knowledge tree to view its content here</p>
                    </div>
                `;
            }
            
            if (closePreviewBtn) {
                closePreviewBtn.style.display = 'none';
            }
        }

        // Edit node from preview area
        window.editNodeFromPreview = function(title) {
            // Find the node with this title and trigger edit
            const allNodes = document.querySelectorAll('.node-title');
            for (const nodeTitle of allNodes) {
                if (nodeTitle.textContent === title) {
                    const nodeContent = nodeTitle.closest('.node-content');
                    if (nodeContent) {
                        window.editNode(new Event('click'), nodeContent);
                        break;
                    }
                }
            }
        }

        // Show section content in preview (for GraphRAG analysis)
        window.showSectionInPreview = function(sectionType, title) {
            const previewContent = document.getElementById(`documentPreviewContent_${title}`);
            if (!previewContent) return;
            
            // Get the analysis data
            const analysisDB = JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}');
            let fileAnalysis = null;
            
            const sortedKeys = Object.keys(analysisDB).sort((a, b) => {
                const timestampA = a.split('_').pop() || '0';
                const timestampB = b.split('_').pop() || '0';
                return parseInt(timestampB) - parseInt(timestampA);
            });
            
            for (const key of sortedKeys) {
                if (key.startsWith(title + '_') || key === title) {
                    fileAnalysis = analysisDB[key];
                    break;
                }
            }
            
            if (fileAnalysis && sectionType === 'full') {
                previewContent.innerHTML = `
                    <div style="line-height: 1.8; color: #374151; font-size: 15px;">
                        ${fileAnalysis.extractedContent.replace(/\n/g, '<br>')}
                    </div>
                `;
            }
        }

        // Get sample content for different knowledge items
        function getSampleContent(title) {
            const contentMap = {
                '澳洲市场用户画像分析': `
                    <h3>🎯 目标用户画像</h3>
                    <p><strong>主要用户群体：</strong></p>
                    <ul>
                        <li><strong>科技创业者</strong> - 25-40岁，集中在悉尼、墨尔本</li>
                        <li><strong>数字营销经理</strong> - 30-45岁，中大型企业</li>
                        <li><strong>内容创作者</strong> - 20-35岁，自媒体和KOL</li>
                    </ul>
                    
                    <h3>📊 市场特征</h3>
                    <p><strong>消费行为：</strong></p>
                    <ul>
                        <li>高度重视产品质量和用户体验</li>
                        <li>偏好本土化服务和本地案例</li>
                        <li>LinkedIn和email营销效果最佳</li>
                        <li>平均决策周期：B2B 3-6个月，B2C 1-2周</li>
                    </ul>

                    <h3>💡 关键洞察</h3>
                    <p>澳洲用户对AI工具持开放态度，但更注重实际ROI和合规性。建议重点突出效率提升和成本节约。</p>
                `,
                '悉尼科技圈竞品分析': `
                    <h3>🏢 主要竞争对手</h3>
                    <p><strong>直接竞争者：</strong></p>
                    <ul>
                        <li><strong>Canva</strong> - 设计工具，悉尼本土独角兽</li>
                        <li><strong>Atlassian</strong> - 协作工具，强大的本地影响力</li>
                        <li><strong>Campaign Monitor</strong> - 邮件营销，澳洲老牌</li>
                    </ul>
                    
                    <h3>📈 市场机会</h3>
                    <p><strong>差异化优势：</strong></p>
                    <ul>
                        <li>AI驱动的智能内容生成</li>
                        <li>多平台整合营销自动化</li>
                        <li>本地化的客户支持服务</li>
                        <li>符合GDPR和澳洲隐私法规</li>
                    </ul>

                    <h3>💰 定价策略建议</h3>
                    <p>建议采用订阅制，起步价$49/月，对标Canva Pro。提供14天免费试用期。</p>
                `,
                'AI营销策略案例库': `
                    <h3>🎯 成功案例集</h3>
                    
                    <h4>案例1: 悉尼咖啡连锁店</h4>
                    <p><strong>策略：</strong>使用AI生成本地化社交媒体内容</p>
                    <p><strong>结果：</strong>Instagram参与度提升340%，新客户增长180%</p>
                    
                    <h4>案例2: 墨尔本SaaS公司</h4>
                    <p><strong>策略：</strong>AI驱动的LinkedIn内容营销</p>
                    <p><strong>结果：</strong>潜在客户增长250%，转化率提升45%</p>
                    
                    <h4>案例3: 布里斯班电商平台</h4>
                    <p><strong>策略：</strong>个性化邮件营销自动化</p>
                    <p><strong>结果：</strong>邮件打开率60%，点击率提升120%</p>

                    <h3>📝 最佳实践</h3>
                    <ul>
                        <li>结合本地文化元素和流行语</li>
                        <li>重点突出ROI和效率提升</li>
                        <li>使用客户成功故事建立信任</li>
                    </ul>
                `,
                '爆款文案写作模板': `
                    <h3>📝 AIDA爆款公式</h3>
                    <p><strong>A - Attention (吸引注意)</strong></p>
                    <ul>
                        <li>"悉尼创业者都在用的AI神器"</li>
                        <li>"5分钟生成一周社媒内容"</li>
                        <li>"让你的营销效果提升3倍的秘密"</li>
                    </ul>
                    
                    <p><strong>I - Interest (激发兴趣)</strong></p>
                    <ul>
                        <li>具体数据：节省80%时间</li>
                        <li>同行案例：XX公司月增长200%</li>
                        <li>独特优势：澳洲本土化AI模型</li>
                    </ul>

                    <p><strong>D - Desire (创造渴望)</strong></p>
                    <ul>
                        <li>想象成功场景："想象每天只需30分钟就能完成所有营销工作"</li>
                        <li>恐惧错失："竞争对手已经开始使用，你还在等什么？"</li>
                    </ul>

                    <p><strong>A - Action (行动召唤)</strong></p>
                    <ul>
                        <li>"立即开始14天免费试用"</li>
                        <li>"加入3000+澳洲企业的成功行列"</li>
                    </ul>
                `,
                'AI写作提示词库': `
                    <h3>🤖 高效提示词模板</h3>
                    
                    <h4>📱 社交媒体内容</h4>
                    <p><code>为[行业]公司写一条LinkedIn帖子，介绍[产品/服务]，目标受众是[澳洲/悉尼][具体人群]，语调要[专业/轻松]，包含相关话题标签。</code></p>
                    
                    <h4>📧 邮件营销</h4>
                    <p><code>写一封[欢迎/推广/续费]邮件，发送给[目标客户]，突出[核心价值]，包含明确的行动召唤，符合澳洲邮件营销最佳实践。</code></p>
                    
                    <h4>📝 博客文章</h4>
                    <p><code>写一篇关于[话题]的博客文章，针对澳洲[目标受众]，包含SEO关键词，文章结构清晰，提供实用价值。</code></p>

                    <h3>💡 优化技巧</h3>
                    <ul>
                        <li>具体化：用具体行业、地区、数据</li>
                        <li>本土化：加入澳洲文化元素</li>
                        <li>角色设定：明确AI扮演的角色</li>
                        <li>格式要求：指定输出格式和长度</li>
                    </ul>
                `
            };

            // 为其他没有具体内容的节点提供通用模板
            if (contentMap[title]) {
                return contentMap[title];
            } else {
                return `
                    <h3>📄 ${title}</h3>
                    <p>这里是<strong>${title}</strong>的详细内容。</p>
                    <p>您可以点击下方的"✏️ Edit Content"按钮来编辑和添加您自己的内容。</p>
                    
                    <div style="background: #eff6ff; border-left: 4px solid #3b82f6; padding: 16px; margin: 16px 0;">
                        <p><strong>💡 提示：</strong>这是一个内容占位符。您可以在这里添加：</p>
                        <ul>
                            <li>相关的研究资料和数据</li>
                            <li>最佳实践和案例研究</li>
                            <li>模板和工具链接</li>
                            <li>行动清单和检查列表</li>
                        </ul>
                    </div>
                `;
            }
        }

        // Drag and Drop functionality
        let draggedElement = null;

        function handleDragStart(event) {
            draggedElement = event.target.closest('.tree-node');
            const nodeContent = event.target.closest('.node-content');
            nodeContent.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/html', draggedElement.outerHTML);
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            
            const dropTarget = event.target.closest('.node-content');
            if (dropTarget && dropTarget !== draggedElement?.querySelector('.node-content')) {
                // Remove previous drag-over styles
                document.querySelectorAll('.node-content.drag-over').forEach(node => {
                    node.classList.remove('drag-over');
                });
                
                // Add drag-over style to current target
                dropTarget.classList.add('drag-over');
            }
        }

        function handleDrop(event) {
            event.preventDefault();
            
            const dropTarget = event.target.closest('.node-content');
            if (!dropTarget || !draggedElement) return;
            
            const targetTreeNode = dropTarget.closest('.tree-node');
            const targetIsFolder = targetTreeNode.querySelector('.node-icon.folder');
            
            if (targetIsFolder && targetTreeNode !== draggedElement) {
                // Drop into folder
                let childrenContainer = targetTreeNode.querySelector('.node-children');
                if (!childrenContainer) {
                    childrenContainer = document.createElement('div');
                    childrenContainer.className = 'node-children expanded';
                    targetTreeNode.appendChild(childrenContainer);
                    
                    // Update expand icon
                    const expandIcon = targetTreeNode.querySelector('.node-expand');
                    expandIcon.innerHTML = '▼';
                    expandIcon.setAttribute('onclick', 'toggleNode(event, this)');
                }
                
                childrenContainer.classList.add('expanded');
                
                // Clone the dragged element and update its event handlers
                const clonedElement = draggedElement.cloneNode(true);
                updateEventHandlers(clonedElement);
                
                childrenContainer.appendChild(clonedElement);
                draggedElement.remove();
                
                showNotification('Item moved successfully! 📦');
            }
            
            // Clean up
            cleanupDragStyles();
        }

        function handleDragEnd(event) {
            cleanupDragStyles();
            draggedElement = null;
        }

        function cleanupDragStyles() {
            // Remove all drag-related styles
            document.querySelectorAll('.node-content').forEach(node => {
                node.classList.remove('dragging', 'drag-over');
            });
        }

        // Edit node title (double-click)
        function editNodeTitle(event, titleElement) {
            event.stopPropagation();
            const currentTitle = titleElement.textContent;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentTitle;
            input.style.width = '100%';
            input.style.border = '1px solid #8b5cf6';
            input.style.borderRadius = '4px';
            input.style.padding = '2px 6px';
            input.style.fontSize = '14px';
            
            titleElement.innerHTML = '';
            titleElement.appendChild(input);
            input.focus();
            input.select();
            
            function saveTitle() {
                const newTitle = input.value.trim();
                if (newTitle && newTitle !== currentTitle) {
                    titleElement.textContent = newTitle;
                    showNotification(`Renamed to "${newTitle}" ✏️`);
                } else {
                    titleElement.textContent = currentTitle;
                }
            }
            
            input.addEventListener('blur', saveTitle);
            input.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    input.blur();
                }
                if (e.key === 'Escape') {
                    titleElement.textContent = currentTitle;
                }
            });
        }

        // Add child item to any node (folder or file) - make global
        window.addChildItem = function(event, buttonElement) {
            event.stopPropagation();
            const itemName = prompt('Enter item name:');
            if (!itemName) return;
            
            const treeNode = buttonElement.closest('.tree-node');
            let childrenContainer = treeNode.querySelector('.node-children');
            
            if (!childrenContainer) {
                childrenContainer = document.createElement('div');
                childrenContainer.className = 'node-children expanded';
                treeNode.appendChild(childrenContainer);
            }
            
            childrenContainer.classList.add('expanded');
            
            // Update expand icon (create one if it doesn't exist)
            let expandIcon = treeNode.querySelector('.node-expand');
            if (!expandIcon.innerHTML || expandIcon.innerHTML === '') {
                expandIcon.innerHTML = '▼';
                expandIcon.setAttribute('onclick', 'toggleNode(event, this)');
            } else if (expandIcon.innerHTML === '▶') {
                expandIcon.innerHTML = '▼';
            }
            
            const newItem = createTreeNode(itemName, 'file', false);
            childrenContainer.appendChild(newItem);
            
            // Ensure event handlers are properly attached
            updateEventHandlers(newItem);
            
            const parentName = treeNode.querySelector('.node-title').textContent;
            showNotification(`Item "${itemName}" added to "${parentName}"! 📄`);
        }

        // Update event handlers for dynamically created elements
        function updateEventHandlers(element) {
            const nodeContent = element.querySelector('.node-content');
            if (nodeContent) {
                // Check if it's a file or folder to set correct onclick handler
                const nodeIcon = nodeContent.querySelector('.node-icon');
                const isFolder = nodeIcon && nodeIcon.classList.contains('folder');
                
                // Check if it's an uploaded file (has storage key attributes)
                const parentNode = nodeContent.closest('.tree-node');
                const hasStorageKey = parentNode && parentNode.hasAttribute('data-file-storage-key');
                
                // Update main node onclick
                if (isFolder) {
                    nodeContent.setAttribute('onclick', 'selectNode(this)');
                } else if (hasStorageKey) {
                    // Don't override uploaded files - they should keep openFileWithLocalTool
                    // Only update if it doesn't already have the correct handler
                    const currentOnclick = nodeContent.getAttribute('onclick');
                    if (!currentOnclick || !currentOnclick.includes('openFileWithLocalTool')) {
                        nodeContent.setAttribute('onclick', 'openFileWithLocalTool(event, this)');
                    }
                } else {
                    nodeContent.setAttribute('onclick', 'showNodeContent(event, this)');
                }
                
                nodeContent.setAttribute('draggable', 'true');
                nodeContent.setAttribute('ondragstart', 'handleDragStart(event)');
                nodeContent.setAttribute('ondragover', 'handleDragOver(event)');
                nodeContent.setAttribute('ondrop', 'handleDrop(event)');
                nodeContent.setAttribute('ondragend', 'handleDragEnd(event)');
                
                // Update title double-click
                const nodeTitle = nodeContent.querySelector('.node-title');
                if (nodeTitle) {
                    nodeTitle.setAttribute('ondblclick', 'editNodeTitle(event, this)');
                }
                
                // Update expand button
                const expandBtn = nodeContent.querySelector('.node-expand');
                if (expandBtn && (expandBtn.innerHTML === '▶' || expandBtn.innerHTML === '▼')) {
                    expandBtn.setAttribute('onclick', 'toggleNode(event, this)');
                }
                
                // Update action buttons
                const actionButtons = nodeContent.querySelectorAll('.node-action');
                actionButtons.forEach(button => {
                    const buttonText = button.textContent || button.innerHTML;
                    if (buttonText.includes('➕')) {
                        button.setAttribute('onclick', 'addChildItem(event, this)');
                    } else if (buttonText.includes('✏️')) {
                        button.setAttribute('onclick', 'editNode(event, this)');
                    } else if (buttonText.includes('🗑️')) {
                        button.setAttribute('onclick', 'deleteNode(event, this)');
                    }
                });
            }
            
            // Recursively update child nodes
            const childNodes = element.querySelectorAll('.tree-node');
            childNodes.forEach(child => {
                if (child !== element) { // Avoid infinite recursion
                    updateEventHandlers(child);
                }
            });
        }

        // Edit node (content) - make it global for easier access
        // Simple content storage
        const nodeContentStore = {};

        // Selected nodes for analysis
        let selectedNodes = [];
        let selectedNodesData = {};

        // Toggle document selection
        window.toggleSelection = function(event, button) {
            event.stopPropagation();
            
            const nodeContent = button.closest('.node-content');
            const title = nodeContent.querySelector('.node-title').textContent;
            const isSelected = button.getAttribute('data-selected') === 'true';
            
            if (isSelected) {
                // Deselect
                button.setAttribute('data-selected', 'false');
                selectedNodes = selectedNodes.filter(node => node !== title);
                delete selectedNodesData[title];
            } else {
                // Select
                button.setAttribute('data-selected', 'true');
                selectedNodes.push(title);
                selectedNodesData[title] = {
                    content: nodeContentStore[title] || getSampleContent(title) || '',
                    type: nodeContent.querySelector('.node-icon').classList.contains('folder') ? 'folder' : 'file',
                    element: nodeContent
                };
            }
            
            // Update selected docs display
            updateSelectedDocsDisplay();
        }

        window.editNode = function(event, buttonElement) {
            event.stopPropagation();
            console.log('editNode called!', event, buttonElement);
            const nodeContent = buttonElement.closest('.node-content');
            const title = nodeContent.querySelector('.node-title').textContent;
            
            // Get existing content or sample content
            let existingContent = nodeContentStore[title];
            if (!existingContent) {
                // Try to get from sample content and convert HTML to plain text
                const sampleContent = getSampleContent(title);
                if (sampleContent) {
                    // Convert HTML to plain text for editing
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = sampleContent;
                    existingContent = tempDiv.textContent || tempDiv.innerText || '';
                } else {
                    existingContent = `请在此编辑 "${title}" 的内容...

您可以添加：
• 详细描述
• 相关链接
• 操作步骤
• 重要注意事项`;
                }
            }
            
            // Create a simple content editor modal
            const modal = document.createElement('div');
            modal.className = 'edit-modal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.6); z-index: 5000; display: flex; 
                align-items: center; justify-content: center;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white; padding: 24px; border-radius: 12px; 
                width: 500px; max-width: 90vw; max-height: 70vh; overflow-y: auto;
                box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            `;
            
            modalContent.innerHTML = `
                <h3 style="margin: 0 0 16px 0; color: #1f2937;">✏️ Edit Content: ${title}</h3>
                <textarea id="nodeContentEditor" style="
                    width: 100%; height: 250px; border: 2px solid #e5e7eb; 
                    border-radius: 8px; padding: 12px; font-size: 14px; 
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                    resize: vertical; outline: none;
                " placeholder="Enter your content here...">${existingContent}</textarea>
                <div style="margin-top: 20px; text-align: right;">
                    <button id="cancelBtn" style="
                        margin-right: 12px; padding: 10px 20px; border: 2px solid #e5e7eb; 
                        background: white; border-radius: 6px; cursor: pointer; font-weight: 500;
                    ">Cancel</button>
                    <button id="saveBtn" style="
                        padding: 10px 20px; background: linear-gradient(135deg, #8b5cf6, #6366f1); 
                        color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;
                    ">💾 Save Content</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Add event listeners
            const cancelBtn = modalContent.querySelector('#cancelBtn');
            const saveBtn = modalContent.querySelector('#saveBtn');
            const textarea = modalContent.querySelector('#nodeContentEditor');
            
            cancelBtn.addEventListener('click', () => {
                document.body.removeChild(modal);
            });
            
            saveBtn.addEventListener('click', () => {
                const content = textarea.value;
                // Store the content
                nodeContentStore[title] = content;
                console.log(`Saved content for "${title}":`, content);
                
                // Update the display content as well
                updateNodeDisplayContent(title, content);
                
                showNotification(`Content saved for "${title}" ✅`);
                document.body.removeChild(modal);
            });
            
            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
            
            // Focus on textarea
            setTimeout(() => textarea.focus(), 100);
        }
        
        // Update node display content after editing
        function updateNodeDisplayContent(title, content) {
            // This will be used by showNodeContent to display updated content
            // The content is already stored in nodeContentStore
        }

        // GraphRAG Analysis Function
        window.analyzeWithGraphRAG = function(event, buttonElement) {
            event.stopPropagation();
            console.log('GraphRAG Analysis triggered!', event, buttonElement);
            
            const nodeContent = buttonElement.closest('.node-content');
            const title = nodeContent.querySelector('.node-title').textContent;
            
            // Get content for analysis
            let analysisContent = nodeContentStore[title] || getSampleContent(title) || '暂无内容可分析';
            
            // Show loading modal
            showAnalysisLoadingModal(title);
            
            // Simulate GraphRAG analysis process
            setTimeout(() => {
                performGraphRAGAnalysis(title, analysisContent);
            }, 2000);
        }

        // Show loading modal for GraphRAG analysis
        function showAnalysisLoadingModal(title) {
            const modal = document.createElement('div');
            modal.id = 'graphragLoadingModal';
            modal.className = 'analysis-loading-modal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.8); z-index: 6000; display: flex; 
                align-items: center; justify-content: center;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white; padding: 40px; border-radius: 16px; 
                    max-width: 500px; text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.4);
                    position: relative;
                ">
                    <button onclick="document.getElementById('graphragLoadingModal').remove()" style="
                        position: absolute; top: 16px; right: 16px; 
                        background: #f3f4f6; border: none; width: 32px; height: 32px; 
                        border-radius: 50%; cursor: pointer; color: #6b7280; font-size: 18px;
                        display: flex; align-items: center; justify-content: center;
                        transition: all 0.2s ease;
                    " onmouseover="this.style.background='#e5e7eb'; this.style.color='#374151'" 
                       onmouseout="this.style.background='#f3f4f6'; this.style.color='#6b7280'">✕</button>
                    <div style="margin-bottom: 24px;">
                        <div style="
                            width: 60px; height: 60px; border: 4px solid #e5e7eb; 
                            border-top: 4px solid #8b5cf6; border-radius: 50%; 
                            animation: spin 1s linear infinite; margin: 0 auto 16px;
                        "></div>
                        <h3 style="margin: 0; color: #1f2937; font-size: 20px;">🧠 GraphRAG 深度分析中...</h3>
                    </div>
                    <p style="color: #6b7280; margin: 16px 0; font-size: 14px;">
                        正在分析 "${title}"<br>
                        构建知识图谱 • 提取实体关系 • 生成洞察
                    </p>
                    <div style="
                        background: #f3f4f6; border-radius: 8px; padding: 12px; 
                        text-align: left; font-size: 12px; color: #4b5563;
                    ">
                        <div id="analysisProgress">
                            ✓ 加载文档内容...<br>
                            ⏳ 构建知识图谱...<br>
                            ⏳ 实体关系提取...<br>
                            ⏳ 生成深度洞察...<br>
                        </div>
                    </div>
                </div>
                <style>
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                </style>
            `;
            
            document.body.appendChild(modal);
            
            // Simulate progress updates
            setTimeout(() => updateProgress('✓ 加载文档内容...<br>✓ 构建知识图谱...<br>⏳ 实体关系提取...<br>⏳ 生成深度洞察...<br>'), 800);
            setTimeout(() => updateProgress('✓ 加载文档内容...<br>✓ 构建知识图谱...<br>✓ 实体关系提取...<br>⏳ 生成深度洞察...<br>'), 1500);
        }
        
        function updateProgress(html) {
            const progressElement = document.getElementById('analysisProgress');
            if (progressElement) {
                progressElement.innerHTML = html;
            }
        }

        // Perform GraphRAG Analysis and show results
        function performGraphRAGAnalysis(title, content) {
            // Remove loading modal
            const loadingModal = document.getElementById('graphragLoadingModal');
            if (loadingModal) {
                document.body.removeChild(loadingModal);
            }
            
            // Generate analysis results (simulate GraphRAG processing)
            const analysisResults = generateGraphRAGResults(title, content);
            
            // Update workflow to Analysis step
            updateActiveStep('analysis');
            
            // Show results and trigger transition to next step
            showGraphRAGResults(analysisResults);
        }

        // Generate simulated GraphRAG analysis results
        function generateGraphRAGResults(title, content) {
            const results = {
                title: title,
                summary: generateAnalysisSummary(title),
                entities: generateExtractedEntities(title),
                relationships: generateEntityRelationships(title),
                insights: generateKeyInsights(title),
                recommendations: [], // Will be populated by dynamic analysis
                knowledgeGraph: generateKnowledgeGraphData(title),
                nextSteps: generateNextSteps(title)
            };
            
            return results;
        }

        function generateAnalysisSummary(title) {
            const summaries = {
                '澳洲市场用户画像分析': {
                    overview: '基于GraphRAG深度分析，澳洲市场呈现出高度数字化的B2B生态系统，主要集中在悉尼和墨尔本两大商业中心。',
                    keyFindings: [
                        '科技创业者(25-40岁)占主导地位，占比45%',
                        '数字营销预算年增长率达23%',
                        'LinkedIn是最主要的B2B获客渠道(67%使用率)',
                        '本地化内容的转化率比通用内容高3.2倍'
                    ]
                },
                default: {
                    overview: `通过GraphRAG分析${title}，发现了多个关键实体和深层关系模式。`,
                    keyFindings: [
                        '识别出核心概念和关键要素',
                        '发现潜在的关联关系和影响因子',
                        '提取出可操作的洞察和建议',
                        '构建了完整的知识图谱结构'
                    ]
                }
            };
            
            return summaries[title] || summaries.default;
        }

        function generateExtractedEntities(title) {
            const entities = {
                '澳洲市场用户画像分析': [
                    { name: '科技创业者', type: '用户群体', confidence: 0.95 },
                    { name: '悉尼', type: '地理位置', confidence: 0.92 },
                    { name: 'LinkedIn', type: '平台渠道', confidence: 0.89 },
                    { name: 'B2B营销', type: '业务类型', confidence: 0.87 },
                    { name: '数字营销经理', type: '用户角色', confidence: 0.85 }
                ],
                default: [
                    { name: '核心概念', type: '概念', confidence: 0.9 },
                    { name: '关键要素', type: '要素', confidence: 0.85 },
                    { name: '影响因子', type: '因子', confidence: 0.8 }
                ]
            };
            
            return entities[title] || entities.default;
        }

        function generateEntityRelationships(title) {
            return [
                { source: '科技创业者', target: '悉尼', relation: '主要分布于', strength: 0.85 },
                { source: '数字营销经理', target: 'LinkedIn', relation: '频繁使用', strength: 0.78 },
                { source: 'B2B营销', target: '本地化策略', relation: '依赖于', strength: 0.82 }
            ];
        }

        function generateKeyInsights(title) {
            const insights = {
                '澳洲市场用户画像分析': [
                    {
                        insight: '地理集中效应',
                        description: '澳洲B2B市场高度集中在悉尼-墨尔本轴线，形成了独特的商业生态圈',
                        impact: 'high',
                        actionable: '建议在这两个城市建立本地化团队和合作伙伴关系'
                    },
                    {
                        insight: '数字原生特征',
                        description: '目标用户群体具有强烈的数字化偏好，更倾向于通过数字渠道获取信息',
                        impact: 'high', 
                        actionable: '优先投资数字营销渠道，特别是LinkedIn和专业社交平台'
                    },
                    {
                        insight: '本地化敏感度',
                        description: '澳洲用户对本地化内容和案例表现出显著偏好',
                        impact: 'medium',
                        actionable: '开发澳洲本地化的案例研究和成功故事'
                    }
                ],
                default: [
                    {
                        insight: '核心模式识别',
                        description: '通过图谱分析发现了关键的模式和规律',
                        impact: 'high',
                        actionable: '基于发现的模式制定相应策略'
                    }
                ]
            };
            
            return insights[title] || insights.default;
        }

        // Removed hardcoded generateRecommendations function
        // Recommendations are now dynamically generated based on actual analysis

        function generateKnowledgeGraphData(title) {
            // This would normally come from the actual GraphRAG processing
            return {
                nodes: 12,
                edges: 18,
                communities: 3,
                centralityScore: 0.76
            };
        }

        function generateNextSteps(title) {
            return [
                { step: '市场调研验证', description: '验证分析结果的准确性', priority: 'high' },
                { step: '策略制定', description: '基于洞察制定具体营销策略', priority: 'high' },
                { step: '内容创作', description: '创作符合澳洲市场的本地化内容', priority: 'medium' },
                { step: '渠道优化', description: '优化LinkedIn等关键渠道的投放', priority: 'medium' }
            ];
        }

        // Show GraphRAG Analysis Results
        function showGraphRAGResults(results) {
            // Close knowledge panel first
            toggleKnowledgePanel();
            
            // Create results display modal/panel
            const resultsPanel = document.createElement('div');
            resultsPanel.id = 'graphragResultsPanel';
            resultsPanel.className = 'graphrag-results-panel';
            resultsPanel.style.cssText = `
                position: fixed; top: 0; right: 0; width: 100vw; height: 100vh; 
                background: white; z-index: 5000; overflow-y: auto;
                animation: slideInFromRight 0.5s ease-out;
            `;
            
            resultsPanel.innerHTML = `
                <div style="min-height: 100vh;">
                    <!-- Header -->
                    <div style="
                        background: linear-gradient(135deg, #667eea, #764ba2); 
                        color: white; padding: 30px; position: sticky; top: 0; z-index: 100;
                    ">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <h1 style="margin: 0; font-size: 28px; font-weight: 700;">
                                    🧠 GraphRAG 深度洞察
                                </h1>
                                <p style="margin: 8px 0 0; opacity: 0.9; font-size: 16px;">
                                    ${results.title} - 智能分析报告
                                </p>
                            </div>
                            <div style="display: flex; gap: 12px; align-items: center;">
                                <button onclick="exportAnalysisResults()" style="
                                    background: rgba(255,255,255,0.2); color: white; border: none;
                                    padding: 10px 16px; border-radius: 8px; cursor: pointer; font-size: 14px;
                                ">📊 导出报告</button>
                                <button onclick="closeGraphRAGResults()" style="
                                    background: rgba(255,255,255,0.2); color: white; border: none;
                                    width: 40px; height: 40px; border-radius: 50%; cursor: pointer; font-size: 18px;
                                ">✕</button>
                            </div>
                        </div>
                        
                        <!-- Progress Indicator -->
                        <div style="margin-top: 20px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 12px; opacity: 0.8;">分析进度</span>
                                <span style="font-size: 12px; opacity: 0.8;">100%</span>
                            </div>
                            <div style="background: rgba(255,255,255,0.3); height: 6px; border-radius: 3px; overflow: hidden;">
                                <div style="background: white; height: 100%; width: 100%; border-radius: 3px;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Content -->
                    <div style="padding: 40px;">
                        <!-- Executive Summary -->
                        <section style="margin-bottom: 50px;">
                            <h2 style="color: #1a202c; margin-bottom: 20px; font-size: 22px; font-weight: 600;">
                                📋 执行摘要
                            </h2>
                            <div style="
                                background: #f7fafc; border-left: 4px solid #667eea; 
                                padding: 24px; border-radius: 0 12px 12px 0; margin-bottom: 24px;
                            ">
                                <p style="margin: 0; color: #2d3748; line-height: 1.6; font-size: 16px;">
                                    ${results.summary.overview}
                                </p>
                            </div>
                            
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 16px;">
                                ${results.summary.keyFindings.map(finding => `
                                    <div style="
                                        background: white; border: 1px solid #e2e8f0; 
                                        padding: 16px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                                    ">
                                        <div style="color: #4a5568; font-size: 14px; line-height: 1.5;">
                                            ✓ ${finding}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </section>

                        <!-- Knowledge Graph Stats -->
                        <section style="margin-bottom: 50px;">
                            <h2 style="color: #1a202c; margin-bottom: 20px; font-size: 22px; font-weight: 600;">
                                📊 知识图谱统计
                            </h2>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                                <div style="background: #667eea; color: white; padding: 20px; border-radius: 12px; text-align: center;">
                                    <div style="font-size: 32px; font-weight: bold; margin-bottom: 8px;">${results.knowledgeGraph.nodes}</div>
                                    <div style="font-size: 14px; opacity: 0.9;">实体节点</div>
                                </div>
                                <div style="background: #764ba2; color: white; padding: 20px; border-radius: 12px; text-align: center;">
                                    <div style="font-size: 32px; font-weight: bold; margin-bottom: 8px;">${results.knowledgeGraph.edges}</div>
                                    <div style="font-size: 14px; opacity: 0.9;">关系连接</div>
                                </div>
                                <div style="background: #f093fb; color: white; padding: 20px; border-radius: 12px; text-align: center;">
                                    <div style="font-size: 32px; font-weight: bold; margin-bottom: 8px;">${results.knowledgeGraph.communities}</div>
                                    <div style="font-size: 14px; opacity: 0.9;">社群集群</div>
                                </div>
                                <div style="background: #4facfe; color: white; padding: 20px; border-radius: 12px; text-align: center;">
                                    <div style="font-size: 32px; font-weight: bold; margin-bottom: 8px;">${Math.round((results.knowledgeGraph.centralityScore || 0) * 100)}%</div>
                                    <div style="font-size: 14px; opacity: 0.9;">中心度评分</div>
                                </div>
                            </div>
                        </section>

                        <!-- Action Buttons -->
                        <section style="text-align: center; padding: 40px 0;">
                            <button onclick="proceedToNextStep()" style="
                                background: linear-gradient(135deg, #667eea, #764ba2); 
                                color: white; border: none; padding: 16px 32px; 
                                border-radius: 12px; font-size: 16px; font-weight: 600; 
                                cursor: pointer; margin-right: 16px; box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
                            ">
                                🚀 进入下一阶段：市场调研
                            </button>
                            <button onclick="saveAnalysisResults()" style="
                                background: white; color: #667eea; border: 2px solid #667eea; 
                                padding: 16px 32px; border-radius: 12px; font-size: 16px; 
                                font-weight: 600; cursor: pointer;
                            ">
                                💾 保存分析结果
                            </button>
                        </section>
                    </div>
                </div>
            `;
            
            document.body.appendChild(resultsPanel);
        }

        // Helper functions for GraphRAG results panel
        window.closeGraphRAGResults = function() {
            const panel = document.getElementById('graphragResultsPanel');
            if (panel) {
                panel.style.animation = 'slideOutToRight 0.3s ease-in forwards';
                setTimeout(() => {
                    document.body.removeChild(panel);
                }, 300);
            }
        }

        window.exportAnalysisResults = function() {
            showNotification('📊 分析报告导出功能开发中...');
        }

        window.saveAnalysisResults = function() {
            showNotification('💾 分析结果已保存到知识库');
        }

        window.proceedToNextStep = function() {
            // Update workflow to Research step
            updateActiveStep('research');
            closeGraphRAGResults();
            showNotification('🚀 已进入市场调研阶段，开始制定调研策略');
            
            // Show research interface after a delay
            setTimeout(() => {
                showResearchInterface();
            }, 1000);
        }

        function showResearchInterface() {
            // This would open the next phase of the workflow
            // For now, just show a notification
            showNotification('🔍 市场调研界面开发中... 将包含调研问卷、访谈指南等工具');
        }

        // Add slide out animation
        const additionalStyles = document.createElement('style');
        additionalStyles.textContent = `
            @keyframes slideOutToRight {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
        `;
        document.head.appendChild(additionalStyles);

        // Delete node - make global for onclick access
        window.deleteNode = function(event, buttonElement) {
            console.log('🗑️ Delete node function called!', event, buttonElement);
            
            try {
                event.stopPropagation();
                const nodeContent = buttonElement.closest('.node-content');
                if (!nodeContent) {
                    console.error('❌ 无法找到node-content元素');
                    return;
                }
                
                const titleElement = nodeContent.querySelector('.node-title');
                if (!titleElement) {
                    console.error('❌ 无法找到node-title元素');
                    return;
                }
                
                const title = titleElement.textContent;
                console.log('🗑️ Attempting to delete:', title);
                
                const treeNode = buttonElement.closest('.tree-node');
                if (!treeNode) {
                    console.error('❌ 无法找到tree-node元素');
                    return;
                }
                
                // 🔍 检查节点是否有原始文件名属性
                const originalFileName = treeNode.getAttribute('data-file-name');
                console.log('🔍 检查文件名属性:');
                console.log('  - 显示名称:', title);
                console.log('  - 原始文件名属性:', originalFileName);
                console.log('  - 存储键属性:', treeNode.getAttribute('data-file-storage-key'));
                
                // 🔍 显示所有可能的属性
                const allAttributes = {};
                for (let attr of treeNode.attributes) {
                    allAttributes[attr.name] = attr.value;
                }
                console.log('🔍 节点所有属性:', allAttributes);
            
                // 🔥 使用原始文件名进行删除（如果存在的话）
                const fileNameToDelete = originalFileName || title;
                console.log('🗑️ Proceeding with deletion of:', fileNameToDelete);
                
                // 🔥 确定是文件还是分类
                const iconElement = nodeContent.querySelector('.node-icon');
                if (!iconElement) {
                    console.error('❌ 无法找到node-icon元素');
                    return;
                }
                
                const iconText = iconElement.textContent;
                const isFile = iconText.includes('📄') || iconText.includes('🎯');
                console.log('🗑️ File type detection - Icon text:', iconText, 'Is file:', isFile);
                
                // 🔥 根据存储结构判断是文件还是分类
                const knowledgeTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
                const isCategory = fileNameToDelete in knowledgeTree;
                const isActualFile = Object.values(knowledgeTree).some(category => 
                    category.files && category.files.some(file => file.name === fileNameToDelete)
                );
                
                console.log('🔍 真实类型判断:');
                console.log('  - 是分类:', isCategory);
                console.log('  - 是文件:', isActualFile);
                console.log('  - 图标判断:', isFile);
                
                if (isCategory && !isActualFile) {
                    // 删除分类：清理整个分类的持久化数据
                    cleanupCategoryFromPersistentData(fileNameToDelete);
                    console.log('🗑️ Cleaned up category data for:', fileNameToDelete);
                } else if (isActualFile) {
                    // 删除文件：清理持久化数据
                    cleanupFileFromPersistentData(fileNameToDelete);
                    console.log('🗑️ Cleaned up file data for:', fileNameToDelete);
                } else {
                    console.log('⚠️ 无法确定类型，尝试两种删除方式');
                    cleanupFileFromPersistentData(fileNameToDelete);
                    cleanupCategoryFromPersistentData(fileNameToDelete);
                }
                
                // 从DOM中移除
                console.log('🗑️ Removing DOM element for:', title);
                treeNode.remove();
                showNotification(`"${title}" deleted! 🗑️`);
                console.log('🗑️ Deletion completed for:', title);
                
            } catch (error) {
                console.error('❌ Delete function error:', error);
                alert('删除出错: ' + error.message);
            }
        }


        function searchKnowledge(query) {
            const nodes = document.querySelectorAll('.tree-node');
            const lowerQuery = query.toLowerCase();
            
            nodes.forEach(node => {
                const title = node.querySelector('.node-title').textContent.toLowerCase();
                const matches = title.includes(lowerQuery);
                node.style.display = matches || !query ? 'block' : 'none';
            });
        }

        function importTemplate(templateType) {
            const templates = {
                marketing: 'Marketing Strategy Template',
                content: 'Content Creation Framework', 
                social: 'Social Media Guide',
                analytics: 'Analytics Template'
            };
            
            showNotification(`${templates[templateType]} imported successfully! 📋`);
        }

        function showNotification(message) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #10b981, #059669);
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                font-size: 14px;
                z-index: 3000;
                animation: slideInRight 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        function editNode(event, element) { event.stopPropagation(); }
        // Export selected knowledge as downloadable files
        window.exportSelectedKnowledge = function() {
            console.log('📤 exportSelectedKnowledge called!');
            const selectedCheckboxes = document.querySelectorAll('.node-checkbox.selected');
            const selectedCount = selectedCheckboxes.length;
            console.log('🔍 Selected checkboxes:', selectedCheckboxes);
            console.log('🔍 Selected count:', selectedCount);
            console.log('🔍 selectedNodes array:', selectedNodes);
            
            if (selectedCount === 0) {
                console.log('⚠️ No content selected for export');
                showNotification('⚠️ Please select content to export');
                return;
            }
            
            console.log('📤 Exporting selected knowledge:', selectedNodes);
            
            // Create export data structure
            const exportData = {
                exportedAt: new Date().toISOString(),
                exportedBy: 'CreatorMind AI',
                selectedItems: [],
                totalCount: selectedCount
            };
            
            // Process each selected item
            selectedNodes.forEach(nodeName => {
                const nodeData = selectedNodesData[nodeName] || {};
                const item = {
                    name: nodeName,
                    type: nodeData.type || 'file',
                    content: nodeData.content || getSampleContent(nodeName) || 'No content available',
                    exportedAt: new Date().toISOString()
                };
                exportData.selectedItems.push(item);
            });
            
            // Create and download JSON file
            const jsonContent = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonContent], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            // Create download link
            const link = document.createElement('a');
            link.href = url;
            link.download = `knowledge-export-${new Date().getFullYear()}-${String(new Date().getMonth() + 1).padStart(2, '0')}-${String(new Date().getDate()).padStart(2, '0')}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            showNotification(`📤 Exported ${selectedCount} items to your downloads folder!`);
            console.log('✅ Export completed successfully');
        }
        
        function useSelectedContent() { showNotification('Selected content added to workflow! ✨'); }

        // GraphRAG Service Integration
        // Multi-Agent System Classes
        class GraphAgent {
            constructor(graphRAGService) {
                this.service = graphRAGService;
                this.agentType = 'graph';
                this.capabilities = ['entity_extraction', 'relationship_mapping', 'graph_traversal'];
            }
            
            async analyze(content, context = {}) {
                console.log('🕸️ GraphAgent: Analyzing content structure and relationships');
                
                const entities = await this.extractEntities(content);
                const relationships = await this.mapRelationships(entities, content);
                const graphStructure = await this.buildGraphStructure(entities, relationships);
                
                return {
                    agent: 'GraphAgent',
                    entities,
                    relationships,
                    graphStructure,
                    reasoning: this.generateGraphReasoning(graphStructure),
                    confidence: this.calculateGraphConfidence(entities, relationships)
                };
            }
            
            async extractEntities(content) {
                // 实体提取逻辑
                const entityTypes = ['PERSON', 'ORG', 'TECH', 'CONCEPT', 'EVENT', 'LOCATION'];
                const entities = [];
                
                // 基于内容类型和文件名提取实体
                if (content.name) {
                    const filename = content.name.toLowerCase();
                    
                    if (filename.includes('api') || filename.includes('service')) {
                        entities.push({ type: 'TECH', value: 'API服务', confidence: 0.9 });
                    }
                    if (filename.includes('user') || filename.includes('client')) {
                        entities.push({ type: 'CONCEPT', value: '用户管理', confidence: 0.8 });
                    }
                    if (filename.includes('data') || filename.includes('model')) {
                        entities.push({ type: 'CONCEPT', value: '数据模型', confidence: 0.85 });
                    }
                }
                
                return entities;
            }
            
            async mapRelationships(entities, content) {
                const relationships = [];
                
                // 基于实体间的语义关系生成连接
                for (let i = 0; i < entities.length; i++) {
                    for (let j = i + 1; j < entities.length; j++) {
                        const rel = this.inferRelationship(entities[i], entities[j], content);
                        if (rel) relationships.push(rel);
                    }
                }
                
                return relationships;
            }
            
            inferRelationship(entity1, entity2, content) {
                if (entity1.type === 'TECH' && entity2.type === 'CONCEPT') {
                    return {
                        source: entity1.value,
                        target: entity2.value,
                        type: 'IMPLEMENTS',
                        confidence: 0.7
                    };
                }
                return null;
            }
            
            async buildGraphStructure(entities, relationships) {
                return {
                    nodes: entities.map((e, i) => ({ id: i, label: e.value, type: e.type })),
                    edges: relationships.map((r, i) => ({
                        id: i,
                        source: entities.findIndex(e => e.value === r.source),
                        target: entities.findIndex(e => e.value === r.target),
                        type: r.type
                    }))
                };
            }
            
            generateGraphReasoning(structure) {
                return [
                    `检测到 ${structure.nodes.length} 个实体节点`,
                    `识别了 ${structure.edges.length} 个关系连接`,
                    '基于图结构分析了内容语义关系'
                ];
            }
            
            calculateGraphConfidence(entities, relationships) {
                return Math.min(0.95, 0.6 + (entities.length * 0.05) + (relationships.length * 0.03));
            }
            
            // 新增：从文档中提取实体的方法
            async extractEntitiesFromDocument(file, documentAnalysis) {
                console.log('🕸️ GraphAgent: Extracting entities from document');
                
                const content = documentAnalysis.extractedContent || '';
                const fileType = documentAnalysis.fileType?.supportedFormat || 'UNKNOWN';
                
                const entities = await this.extractEntitiesFromContent(content, fileType);
                const relationships = await this.mapRelationships(entities, { name: file.name, content });
                
                return {
                    agent: 'GraphAgent',
                    entities,
                    relationships,
                    confidence: this.calculateGraphConfidence(entities, relationships)
                };
            }
            
            async extractEntitiesFromContent(content, fileType) {
                console.log('🔍 GraphAgent: Analyzing content with length:', content.length || content.inferredContent?.length || 0);
                const entities = [];
                
                // 检查是否是AI分析的结果
                if (content && typeof content === 'object' && content.aiGenerated) {
                    console.log('🤖 Using AI-analyzed content for entity extraction');
                    
                    // 从AI实体中提取
                    if (content.aiEntities && content.aiEntities.length > 0) {
                        content.aiEntities.forEach(entity => {
                            entities.push({
                                type: 'AI_ENTITY',
                                value: entity,
                                confidence: 0.85
                            });
                        });
                    }
                    
                    // 从AI概念中提取
                    if (content.aiConcepts && content.aiConcepts.length > 0) {
                        content.aiConcepts.forEach(concept => {
                            entities.push({
                                type: 'AI_CONCEPT', 
                                value: concept,
                                confidence: 0.8
                            });
                        });
                    }
                    
                    // 从推断内容中提取更多实体
                    if (content.inferredContent) {
                        const inferredEntities = this.extractEntitiesFromText(content.inferredContent);
                        entities.push(...inferredEntities);
                    }
                    
                    return this.deduplicateAndRankEntities(entities);
                }
                
                // 处理普通文本内容
                const textContent = typeof content === 'string' ? content : content.extractedContent || '';
                
                if (!textContent || textContent.length < 10) {
                    console.warn('⚠️ Content too short or empty, using filename analysis');
                    return [{
                        type: 'FILE',
                        value: 'Empty or short content',
                        confidence: 0.3
                    }];
                }
                
                // 基于文件类型的实体识别模式
                const patterns = this.getEntityPatternsByFileType(fileType);
                
                patterns.forEach(pattern => {
                    const matches = textContent.match(pattern.regex) || [];
                    matches.forEach(match => {
                        let cleanMatch = match.trim();
                        if (pattern.type === 'KEY' && cleanMatch.includes('"')) {
                            // 提取JSON key
                            const keyMatch = cleanMatch.match(/"([^"]+)"/);
                            if (keyMatch) cleanMatch = keyMatch[1];
                        } else if (pattern.type === 'HEADING' && cleanMatch.includes('#')) {
                            // 清理Markdown标题
                            cleanMatch = cleanMatch.replace(/^#+\s*/, '');
                        }
                        
                        if (cleanMatch.length > 1) {
                            entities.push({
                                type: pattern.type,
                                value: cleanMatch,
                                confidence: pattern.confidence
                            });
                        }
                    });
                });
                
                // 基于关键词的实体识别
                const words = textContent.toLowerCase().split(/\s+/).filter(w => w.length > 2);
                const keywords = this.extractKeywords(words);
                console.log('🔤 Extracted keywords:', keywords);
                
                keywords.forEach(keyword => {
                    entities.push({
                        type: 'CONCEPT',
                        value: keyword.toUpperCase(),
                        confidence: 0.7
                    });
                });
                
                // 基于内容类型的特殊实体提取
                const contentAnalysis = this.analyzeContentType(textContent);
                if (contentAnalysis.entities) {
                    entities.push(...contentAnalysis.entities);
                }
                
                const finalEntities = this.deduplicateAndRankEntities(entities);
                console.log('✅ Final extracted entities:', finalEntities);
                return finalEntities;
            }
            
            // 从文本中提取实体的辅助方法
            extractEntitiesFromText(text) {
                const entities = [];
                
                // 检测技术词汇
                const techTerms = ['API', 'REST', '数据库', '算法', '机器学习', '人工智能', '系统', '架构', '设计'];
                techTerms.forEach(term => {
                    if (text.includes(term) && this.isValidEntity(term)) {
                        entities.push({
                            type: 'TECH',
                            value: term,
                            confidence: 0.7
                        });
                    }
                });
                
                // 检测业务词汇
                const businessTerms = ['需求', '用户', '产品', '功能', '流程', '管理', '分析', '报告'];
                businessTerms.forEach(term => {
                    if (text.includes(term) && this.isValidEntity(term)) {
                        entities.push({
                            type: 'BUSINESS',
                            value: term,
                            confidence: 0.6
                        });
                    }
                });
                
                return entities;
            }
            
            analyzeContentType(content) {
                const entities = [];
                const lowercaseContent = content.toLowerCase();
                
                // 检测技术相关内容
                const techTerms = [
                    'api', 'database', 'server', 'client', 'framework', 'library', 
                    'algorithm', 'data structure', 'machine learning', 'artificial intelligence',
                    'frontend', 'backend', 'fullstack', 'microservice', 'docker', 'kubernetes'
                ];
                
                techTerms.forEach(term => {
                    if (lowercaseContent.includes(term)) {
                        entities.push({
                            type: 'TECH_TERM',
                            value: term.toUpperCase(),
                            confidence: 0.8
                        });
                    }
                });
                
                // 检测人名（简单模式）
                const namePattern = /\b[A-Z][a-z]+\s+[A-Z][a-z]+\b/g;
                const names = content.match(namePattern) || [];
                names.forEach(name => {
                    entities.push({
                        type: 'PERSON',
                        value: name,
                        confidence: 0.6
                    });
                });
                
                // 检测日期
                const datePattern = /\b\d{4}-\d{2}-\d{2}\b|\b\d{1,2}\/\d{1,2}\/\d{4}\b/g;
                const dates = content.match(datePattern) || [];
                dates.forEach(date => {
                    entities.push({
                        type: 'DATE',
                        value: date,
                        confidence: 0.9
                    });
                });
                
                return { entities };
            }
            
            getEntityPatternsByFileType(fileType) {
                const commonPatterns = [
                    { type: 'EMAIL', regex: /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, confidence: 0.9 },
                    { type: 'URL', regex: /https?:\/\/[^\s]+/g, confidence: 0.8 },
                    { type: 'TECH', regex: /\b(API|REST|GraphQL|React|Node\.js|Python|JavaScript|SQL|NoSQL|Docker|Kubernetes)\b/gi, confidence: 0.8 }
                ];
                
                const typeSpecificPatterns = {
                    'JSON': [
                        { type: 'KEY', regex: /"([^"]+)":/g, confidence: 0.6 }
                    ],
                    'CSV': [
                        { type: 'COLUMN', regex: /^[^,\n]+/gm, confidence: 0.7 }
                    ],
                    'MD': [
                        { type: 'HEADING', regex: /^#+\s+(.+)$/gm, confidence: 0.8 }
                    ]
                };
                
                return [...commonPatterns, ...(typeSpecificPatterns[fileType] || [])];
            }
            
            extractKeywords(words) {
                const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were']);
                const wordFreq = {};
                
                words.forEach(word => {
                    if (word.length > 3 && !stopWords.has(word)) {
                        wordFreq[word] = (wordFreq[word] || 0) + 1;
                    }
                });
                
                return Object.entries(wordFreq)
                    .filter(([word, freq]) => freq >= 2)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 10)
                    .map(([word]) => word);
            }
            
            deduplicateAndRankEntities(entities) {
                const entityMap = new Map();
                
                entities.forEach(entity => {
                    const key = `${entity.type}:${entity.value.toLowerCase()}`;
                    const existing = entityMap.get(key);
                    
                    if (!existing || entity.confidence > existing.confidence) {
                        entityMap.set(key, entity);
                    }
                });
                
                return Array.from(entityMap.values())
                    .sort((a, b) => b.confidence - a.confidence)
                    .slice(0, 20);
            }
        }
        
        class HybridAgent {
            constructor(graphRAGService) {
                this.service = graphRAGService;
                this.agentType = 'hybrid';
                this.capabilities = ['multi_modal_analysis', 'context_fusion', 'semantic_reasoning'];
            }
            
            async analyze(content, context = {}) {
                console.log('🔄 HybridAgent: Performing multi-modal hybrid analysis');
                
                const textAnalysis = await this.analyzeTextContent(content);
                const structuralAnalysis = await this.analyzeStructure(content);
                const semanticAnalysis = await this.performSemanticReasoning(content, context);
                
                const fusedResults = await this.fuseAnalyses([textAnalysis, structuralAnalysis, semanticAnalysis]);
                
                return {
                    agent: 'HybridAgent',
                    textAnalysis,
                    structuralAnalysis,
                    semanticAnalysis,
                    fusedResults,
                    reasoning: this.generateHybridReasoning(fusedResults),
                    confidence: this.calculateHybridConfidence(fusedResults)
                };
            }
            
            async analyzeTextContent(content) {
                return {
                    contentType: this.detectContentType(content),
                    complexity: this.assessComplexity(content),
                    topics: this.extractTopics(content)
                };
            }
            
            async analyzeStructure(content) {
                return {
                    fileStructure: this.analyzeFileStructure(content),
                    organizationalPattern: this.detectOrganizationPattern(content),
                    dependencies: this.inferDependencies(content)
                };
            }
            
            async performSemanticReasoning(content, context) {
                return {
                    contextualRelevance: this.calculateContextRelevance(content, context),
                    semanticSimilarity: this.findSemanticSimilarities(content),
                    conceptualMapping: this.mapConcepts(content)
                };
            }
            
            async fuseAnalyses(analyses) {
                return {
                    combinedInsights: this.combineInsights(analyses),
                    crossModalConnections: this.findCrossModalConnections(analyses),
                    emergentPatterns: this.identifyEmergentPatterns(analyses)
                };
            }
            
            detectContentType(content) {
                const filename = content.name?.toLowerCase() || '';
                if (filename.includes('api')) return 'API文档';
                if (filename.includes('config')) return '配置文件';
                if (filename.includes('data')) return '数据文件';
                return '通用内容';
            }
            
            generateHybridReasoning(results) {
                return [
                    '执行了多模态内容分析',
                    `融合了文本、结构和语义三个维度的分析结果`,
                    `识别出 ${results.crossModalConnections?.length || 0} 个跨模态连接`,
                    '生成了综合性的理解框架'
                ];
            }
            
            calculateHybridConfidence(results) {
                const baseConfidence = 0.75;
                const insightBonus = (results.combinedInsights?.length || 0) * 0.02;
                const connectionBonus = (results.crossModalConnections?.length || 0) * 0.03;
                return Math.min(0.98, baseConfidence + insightBonus + connectionBonus);
            }
            
            // Helper methods for HybridAgent
            assessComplexity(content) {
                return 'medium';
            }
            
            extractTopics(content) {
                return ['content analysis', 'file processing'];
            }
            
            analyzeFileStructure(content) {
                return 'standard file structure';
            }
            
            detectOrganizationPattern(content) {
                return 'hierarchical';
            }
            
            inferDependencies(content) {
                return [];
            }
            
            calculateContextRelevance(content, context) {
                return 0.8;
            }
            
            findSemanticSimilarities(content) {
                return [];
            }
            
            mapConcepts(content) {
                return {};
            }
            
            combineInsights(analyses) {
                return ['Combined multi-modal insights'];
            }
            
            findCrossModalConnections(analyses) {
                return ['Text-Structure connection', 'Structure-Semantic connection'];
            }
            
            identifyEmergentPatterns(analyses) {
                return ['Emergent pattern detected'];
            }
            
            // 新增：从文档中提取实体的方法
            async extractEntitiesFromDocument(file, documentAnalysis) {
                console.log('🔄 HybridAgent: Extracting entities from document');
                
                const textAnalysis = await this.analyzeTextContent({ name: file.name, content: documentAnalysis.extractedContent });
                const structuralAnalysis = await this.analyzeStructure({ name: file.name, structure: documentAnalysis.documentStructure });
                
                const entities = this.extractEntitiesFromAnalysis(textAnalysis, structuralAnalysis);
                
                return {
                    agent: 'HybridAgent',
                    entities,
                    relationships: [],
                    confidence: this.calculateHybridConfidence({ combinedInsights: entities, crossModalConnections: [] })
                };
            }
            
            extractEntitiesFromAnalysis(textAnalysis, structuralAnalysis) {
                const entities = [];
                
                // 从文本分析中提取实体
                if (textAnalysis.topics) {
                    textAnalysis.topics.forEach(topic => {
                        entities.push({
                            type: 'TOPIC',
                            value: topic,
                            confidence: 0.7,
                            source: 'text_analysis'
                        });
                    });
                }
                
                // 从结构分析中提取实体
                if (structuralAnalysis.organizationalPattern) {
                    entities.push({
                        type: 'PATTERN',
                        value: structuralAnalysis.organizationalPattern,
                        confidence: 0.6,
                        source: 'structural_analysis'
                    });
                }
                
                return entities;
            }
        }
        
        class DeepResearchAgent {
            constructor(graphRAGService) {
                this.service = graphRAGService;
                this.agentType = 'deep_research';
                this.capabilities = ['deep_analysis', 'research_synthesis', 'insight_generation'];
            }
            
            async analyze(content, context = {}) {
                console.log('🔍 DeepResearchAgent: Conducting deep research analysis');
                
                const domainAnalysis = await this.analyzeDomain(content);
                const knowledgeExtraction = await this.extractKnowledge(content, context);
                const insightGeneration = await this.generateDeepInsights(content, domainAnalysis, knowledgeExtraction);
                const researchSynthesis = await this.synthesizeResearch(insightGeneration);
                
                return {
                    agent: 'DeepResearchAgent',
                    domainAnalysis,
                    knowledgeExtraction,
                    insightGeneration,
                    researchSynthesis,
                    reasoning: this.generateResearchReasoning(researchSynthesis),
                    confidence: this.calculateResearchConfidence(researchSynthesis)
                };
            }
            
            async analyzeDomain(content) {
                return {
                    domain: this.identifyDomain(content),
                    expertise_level: this.assessExpertiseLevel(content),
                    domain_entities: this.extractDomainEntities(content),
                    technical_complexity: this.assessTechnicalComplexity(content)
                };
            }
            
            async extractKnowledge(content, context) {
                return {
                    key_concepts: this.extractKeyConcepts(content),
                    methodologies: this.identifyMethodologies(content),
                    best_practices: this.inferBestPractices(content),
                    potential_issues: this.identifyPotentialIssues(content)
                };
            }
            
            async generateDeepInsights(content, domainAnalysis, knowledgeExtraction) {
                const insights = [];
                
                // 基于领域分析生成洞察
                if (domainAnalysis.technical_complexity === 'high') {
                    insights.push('该内容涉及高技术复杂度，需要专业知识理解');
                }
                
                // 基于知识提取生成洞察
                if (knowledgeExtraction.methodologies?.length > 0) {
                    insights.push(`识别了 ${knowledgeExtraction.methodologies.length} 种方法论`);
                }
                
                return {
                    insights,
                    impact_assessment: this.assessImpact(content),
                    future_implications: this.predictFutureImplications(content),
                    recommendations: this.generateRecommendations(content)
                };
            }
            
            async synthesizeResearch(insights) {
                return {
                    synthesis_summary: this.createSynthesisSummary(insights),
                    key_findings: this.extractKeyFindings(insights),
                    research_gaps: this.identifyResearchGaps(insights),
                    actionable_outcomes: this.generateActionableOutcomes(insights)
                };
            }
            
            identifyDomain(content) {
                const filename = content.name?.toLowerCase() || '';
                if (filename.includes('ai') || filename.includes('ml')) return 'AI/机器学习';
                if (filename.includes('web') || filename.includes('html')) return 'Web开发';
                if (filename.includes('data')) return '数据科学';
                return '通用技术';
            }
            
            generateResearchReasoning(synthesis) {
                return [
                    '进行了深度领域分析',
                    '提取了核心知识要素',
                    '生成了深层次洞察',
                    `综合分析发现了 ${synthesis.key_findings?.length || 0} 个关键发现`,
                    '形成了可操作的研究成果'
                ];
            }
            
            calculateResearchConfidence(synthesis) {
                const baseConfidence = 0.8;
                const findingsBonus = (synthesis.key_findings?.length || 0) * 0.025;
                const actionableBonus = (synthesis.actionable_outcomes?.length || 0) * 0.02;
                return Math.min(0.99, baseConfidence + findingsBonus + actionableBonus);
            }
            
            // Helper methods for DeepResearchAgent
            assessExpertiseLevel(content) {
                return 'intermediate';
            }
            
            extractDomainEntities(content) {
                return ['技术实体', '概念实体'];
            }
            
            assessTechnicalComplexity(content) {
                const filename = content.name?.toLowerCase() || '';
                if (filename.includes('ai') || filename.includes('ml') || filename.includes('algorithm')) {
                    return 'high';
                } else if (filename.includes('api') || filename.includes('service')) {
                    return 'medium';
                }
                return 'low';
            }
            
            extractKeyConcepts(content) {
                return ['核心概念1', '核心概念2'];
            }
            
            identifyMethodologies(content) {
                return ['方法论A', '方法论B'];
            }
            
            inferBestPractices(content) {
                return ['最佳实践1', '最佳实践2'];
            }
            
            identifyPotentialIssues(content) {
                return ['潜在问题1', '潜在问题2'];
            }
            
            assessImpact(content) {
                return 'medium impact';
            }
            
            predictFutureImplications(content) {
                return ['Future implication 1', 'Future implication 2'];
            }
            
            generateRecommendations(content) {
                return ['Recommendation 1', 'Recommendation 2'];
            }
            
            createSynthesisSummary(insights) {
                return '综合分析总结';
            }
            
            extractKeyFindings(insights) {
                return ['关键发现1', '关键发现2', '关键发现3'];
            }
            
            identifyResearchGaps(insights) {
                return ['研究缺口1', '研究缺口2'];
            }
            
            generateActionableOutcomes(insights) {
                return ['可操作成果1', '可操作成果2'];
            }
            
            // 新增：从文档中提取实体的方法
            async extractEntitiesFromDocument(file, documentAnalysis) {
                console.log('🔍 DeepResearchAgent: Extracting entities from document');
                
                const domain = this.identifyDomain({ name: file.name, content: documentAnalysis.extractedContent });
                const domainEntities = this.extractDomainEntities({ name: file.name });
                const keyConcepts = this.extractKeyConcepts({ name: file.name, content: documentAnalysis.extractedContent });
                
                const entities = [
                    ...domainEntities.map(entity => ({ type: 'DOMAIN', value: entity, confidence: 0.8 })),
                    ...keyConcepts.map(concept => ({ type: 'CONCEPT', value: concept, confidence: 0.7 }))
                ];
                
                return {
                    agent: 'DeepResearchAgent',
                    entities,
                    relationships: [],
                    confidence: this.calculateResearchConfidence({ key_findings: entities, actionable_outcomes: [] })
                };
            }
        }

        class GraphRAGService {
            constructor() {
                this.baseUrl = 'http://127.0.0.1:8001/api'; // GraphRAG代理服务
                this.isConnected = true; // 🔥 强制启用本地服务
                console.log('🚀 GraphRAG服务已启用，URL:', this.baseUrl);
                // this.checkServiceHealth(); // 启动时检查服务健康状态
                
                // 初始化多智能体系统
                this.graphAgent = new GraphAgent(this);
                this.hybridAgent = new HybridAgent(this);
                this.deepResearchAgent = new DeepResearchAgent(this);
                
                // 支持的文件格式
                this.supportedFormats = {
                    'text/plain': 'TXT',
                    'application/pdf': 'PDF', 
                    'text/markdown': 'MD',
                    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'DOCX',
                    'application/msword': 'DOC',
                    'text/csv': 'CSV',
                    'application/json': 'JSON',
                    'application/x-yaml': 'YAML',
                    'text/yaml': 'YML'
                };
                
                this.checkConnection();
            }
            
            // 检查GraphRAG服务健康状态
            async checkServiceHealth() {
                try {
                    console.log('🔍 检查GraphRAG服务状态...');
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10秒超时
                    
                    const response = await fetch(`${this.baseUrl}/auth/profile`, {
                        method: 'GET',
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('✅ GraphRAG服务正常:', result);
                        this.isConnected = true;
                        return true;
                    } else {
                        throw new Error(`健康检查失败: ${response.status}`);
                    }
                } catch (error) {
                    console.warn('⚠️ GraphRAG服务不可用:', error.message);
                    console.warn('📋 将使用备用分析系统');
                    this.isConnected = false;
                    return false;
                }
            }
            
            // 新增：即时文件内容分析
            async analyzeFileOnUpload(file) {
                // 🚨 DEBUG: GraphRAG Service 函数入口追踪
                console.log('🚨 DEBUG: ======= GraphRAG Service analyzeFileOnUpload 函数被调用 =======');
                console.log('🚨 DEBUG: 传入的File对象详细信息:');
                console.log('🚨 DEBUG: - File名称:', file.name);
                console.log('🚨 DEBUG: - File大小:', file.size, '字节');
                console.log('🚨 DEBUG: - File类型:', file.type);
                console.log('🚨 DEBUG: - File构造器:', file.constructor.name);
                console.log('🚨 DEBUG: - File对象完整信息:', file);
                
                // 🚨 DEBUG: 检查File对象的自定义属性
                if (file.sourceUrl) {
                    console.log('🚨 DEBUG: - 检测到sourceUrl:', file.sourceUrl);
                    console.log('🚨 DEBUG: - 这是从URL创建的File对象！');
                    if (file.sourceUrl.includes('youtube.com') || file.sourceUrl.includes('youtu.be')) {
                        console.log('🚨 DEBUG: ⚠️  关键发现：这是YouTube URL的File对象！');
                        console.log('🚨 DEBUG: ⚠️  期望：系统应该检测到这是视频内容并调用视频提取管道');
                        console.log('🚨 DEBUG: ⚠️  问题：如果系统把它当作普通HTML文件处理，就会出现内容不正确的问题');
                    }
                }
                if (file.title) {
                    console.log('🚨 DEBUG: - 检测到title:', file.title);
                }
                
                // 🚨 DEBUG: 预读取File内容进行分析
                try {
                    const fileText = await file.text();
                    console.log('🚨 DEBUG: - File内容长度:', fileText.length);
                    console.log('🚨 DEBUG: - File内容预览（前200字符）:', fileText.substring(0, 200));
                    
                    // 检查是否是YouTube URL内容
                    if (fileText.includes('youtube.com') && fileText.length < 200) {
                        console.log('🚨 DEBUG: ⚠️  关键发现：File内容是简短的YouTube URL！');
                        console.log('🚨 DEBUG: ⚠️  这表明File对象可能包含URL而不是提取的内容');
                    }
                    
                    // 检查是否是HTML页面内容  
                    if (fileText.includes('<html') || fileText.includes('<!DOCTYPE') || 
                        fileText.includes('关于 新闻 版权')) {
                        console.log('🚨 DEBUG: ⚠️  关键发现：File内容是HTML页面内容！');
                        console.log('🚨 DEBUG: ⚠️  这可能就是问题所在：YouTube URL被当作HTML页面处理');
                    }
                } catch (textError) {
                    console.log('🚨 DEBUG: - 无法预读取File内容:', textError);
                }
                
                console.log('🚨 DEBUG: 即将进入函数主要逻辑...');
                console.log('🚀 开始文件分析:', file.name);
                
                // 如果服务未连接，先尝试重新连接
                if (!this.isConnected) {
                    console.log('🔄 服务未连接，尝试重新连接...');
                    await this.checkServiceHealth();
                }
                
                try {
                    // 🚀 优先使用GraphRAG Agent的真正能力
                    if (this.isConnected) {
                        console.log('🔗 使用GraphRAG Agent进行专业分析');
                        return await this.useGraphRAGAgent(file);
                    }
                    
                    // 🔄 GraphRAG离线时的高质量备用方案
                    console.log('⚠️ GraphRAG Agent离线，使用内置AI分析');
                    
                    // 第一步：读取文件真实内容
                    let fileContent = '';
                    if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {
                        // 🔥 使用PDF.js提取真实PDF内容
                        console.log('📄 开始提取PDF真实内容...');
                        try {
                            fileContent = await this.extractPDFText(file);
                            console.log('✅ PDF内容提取成功，长度:', fileContent.length);
                        } catch (pdfError) {
                            console.log('❌ PDF提取失败，使用文件名分析:', pdfError.message);
                            fileContent = `PDF文件: ${file.name}`;
                        }
                    } else {
                        try {
                            fileContent = await this.readTextFile(file);
                            console.log('✅ 文件内容读取成功，长度:', fileContent.length);
                        } catch (error) {
                            console.log('❌ 文件读取失败:', error.message);
                            fileContent = `文件: ${file.name}`;
                        }
                    }
                    
                    // 第二步：GPT-5 nano智能分析
                    const intelligentAnalysis = await this.analyzeFileContent(file, fileContent);
                    
                    // 第三步：构建返回结果
                    return {
                        fileName: file.name,
                        fileType: this.identifyFileType(file),
                        fileSize: file.size,
                        analysisTimestamp: new Date().toISOString(),
                        extractedContent: intelligentAnalysis.content,
                        concepts: intelligentAnalysis.concepts || [],
                        entities: intelligentAnalysis.entities || [],
                        relationships: intelligentAnalysis.relationships || [],
                        positionSuggestion: {
                            primarySuggestion: {
                                path: intelligentAnalysis.knowledgeTreeSuggestion,
                                confidence: intelligentAnalysis.confidence
                            },
                            alternatives: [] // GPT-5 nano会给出最佳建议
                        },
                        processingStage: 'completed',
                        confidence: intelligentAnalysis.confidence
                    };
                    
                } catch (error) {
                    console.error('❌ 文件分析失败:', error);
                    return {
                        fileName: file.name,
                        fileType: this.identifyFileType(file),
                        fileSize: file.size,
                        extractedContent: `分析失败: ${file.name}`,
                        concepts: [],
                        entities: [],
                        positionSuggestion: {
                            primarySuggestion: {
                                path: '未分类',
                                confidence: 0.3
                            },
                            alternatives: []
                        },
                        processingStage: 'failed',
                        error: error.message
                    };
                }
            }
            
            // 识别文件类型
            identifyFileType(file) {
                const mimeType = file.type;
                const extension = file.name.split('.').pop()?.toLowerCase();
                
                return {
                    mimeType,
                    extension,
                    supportedFormat: this.supportedFormats[mimeType] || extension?.toUpperCase() || 'UNKNOWN',
                    isSupported: !!this.supportedFormats[mimeType] || ['txt', 'md', 'csv', 'json', 'yml', 'yaml'].includes(extension)
                };
            }
            
            // 多格式文档处理
            async processMultiFormatDocument(file) {
                console.log('📄 Processing multi-format document:', file.name);
                
                const fileType = this.identifyFileType(file);
                
                if (!fileType.isSupported) {
                    throw new Error(`Unsupported file format: ${fileType.supportedFormat}`);
                }
                
                let extractedContent = '';
                let documentStructure = {};
                
                try {
                    // 统一文件处理流程 - 读取内容后用GPT-4o智能分析
                    console.log('📄 统一处理文件:', file.name, file.type);
                    
                    // 第一步：读取文件内容
                    if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {
                        // PDF文件需要特殊处理（目前使用文件名分析，可以集成PDF.js）
                        extractedContent = `PDF文件: ${file.name}`;
                        console.log('📄 PDF文件将使用文件名进行智能分析');
                    } else {
                        // 其他文件类型：TXT, MD, JSON, CSV等都尝试作为文本读取
                        try {
                            extractedContent = await this.readTextFile(file);
                            console.log('✅ 文件内容读取成功，长度:', extractedContent.length);
                        } catch (readError) {
                            console.log('❌ 文件内容读取失败，使用文件名分析:', readError.message);
                            extractedContent = `文件: ${file.name}`;
                        }
                    }
                    
                    // 第二步：使用GPT-4o进行智能内容分析
                    const intelligentAnalysis = await this.analyzeFileContent(file, extractedContent);
                    
                    // 第三步：构建统一的文档结构
                    documentStructure = {
                        type: 'intelligent_analysis',
                        concepts: intelligentAnalysis.concepts || [],
                        entities: intelligentAnalysis.entities || [],
                        relationships: intelligentAnalysis.relationships || [],
                        summary: intelligentAnalysis.content,
                        knowledgeTreeSuggestion: intelligentAnalysis.knowledgeTreeSuggestion,
                        confidence: intelligentAnalysis.confidence
                    };
                    
                    console.log(`📊 AI分析结果: ${intelligentAnalysis.entities?.length || 0}个实体, ${intelligentAnalysis.concepts?.length || 0}个概念, ${intelligentAnalysis.relationships?.length || 0}个关系`);
                    
                    // 更新extractedContent为分析结果
                    extractedContent = intelligentAnalysis.content;
                    
                    return {
                        fileType,
                        extractedContent,
                        documentStructure,
                        contentLength: extractedContent.length,
                        processingMethod: this.isConnected ? 'graphrag_service' : 'local_processing'
                    };
                    
                } catch (error) {
                    console.warn('⚠️ Document processing failed, using fallback:', error);
                    return this.generateDocumentFallback(file, fileType);
                }
            }
            
            // 读取文本文件
            async readTextFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = e => {
                        console.log('📄 File content extracted, length:', e.target.result?.length || 0);
                        resolve(e.target.result || '');
                    };
                    reader.onerror = e => {
                        console.error('❌ Failed to read file:', e);
                        reject(new Error('Failed to read file'));
                    };
                    reader.readAsText(file);
                });
            }
            
            // 分析文本结构
            analyzeTextStructure(content) {
                const lines = content.split('\n');
                const words = content.split(/\s+/).filter(w => w.length > 0);
                const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
                
                return {
                    lineCount: lines.length,
                    wordCount: words.length,
                    sentenceCount: sentences.length,
                    averageWordsPerSentence: Math.round(words.length / Math.max(sentences.length, 1)),
                    hasStructuredContent: this.detectStructuredContent(lines),
                    contentType: this.classifyTextContent(content)
                };
            }
            
            // LLM驱动的实体关系提取
            async extractEntitiesAndRelationships(file, documentAnalysis) {
                console.log('🤖 Extracting entities and relationships using LLM');
                
                if (this.isConnected) {
                    // 使用真实的GraphRAG服务
                    return await this.callGraphRAGEntityExtraction(file, documentAnalysis);
                } else {
                    // 使用多智能体系统进行实体关系提取
                    return await this.multiAgentEntityExtraction(file, documentAnalysis);
                }
            }
            
            // 多智能体实体提取
            async multiAgentEntityExtraction(file, documentAnalysis) {
                const [graphResult, hybridResult, researchResult] = await Promise.all([
                    this.graphAgent.extractEntitiesFromDocument(file, documentAnalysis).catch(e => ({ error: e.message })),
                    this.hybridAgent.extractEntitiesFromDocument(file, documentAnalysis).catch(e => ({ error: e.message })),
                    this.deepResearchAgent.extractEntitiesFromDocument(file, documentAnalysis).catch(e => ({ error: e.message }))
                ]);
                
                return this.fuseEntityExtractionResults([graphResult, hybridResult, researchResult]);
            }
            
            // 社区检测与摘要
            async performCommunityDetection(entityAnalysis) {
                console.log('🏘️ Performing community detection and summarization');
                
                const entities = entityAnalysis.entities || [];
                const relationships = entityAnalysis.relationships || [];
                
                // 构建图结构用于社区检测
                const graph = this.buildEntityGraph(entities, relationships);
                
                // 简化的社区检测算法（模拟Leiden算法）
                const communities = this.detectCommunitiesSimplified(graph);
                
                // 为每个社区生成摘要
                const communitySummaries = await this.generateCommunitySummaries(communities, entities);
                
                return {
                    totalCommunities: communities.length,
                    communities,
                    communitySummaries,
                    detectionMethod: 'simplified_leiden',
                    modularityScore: this.calculateModularity(graph, communities)
                };
            }
            
            // 知识树位置建议
            async suggestKnowledgeTreePosition(file, fullAnalysis) {
                console.log('🌳 Suggesting knowledge tree position', fullAnalysis);
                
                const suggestions = [];
                const entities = fullAnalysis.entityAnalysis?.entities || [];
                const communities = fullAnalysis.communityAnalysis?.communities || [];
                const documentAnalysis = fullAnalysis.documentAnalysis || {};
                const documentType = documentAnalysis.fileType?.supportedFormat;
                
                // 检查是否有AI分析结果
                const aiClassification = documentAnalysis.extractedContent?.aiClassification;
                if (aiClassification && aiClassification !== '文档/其他') {
                    console.log('🤖 Using AI classification:', aiClassification);
                    suggestions.push({
                        path: aiClassification,
                        confidence: 0.9,
                        reason: 'AI智能分析推荐',
                        category: 'ai_classification'
                    });
                }
                
                // 基于文档类型的建议
                if (documentType) {
                    suggestions.push(this.suggestByDocumentType(documentType, file.name));
                }
                
                // 基于文件名的智能建议
                const fileNameSuggestion = this.suggestByFileName(file.name);
                if (fileNameSuggestion) {
                    suggestions.push(fileNameSuggestion);
                }
                
                // 基于实体的建议
                if (entities.length > 0) {
                    suggestions.push(...this.suggestByEntities(entities));
                }
                
                // 基于社区的建议
                if (communities.length > 0) {
                    suggestions.push(...this.suggestByCommunities(communities));
                }
                
                // 如果没有任何建议，提供默认建议
                if (suggestions.length === 0) {
                    suggestions.push({
                        path: '文档/未分类',
                        confidence: 0.5,
                        reason: '默认分类位置',
                        category: 'default'
                    });
                }
                
                // 排序并选择最佳建议
                const rankedSuggestions = this.rankSuggestions(suggestions);
                
                console.log('📋 Generated suggestions:', rankedSuggestions);
                
                return {
                    primarySuggestion: rankedSuggestions[0],
                    alternatives: rankedSuggestions.slice(1, 4),
                    confidence: rankedSuggestions[0]?.confidence || 0.5,
                    reasoning: this.generatePositionReasoning(fullAnalysis, rankedSuggestions[0])
                };
            }
            
            // 基于文件名的建议
            suggestByFileName(fileName) {
                const lowerName = fileName.toLowerCase();
                
                if (lowerName.includes('需求') || lowerName.includes('requirement')) {
                    return {
                        path: '产品/需求文档',
                        confidence: 0.85,
                        reason: '文件名包含需求相关词汇',
                        category: 'filename_analysis'
                    };
                } else if (lowerName.includes('api') || lowerName.includes('接口')) {
                    return {
                        path: '技术/API文档',
                        confidence: 0.85,
                        reason: '文件名包含API相关词汇',
                        category: 'filename_analysis'
                    };
                } else if (lowerName.includes('insight') || lowerName.includes('分析')) {
                    return {
                        path: '分析/洞察报告',
                        confidence: 0.85,
                        reason: '文件名包含分析相关词汇',
                        category: 'filename_analysis'
                    };
                }
                
                return null;
            }
            
            async checkConnection() {
                try {
                    const response = await fetch(`${this.baseUrl}/auth/profile`, {
                        method: 'GET',
                        headers: {'Content-Type': 'application/json'}
                    });
                    this.isConnected = response.ok;
                    console.log('🔗 GraphRAG Service connection:', this.isConnected ? 'Connected' : 'Disconnected');
                } catch (error) {
                    this.isConnected = false;
                    console.log('⚠️ GraphRAG Service offline, using enhanced simulation');
                }
            }
            
            async analyzeContent(file, additionalContext = {}) {
                console.log('🤖 Starting Multi-Agent GraphRAG analysis for:', file.name);
                
                if (!this.isConnected) {
                    console.log('📡 GraphRAG service offline, using multi-agent enhanced analysis');
                    return this.multiAgentAnalysis(file, additionalContext);
                }
                
                try {
                    // 尝试连接真实的GraphRAG服务
                    const formData = new FormData();
                    formData.append('file', file);
                    formData.append('context', JSON.stringify(additionalContext));
                    
                    const response = await fetch(`${this.baseUrl}/graphrag/analyze`, {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        throw new Error(`GraphRAG API error: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    
                    // 即使有真实服务，也用多智能体系统增强结果
                    const enhancedResult = await this.enhanceWithMultiAgent(result, file, additionalContext);
                    return this.processGraphRAGResult(enhancedResult);
                    
                } catch (error) {
                    console.error('❌ GraphRAG service failed, falling back to multi-agent analysis:', error);
                    return this.multiAgentAnalysis(file, additionalContext);
                }
            }
            
            async multiAgentAnalysis(file, additionalContext = {}) {
                console.log('🚀 Running Multi-Agent Analysis Pipeline');
                
                // 并行运行多个智能体
                const [graphResult, hybridResult, researchResult] = await Promise.all([
                    this.graphAgent.analyze(file, additionalContext).catch(e => {
                        console.warn('GraphAgent failed:', e);
                        return { agent: 'GraphAgent', error: e.message };
                    }),
                    this.hybridAgent.analyze(file, additionalContext).catch(e => {
                        console.warn('HybridAgent failed:', e);
                        return { agent: 'HybridAgent', error: e.message };
                    }),
                    this.deepResearchAgent.analyze(file, additionalContext).catch(e => {
                        console.warn('DeepResearchAgent failed:', e);
                        return { agent: 'DeepResearchAgent', error: e.message };
                    })
                ]);
                
                // 融合多智能体结果
                const fusedResult = await this.fuseMultiAgentResults([graphResult, hybridResult, researchResult]);
                
                // 获取基础分析作为补充
                const basicAnalysis = await this.enhancedSimulatedAnalysis(file, additionalContext);
                
                // 应用图推理增强
                const enhancedWithGraphReasoning = await this.enhanceInsightsWithGraphReasoning({
                    ...basicAnalysis,
                    multiAgentAnalysis: {
                        graphAgent: graphResult,
                        hybridAgent: hybridResult,
                        deepResearchAgent: researchResult,
                        fusedInsights: fusedResult
                    }
                });
                
                return {
                    ...enhancedWithGraphReasoning,
                    isMultiAgent: true,
                    serviceStatus: this.isConnected ? 'connected' : 'multi-agent-fallback'
                };
            }
            
            async enhanceWithMultiAgent(baseResult, file, additionalContext) {
                console.log('🔥 Enhancing GraphRAG result with multi-agent analysis');
                
                // 运行多智能体增强
                const multiAgentEnhancement = await this.multiAgentAnalysis(file, additionalContext);
                
                // 融合基础结果和多智能体结果
                return {
                    ...baseResult,
                    multiAgentEnhancement: multiAgentEnhancement.multiAgentAnalysis,
                    enhancedInsights: this.combineInsights(baseResult, multiAgentEnhancement),
                    confidence: Math.max(baseResult.confidence || 0.8, multiAgentEnhancement.confidence || 0.85)
                };
            }
            
            async fuseMultiAgentResults(results) {
                console.log('🔄 Fusing multi-agent analysis results');
                
                const validResults = results.filter(r => !r.error);
                const failedAgents = results.filter(r => r.error);
                
                if (failedAgents.length > 0) {
                    console.warn(`${failedAgents.length} agents failed:`, failedAgents.map(r => r.agent));
                }
                
                // 提取所有智能体的洞察
                const allInsights = [];
                const allReasoning = [];
                let totalConfidence = 0;
                
                validResults.forEach(result => {
                    if (result.reasoning) allReasoning.push(...result.reasoning);
                    if (result.confidence) totalConfidence += result.confidence;
                    
                    // 提取特定类型的洞察
                    if (result.agent === 'GraphAgent') {
                        allInsights.push('图结构分析: 识别实体和关系网络');
                    } else if (result.agent === 'HybridAgent') {
                        allInsights.push('多模态融合: 综合文本、结构和语义分析');
                    } else if (result.agent === 'DeepResearchAgent') {
                        allInsights.push('深度研究: 领域知识提取和洞察生成');
                    }
                });
                
                const averageConfidence = validResults.length > 0 ? totalConfidence / validResults.length : 0.8;
                
                return {
                    fusedInsights: allInsights,
                    combinedReasoning: allReasoning,
                    agentConsensus: this.calculateAgentConsensus(validResults),
                    fusedConfidence: averageConfidence,
                    activeAgents: validResults.map(r => r.agent),
                    failedAgents: failedAgents.map(r => r.agent)
                };
            }
            
            calculateAgentConsensus(results) {
                // 计算智能体间的共识度
                const consensusTopics = new Set();
                
                results.forEach(result => {
                    if (result.entities) {
                        result.entities.forEach(entity => consensusTopics.add(entity.value));
                    }
                    if (result.concepts) {
                        result.concepts.forEach(concept => consensusTopics.add(concept));
                    }
                });
                
                return {
                    commonTopics: Array.from(consensusTopics),
                    consensusStrength: Math.min(results.length / 3, 1), // 最多3个智能体
                    agreementLevel: results.length > 1 ? 'high' : 'single-agent'
                };
            }
            
            combineInsights(baseResult, multiAgentResult) {
                const combined = [];
                
                if (baseResult.keyInsights) combined.push(...baseResult.keyInsights);
                if (multiAgentResult.multiAgentAnalysis?.fusedInsights?.fusedInsights) {
                    combined.push(...multiAgentResult.multiAgentAnalysis.fusedInsights.fusedInsights);
                }
                
                return Array.from(new Set(combined)); // 去重
            }
            
            async enhanceInsightsWithGraphReasoning(analysis) {
                console.log('🧠 Enhancing insights with graph-based reasoning');
                
                if (!analysis) return analysis;
                
                // 构建知识图谱推理增强器
                const graphReasoning = await this.performGraphBasedReasoning(analysis);
                
                // 增强原有洞察
                const enhancedInsights = await this.generateGraphEnhancedInsights(analysis, graphReasoning);
                
                // 生成推理路径
                const reasoningPaths = await this.generateReasoningPaths(analysis, graphReasoning);
                
                return {
                    ...analysis,
                    graphReasoning,
                    enhancedInsights,
                    reasoningPaths,
                    hasGraphReasoning: true
                };
            }
            
            async performGraphBasedReasoning(analysis) {
                // 基于图结构的推理
                const graphStructure = this.buildReasoningGraph(analysis);
                const centralConcepts = this.identifyCentralConcepts(graphStructure);
                const connectionPatterns = this.analyzeConnectionPatterns(graphStructure);
                const inferredRelationships = this.inferNewRelationships(graphStructure);
                
                return {
                    graphStructure,
                    centralConcepts,
                    connectionPatterns,
                    inferredRelationships,
                    reasoningScore: this.calculateReasoningScore(graphStructure)
                };
            }
            
            buildReasoningGraph(analysis) {
                const nodes = [];
                const edges = [];
                
                // 从实体创建节点
                if (analysis.entities) {
                    analysis.entities.forEach((entity, index) => {
                        nodes.push({
                            id: `entity_${index}`,
                            type: 'entity',
                            label: typeof entity === 'string' ? entity : entity.value || entity.label,
                            weight: 1
                        });
                    });
                }
                
                // 从概念创建节点
                if (analysis.concepts) {
                    analysis.concepts.forEach((concept, index) => {
                        nodes.push({
                            id: `concept_${index}`,
                            type: 'concept',
                            label: typeof concept === 'string' ? concept : concept.value || concept.label,
                            weight: 1.5
                        });
                    });
                }
                
                // 从关系创建边
                if (analysis.relationships) {
                    analysis.relationships.forEach((rel, index) => {
                        edges.push({
                            id: `rel_${index}`,
                            source: this.findNodeByLabel(nodes, rel.source),
                            target: this.findNodeByLabel(nodes, rel.target),
                            type: rel.type || 'RELATED_TO',
                            weight: rel.confidence || 0.7
                        });
                    });
                }
                
                return { nodes, edges };
            }
            
            identifyCentralConcepts(graphStructure) {
                const nodeConnectivity = {};
                
                // 计算节点连接度
                graphStructure.nodes.forEach(node => {
                    nodeConnectivity[node.id] = 0;
                });
                
                graphStructure.edges.forEach(edge => {
                    if (edge.source && edge.target) {
                        nodeConnectivity[edge.source] = (nodeConnectivity[edge.source] || 0) + 1;
                        nodeConnectivity[edge.target] = (nodeConnectivity[edge.target] || 0) + 1;
                    }
                });
                
                // 找出连接度最高的节点
                const sortedNodes = Object.entries(nodeConnectivity)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 5)
                    .map(([nodeId, connectivity]) => {
                        const node = graphStructure.nodes.find(n => n.id === nodeId);
                        return {
                            ...node,
                            connectivity,
                            centrality: connectivity / Math.max(graphStructure.edges.length, 1)
                        };
                    });
                
                return sortedNodes;
            }
            
            analyzeConnectionPatterns(graphStructure) {
                const patterns = [];
                
                // 分析集群模式
                const clusters = this.detectClusters(graphStructure);
                if (clusters.length > 1) {
                    patterns.push({
                        type: 'cluster_formation',
                        description: `识别了 ${clusters.length} 个概念集群`,
                        strength: clusters.length / Math.max(graphStructure.nodes.length / 3, 1)
                    });
                }
                
                // 分析桥接模式
                const bridges = this.detectBridgeNodes(graphStructure);
                if (bridges.length > 0) {
                    patterns.push({
                        type: 'bridge_connections',
                        description: `发现 ${bridges.length} 个桥接节点连接不同概念域`,
                        strength: bridges.length / Math.max(graphStructure.nodes.length, 1)
                    });
                }
                
                return patterns;
            }
            
            inferNewRelationships(graphStructure) {
                const inferred = [];
                
                // 基于共同邻居推断新关系
                graphStructure.nodes.forEach((node1, i) => {
                    graphStructure.nodes.forEach((node2, j) => {
                        if (i >= j) return;
                        
                        const commonNeighbors = this.findCommonNeighbors(node1, node2, graphStructure);
                        if (commonNeighbors.length >= 2) {
                            inferred.push({
                                source: node1.label,
                                target: node2.label,
                                type: 'INFERRED_RELATION',
                                confidence: Math.min(0.8, commonNeighbors.length / 3),
                                reason: `通过 ${commonNeighbors.length} 个共同连接推断`
                            });
                        }
                    });
                });
                
                return inferred.slice(0, 5); // 限制数量
            }
            
            async generateGraphEnhancedInsights(analysis, graphReasoning) {
                const insights = [];
                
                // 基于中心概念的洞察
                if (graphReasoning.centralConcepts?.length > 0) {
                    const topConcept = graphReasoning.centralConcepts[0];
                    insights.push({
                        type: 'centrality',
                        content: `"${topConcept.label}" 是核心概念，具有 ${topConcept.connectivity} 个连接`,
                        confidence: topConcept.centrality,
                        reasoning: '基于图中心性分析'
                    });
                }
                
                // 基于连接模式的洞察
                graphReasoning.connectionPatterns?.forEach(pattern => {
                    insights.push({
                        type: 'pattern',
                        content: pattern.description,
                        confidence: Math.min(pattern.strength, 0.9),
                        reasoning: '基于图连接模式分析'
                    });
                });
                
                // 基于推断关系的洞察
                if (graphReasoning.inferredRelationships?.length > 0) {
                    insights.push({
                        type: 'inference',
                        content: `推断出 ${graphReasoning.inferredRelationships.length} 个潜在关系`,
                        confidence: 0.75,
                        reasoning: '基于图推理分析'
                    });
                }
                
                return insights;
            }
            
            async generateReasoningPaths(analysis, graphReasoning) {
                const paths = [];
                
                // 生成从核心概念到其他概念的推理路径
                if (graphReasoning.centralConcepts?.length > 0) {
                    const centralNode = graphReasoning.centralConcepts[0];
                    
                    paths.push({
                        type: 'centrality_path',
                        steps: [
                            `识别核心概念: ${centralNode.label}`,
                            `分析连接度: ${centralNode.connectivity} 个直接连接`,
                            `计算中心性: ${Math.round(centralNode.centrality * 100)}% 中心度`,
                            `推断重要性: 在知识图谱中占据中心地位`
                        ],
                        confidence: centralNode.centrality
                    });
                }
                
                // 生成推理路径用于推断关系
                graphReasoning.inferredRelationships?.forEach((rel, index) => {
                    if (index < 2) { // 限制路径数量
                        paths.push({
                            type: 'inference_path',
                            steps: [
                                `发现概念: ${rel.source}`,
                                `发现概念: ${rel.target}`,
                                `分析共同连接`,
                                `推断关系: ${rel.type}`,
                                `置信度评估: ${Math.round(rel.confidence * 100)}%`
                            ],
                            confidence: rel.confidence
                        });
                    }
                });
                
                return paths;
            }
            
            // 辅助方法
            findNodeByLabel(nodes, label) {
                const node = nodes.find(n => n.label === label);
                return node ? node.id : null;
            }
            
            detectClusters(graphStructure) {
                // 简化的集群检测
                const visited = new Set();
                const clusters = [];
                
                graphStructure.nodes.forEach(node => {
                    if (!visited.has(node.id)) {
                        const cluster = this.exploreCluster(node, graphStructure, visited);
                        if (cluster.length > 1) {
                            clusters.push(cluster);
                        }
                    }
                });
                
                return clusters;
            }
            
            exploreCluster(startNode, graphStructure, visited, cluster = []) {
                if (visited.has(startNode.id)) return cluster;
                
                visited.add(startNode.id);
                cluster.push(startNode);
                
                // 找到相邻节点
                graphStructure.edges.forEach(edge => {
                    let neighborId = null;
                    if (edge.source === startNode.id) neighborId = edge.target;
                    else if (edge.target === startNode.id) neighborId = edge.source;
                    
                    if (neighborId && !visited.has(neighborId)) {
                        const neighbor = graphStructure.nodes.find(n => n.id === neighborId);
                        if (neighbor) {
                            this.exploreCluster(neighbor, graphStructure, visited, cluster);
                        }
                    }
                });
                
                return cluster;
            }
            
            detectBridgeNodes(graphStructure) {
                // 检测桥接节点（连接不同集群的节点）
                const bridges = [];
                
                graphStructure.nodes.forEach(node => {
                    const neighbors = this.getNeighbors(node, graphStructure);
                    if (neighbors.length >= 3) {
                        // 简化判断：连接数多的节点可能是桥接节点
                        bridges.push(node);
                    }
                });
                
                return bridges;
            }
            
            getNeighbors(node, graphStructure) {
                const neighbors = [];
                graphStructure.edges.forEach(edge => {
                    if (edge.source === node.id) {
                        const neighbor = graphStructure.nodes.find(n => n.id === edge.target);
                        if (neighbor) neighbors.push(neighbor);
                    } else if (edge.target === node.id) {
                        const neighbor = graphStructure.nodes.find(n => n.id === edge.source);
                        if (neighbor) neighbors.push(neighbor);
                    }
                });
                return neighbors;
            }
            
            findCommonNeighbors(node1, node2, graphStructure) {
                const neighbors1 = this.getNeighbors(node1, graphStructure);
                const neighbors2 = this.getNeighbors(node2, graphStructure);
                
                return neighbors1.filter(n1 => 
                    neighbors2.some(n2 => n1.id === n2.id)
                );
            }
            
            calculateReasoningScore(graphStructure) {
                const nodeCount = graphStructure.nodes.length;
                const edgeCount = graphStructure.edges.length;
                const density = nodeCount > 1 ? edgeCount / (nodeCount * (nodeCount - 1) / 2) : 0;
                
                return Math.min(0.95, 0.5 + density * 0.4 + (nodeCount / 10) * 0.1);
            }
            
            // 添加缺失的辅助方法
            detectStructuredContent(lines) {
                // 检测是否为结构化内容（如代码、配置文件等）
                const structureIndicators = lines.filter(line => 
                    line.trim().match(/^[\s]*[{}\[\]()]/g) || 
                    line.includes(':') || 
                    line.includes('=') || 
                    line.startsWith('#') ||
                    line.startsWith('-') ||
                    line.startsWith('*')
                );
                return structureIndicators.length / Math.max(lines.length, 1) > 0.3;
            }
            
            classifyTextContent(content) {
                const lowercaseContent = content.toLowerCase();
                
                if (lowercaseContent.includes('import') || lowercaseContent.includes('function') || lowercaseContent.includes('class')) {
                    return 'code';
                } else if (lowercaseContent.includes('# ') || lowercaseContent.includes('## ')) {
                    return 'markdown';
                } else if (lowercaseContent.includes('abstract') || lowercaseContent.includes('introduction') || lowercaseContent.includes('conclusion')) {
                    return 'academic_paper';
                } else if (lowercaseContent.includes('api') || lowercaseContent.includes('endpoint') || lowercaseContent.includes('request')) {
                    return 'api_documentation';
                } else {
                    return 'general_text';
                }
            }
            
            analyzeJSONStructure(content) {
                try {
                    const json = JSON.parse(content);
                    return {
                        isValidJSON: true,
                        objectCount: this.countJSONObjects(json),
                        depth: this.calculateJSONDepth(json),
                        hasArrays: this.hasArrays(json),
                        topLevelKeys: Object.keys(json || {})
                    };
                } catch (error) {
                    return { isValidJSON: false, error: error.message };
                }
            }
            
            analyzeCSVStructure(content) {
                const lines = content.split('\n').filter(line => line.trim());
                const firstLine = lines[0] || '';
                const columnCount = firstLine.split(',').length;
                
                return {
                    rowCount: lines.length,
                    columnCount,
                    hasHeader: this.detectCSVHeader(firstLine),
                    estimatedDataTypes: this.detectCSVDataTypes(lines.slice(1, 6))
                };
            }
            
            async processComplexDocument(file) {
                // 对于复杂文档格式，尝试调用GraphRAG服务
                if (this.isConnected) {
                    try {
                        const formData = new FormData();
                        formData.append('file', file);
                        
                        const response = await fetch(`${this.baseUrl}/content/input`, {
                            method: 'POST',
                            body: formData
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            return {
                                content: result.extracted_text || '',
                                structure: result.document_structure || {}
                            };
                        }
                    } catch (error) {
                        console.warn('GraphRAG document processing failed:', error);
                    }
                }
                
                // 回退到基础处理
                return this.generateDocumentFallback(file, this.identifyFileType(file));
            }
            
            generateDocumentFallback(file, fileType) {
                return {
                    fileType,
                    extractedContent: `[${fileType.supportedFormat}文件内容提取失败，使用文件名进行基础分析]`,
                    documentStructure: {
                        fileName: file.name,
                        fileSize: file.size,
                        analysisType: 'fallback'
                    },
                    contentLength: 0,
                    processingMethod: 'fallback'
                };
            }
            
            async callGraphRAGEntityExtraction(file, documentAnalysis) {
                try {
                    const response = await fetch(`${this.baseUrl}/graphrag/analyze`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            content: documentAnalysis.extractedContent,
                            file_info: {
                                name: file.name,
                                type: documentAnalysis.fileType.supportedFormat
                            }
                        })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        return {
                            entities: result.entities || [],
                            relationships: result.relationships || [],
                            extractionMethod: 'graphrag_service'
                        };
                    }
                } catch (error) {
                    console.warn('GraphRAG entity extraction failed:', error);
                }
                
                // 回退到多智能体提取
                return this.multiAgentEntityExtraction(file, documentAnalysis);
            }
            
            fuseEntityExtractionResults(results) {
                const validResults = results.filter(r => !r.error);
                const allEntities = [];
                const allRelationships = [];
                
                validResults.forEach(result => {
                    if (result.entities) allEntities.push(...result.entities);
                    if (result.relationships) allRelationships.push(...result.relationships);
                });
                
                return {
                    entities: this.deduplicateEntities(allEntities),
                    relationships: this.deduplicateRelationships(allRelationships),
                    extractionMethod: 'multi_agent_fusion',
                    sourceAgents: validResults.map(r => r.agent || 'unknown')
                };
            }
            
            buildEntityGraph(entities, relationships) {
                return {
                    nodes: entities.map((entity, index) => ({
                        id: index,
                        label: typeof entity === 'string' ? entity : entity.value || entity.label,
                        type: typeof entity === 'object' ? entity.type : 'ENTITY'
                    })),
                    edges: relationships.map((rel, index) => ({
                        id: index,
                        source: this.findEntityIndex(entities, rel.source),
                        target: this.findEntityIndex(entities, rel.target),
                        type: rel.type || 'RELATED_TO'
                    })).filter(edge => edge.source !== -1 && edge.target !== -1)
                };
            }
            
            detectCommunitiesSimplified(graph) {
                // 简化的社区检测算法
                const communities = [];
                const visited = new Set();
                
                graph.nodes.forEach(node => {
                    if (!visited.has(node.id)) {
                        const community = this.expandCommunity(node, graph, visited);
                        if (community.length > 1) {
                            communities.push(community);
                        }
                    }
                });
                
                return communities;
            }
            
            async generateCommunitySummaries(communities, entities) {
                return communities.map((community, index) => ({
                    communityId: index,
                    size: community.length,
                    entities: community.map(nodeId => {
                        const entity = entities[nodeId];
                        return typeof entity === 'string' ? entity : entity.value || entity.label;
                    }),
                    summary: `社区 ${index + 1}: 包含 ${community.length} 个相关实体`,
                    theme: this.inferCommunityTheme(community, entities)
                }));
            }
            
            calculateModularity(graph, communities) {
                // 简化的模块度计算
                if (communities.length <= 1) return 0;
                return Math.min(0.8, communities.length / Math.max(graph.nodes.length / 3, 1));
            }
            
            suggestByDocumentType(documentType, fileName) {
                const suggestions = {
                    'TXT': { path: '文档/文本文件', confidence: 0.6 },
                    'MD': { path: '文档/Markdown', confidence: 0.8 },
                    'PDF': { path: '文档/PDF文档', confidence: 0.7 },
                    'JSON': { path: '数据/配置文件', confidence: 0.8 },
                    'CSV': { path: '数据/数据表', confidence: 0.9 },
                    'DOCX': { path: '文档/Word文档', confidence: 0.8 }
                };
                
                const suggestion = suggestions[documentType] || { path: '其他/未分类', confidence: 0.4 };
                
                return {
                    ...suggestion,
                    reason: `基于文档类型 ${documentType} 的建议`,
                    category: 'document_type'
                };
            }
            
            suggestByEntities(entities) {
                const suggestions = [];
                const entityTypes = {};
                
                entities.forEach(entity => {
                    const type = typeof entity === 'object' ? entity.type : 'GENERAL';
                    entityTypes[type] = (entityTypes[type] || 0) + 1;
                });
                
                Object.entries(entityTypes).forEach(([type, count]) => {
                    if (count >= 2) {
                        const path = this.getPathByEntityType(type);
                        suggestions.push({
                            path,
                            confidence: Math.min(0.9, 0.6 + (count * 0.1)),
                            reason: `检测到 ${count} 个 ${type} 类型实体`,
                            category: 'entity_based'
                        });
                    }
                });
                
                return suggestions;
            }
            
            suggestByCommunities(communities) {
                return communities.map((community, index) => ({
                    path: `知识图谱/社区${index + 1}`,
                    confidence: Math.min(0.8, 0.5 + (community.size * 0.05)),
                    reason: `基于社区检测结果，包含 ${community.size} 个实体`,
                    category: 'community_based'
                }));
            }
            
            rankSuggestions(suggestions) {
                return suggestions
                    .sort((a, b) => (b.confidence || 0) - (a.confidence || 0))
                    .slice(0, 5);
            }
            
            generatePositionReasoning(fullAnalysis, primarySuggestion) {
                if (!primarySuggestion) return '无法生成位置建议';
                
                const reasons = [primarySuggestion.reason];
                
                if (fullAnalysis.entityAnalysis?.entities?.length > 0) {
                    reasons.push(`包含 ${fullAnalysis.entityAnalysis.entities.length} 个实体`);
                }
                
                if (fullAnalysis.communityAnalysis?.totalCommunities > 0) {
                    reasons.push(`识别了 ${fullAnalysis.communityAnalysis.totalCommunities} 个概念社区`);
                }
                
                return reasons.join('；');
            }
            
            calculateOverallConfidence(analyses) {
                const confidences = analyses
                    .map(analysis => analysis.confidence || 0.5)
                    .filter(c => c > 0);
                
                if (confidences.length === 0) return 0.5;
                
                return confidences.reduce((sum, c) => sum + c, 0) / confidences.length;
            }
            
            async generateFallbackAnalysis(file) {
                return {
                    fileName: file.name,
                    basicInfo: `基础分析: ${file.name} (${this.formatFileSize(file.size)})`,
                    suggestedPath: '其他/未分类',
                    confidence: 0.3
                };
            }
            
            // 更多辅助方法
            countJSONObjects(obj, count = 0) {
                if (typeof obj === 'object' && obj !== null) {
                    count++;
                    Object.values(obj).forEach(value => {
                        count = this.countJSONObjects(value, count);
                    });
                }
                return count;
            }
            
            calculateJSONDepth(obj, depth = 0) {
                if (typeof obj === 'object' && obj !== null) {
                    const depths = Object.values(obj).map(value => this.calculateJSONDepth(value, depth + 1));
                    return Math.max(depth, ...depths);
                }
                return depth;
            }
            
            hasArrays(obj) {
                return Array.isArray(obj) || (typeof obj === 'object' && obj !== null && Object.values(obj).some(v => this.hasArrays(v)));
            }
            
            detectCSVHeader(firstLine) {
                return !/^\d/.test(firstLine) && firstLine.includes(',');
            }
            
            detectCSVDataTypes(dataLines) {
                return ['string', 'number', 'mixed'];
            }
            
            deduplicateEntities(entities) {
                const seen = new Set();
                return entities.filter(entity => {
                    const key = typeof entity === 'string' ? entity : entity.value || entity.label;
                    if (seen.has(key)) return false;
                    seen.add(key);
                    return true;
                });
            }
            
            deduplicateRelationships(relationships) {
                const seen = new Set();
                return relationships.filter(rel => {
                    const key = `${rel.source}-${rel.type}-${rel.target}`;
                    if (seen.has(key)) return false;
                    seen.add(key);
                    return true;
                });
            }
            
            findEntityIndex(entities, entityLabel) {
                return entities.findIndex(entity => 
                    (typeof entity === 'string' ? entity : entity.value || entity.label) === entityLabel
                );
            }
            
            expandCommunity(startNode, graph, visited, community = []) {
                if (visited.has(startNode.id)) return community;
                
                visited.add(startNode.id);
                community.push(startNode.id);
                
                // 找到所有相邻节点
                graph.edges.forEach(edge => {
                    let neighborId = null;
                    if (edge.source === startNode.id) neighborId = edge.target;
                    else if (edge.target === startNode.id) neighborId = edge.source;
                    
                    if (neighborId !== null && !visited.has(neighborId)) {
                        const neighbor = graph.nodes.find(n => n.id === neighborId);
                        if (neighbor) {
                            this.expandCommunity(neighbor, graph, visited, community);
                        }
                    }
                });
                
                return community;
            }
            
            inferCommunityTheme(community, entities) {
                // 基于社区中的实体推断主题
                const themes = ['技术', '业务', '数据', '流程', '概念'];
                return themes[community.length % themes.length];
            }
            
            getPathByEntityType(type) {
                const pathMapping = {
                    'TECH': '技术/技术栈',
                    'PERSON': '团队/人员',
                    'ORG': '组织/机构',
                    'CONCEPT': '概念/理论',
                    'LOCATION': '地理/位置',
                    'EVENT': '事件/活动'
                };
                
                return pathMapping[type] || '其他/实体';
            }
            
            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            
            // PDF文件处理
            async processPDFFile(file) {
                console.log('📄 Processing PDF file - using intelligent content analysis');
                
                // 由于PDF需要专门的解析库，我们使用智能回退策略
                // 基于文件名和大小进行内容推断和模拟真实内容
                const fileName = file.name.toLowerCase();
                const fileSize = file.size;
                
                // 直接使用智能内容分析
                const aiAnalyzedContent = await this.analyzeFileContent(file, `PDF文件: ${fileName}`);
                
                return aiAnalyzedContent;
            }
            
            // 📄 使用PDF.js提取真实PDF内容
            async extractPDFText(file) {
                console.log('🔥 使用PDF.js提取PDF文本内容');
                
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    
                    reader.onload = async function(e) {
                        try {
                            const arrayBuffer = e.target.result;
                            
                            // 配置PDF.js worker
                            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                            
                            // 加载PDF文档
                            const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                            console.log('📖 PDF加载成功，总页数:', pdf.numPages);
                            
                            let fullText = '';
                            
                            // 提取所有页面的文本
                            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                                const page = await pdf.getPage(pageNum);
                                const textContent = await page.getTextContent();
                                
                                const pageText = textContent.items.map(item => item.str).join(' ');
                                fullText += pageText + '\n';
                                
                                console.log(`📄 页面 ${pageNum}/${pdf.numPages} 提取完成，本页字符数: ${pageText.length}`);
                            }
                            
                            console.log('✅ PDF全文提取完成，总字符数:', fullText.length);
                            resolve(fullText.trim());
                            
                        } catch (error) {
                            console.error('❌ PDF解析失败:', error);
                            reject(error);
                        }
                    };
                    
                    reader.onerror = () => reject(new Error('文件读取失败'));
                    reader.readAsArrayBuffer(file);
                });
            }
            
            // PDF文本提取专用于GraphRAG (复用主要的PDF解析逻辑)
            async extractPDFTextForGraphRAG(file) {
                try {
                    console.log('📖 为GraphRAG提取PDF文本:', file.name);
                    
                    const arrayBuffer = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = e => resolve(e.target.result);
                        reader.onerror = reject;
                        reader.readAsArrayBuffer(file);
                    });
                    
                    const uint8Array = new Uint8Array(arrayBuffer);
                    let text = '';
                    
                    // 简单的PDF文本提取（查找文本流）
                    const decoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: false });
                    const pdfString = decoder.decode(uint8Array);
                    
                    // 查找文本内容的简单正则表达式
                    const textMatches = pdfString.match(/BT\s+.*?\s+ET/gs);
                    if (textMatches) {
                        for (const match of textMatches) {
                            // 提取括号内的文本
                            const textContent = match.match(/\((.*?)\)/g);
                            if (textContent) {
                                textContent.forEach(t => {
                                    text += t.replace(/[()]/g, '') + ' ';
                                });
                            }
                        }
                    }
                    
                    // 如果简单提取失败，尝试查找可读文本
                    if (text.length < 50) {
                        console.log('⚠️ 尝试备用文本提取方法');
                        const lines = pdfString.split('\n');
                        for (const line of lines) {
                            if (line.length > 10 && 
                                !line.match(/^[<>%\d\s]+$/) &&
                                !line.includes('obj') &&
                                !line.includes('endobj') &&
                                !line.includes('stream') &&
                                !line.includes('endstream')) {
                                
                                const cleanLine = line.replace(/[^\w\s\u4e00-\u9fff.,!?;:()\-]/g, '').trim();
                                if (cleanLine.length > 5) {
                                    text += cleanLine + '\n';
                                }
                            }
                        }
                    }
                    
                    console.log(`📄 GraphRAG PDF文本提取完成: ${text.length} 字符`);
                    return text.trim();
                    
                } catch (error) {
                    console.error('❌ GraphRAG PDF文本提取失败:', error);
                    throw error;
                }
            }
            
            // 🚀 使用真正的GraphRAG Agent服务
            async useGraphRAGAgent(file) {
                // 🚨 DEBUG: GraphRAG Agent 调用入口追踪
                console.log('🚨 DEBUG: ======= useGraphRAGAgent 函数被调用 =======');
                console.log('🚨 DEBUG: 准备发送File对象到GraphRAG后端服务');
                console.log('🚨 DEBUG: - 服务连接状态:', this.isConnected);
                console.log('🚨 DEBUG: - 后端URL:', this.graphRAGUrl);
                
                // 🚨 DEBUG: 详细分析传入的File对象
                console.log('🚨 DEBUG: 传入File对象详细分析:');
                console.log('🚨 DEBUG: - File名称:', file.name);
                console.log('🚨 DEBUG: - File大小:', file.size, '字节');
                console.log('🚨 DEBUG: - File类型:', file.type);
                console.log('🚨 DEBUG: - 最后修改时间:', file.lastModified ? new Date(file.lastModified) : 'N/A');
                
                // 🚨 DEBUG: 检查自定义属性
                if (file.sourceUrl) {
                    console.log('🚨 DEBUG: - sourceUrl存在:', file.sourceUrl);
                    if (file.sourceUrl.includes('youtube.com') || file.sourceUrl.includes('youtu.be')) {
                        console.log('🚨 DEBUG: ⚠️  关键：这是YouTube URL生成的File对象！');
                        console.log('🚨 DEBUG: ⚠️  期望：GraphRAG后端应该检测到这是视频URL并使用视频提取管道');
                        console.log('🚨 DEBUG: ⚠️  期望结果：2694字符的视频转录内容');
                        console.log('🚨 DEBUG: ⚠️  问题场景：如果返回98字符说明被错误当作HTML文件处理');
                    }
                }
                
                // 🚨 DEBUG: 尝试预读文件内容
                try {
                    const fileContent = await file.text();
                    console.log('🚨 DEBUG: - 文件实际内容长度:', fileContent.length);
                    console.log('🚨 DEBUG: - 文件内容预览（前300字符）:');
                    console.log('🚨 DEBUG:   "' + fileContent.substring(0, 300) + '"');
                    
                    // 检查内容特征
                    const isUrl = fileContent.trim().startsWith('http') && fileContent.length < 200;
                    const isHtml = fileContent.includes('<html') || fileContent.includes('<!DOCTYPE');
                    const isYouTubeGeneric = fileContent.includes('关于 新闻 版权');
                    
                    console.log('🚨 DEBUG: - 内容类型分析:');
                    console.log('🚨 DEBUG:   * 是URL: ', isUrl);
                    console.log('🚨 DEBUG:   * 是HTML: ', isHtml);
                    console.log('🚨 DEBUG:   * 是YouTube通用页面: ', isYouTubeGeneric);
                    
                    if (isYouTubeGeneric) {
                        console.log('🚨 DEBUG: ⚠️  发现问题：File内容是YouTube通用页面，不是视频转录！');
                        console.log('🚨 DEBUG: ⚠️  这说明URL被错误处理为HTML页面提取');
                    }
                } catch (readError) {
                    console.log('🚨 DEBUG: - 无法读取文件内容:', readError);
                }
                
                console.log('🤖 调用GraphRAG Agent进行多格式文档处理');
                console.log('📄 文件信息:', {
                    name: file.name,
                    type: file.type,
                    size: file.size
                });
                
                try {
                    // 🔥 直接发送原始文件给GraphRAG，让它处理
                    console.log('🚀 直接发送文件给GraphRAG Agent处理');
                    const fileToSend = file;
                    
                    // 创建FormData来发送文件
                    const formData = new FormData();
                    formData.append('file', fileToSend);
                    formData.append('analysis_type', 'comprehensive'); // 综合分析
                    formData.append('extract_entities', 'true'); // 实体提取
                    formData.append('extract_relationships', 'true'); // 关系提取
                    formData.append('community_detection', 'true'); // 社区检测
                    
                    console.log('📋 发送到GraphRAG的参数:', {
                        fileName: fileToSend.name,
                        fileType: fileToSend.type,
                        fileSize: fileToSend.size,
                        analysisType: 'comprehensive'
                    });
                    
                    // 调用GraphRAG Agent的分析API，添加超时控制
                    console.log(`🌐 正在调用 ${this.baseUrl}/analyze`);
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30秒超时
                    
                    const response = await fetch(`${this.baseUrl}/graphrag/analyze`, {
                        method: 'POST',
                        body: formData,
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    console.log(`📡 GraphRAG API响应状态: ${response.status}`);
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('❌ GraphRAG API错误响应:', errorText);
                        throw new Error(`GraphRAG API error: ${response.status} - ${errorText}`);
                    }
                    
                    const graphRAGResult = await response.json();
                    
                    // 🚨 DEBUG: GraphRAG 后端响应详细分析
                    console.log('🚨 DEBUG: ======= GraphRAG后端响应详细分析 =======');
                    console.log('🚨 DEBUG: 响应状态码:', response.status);
                    console.log('🚨 DEBUG: 响应完整对象:', graphRAGResult);
                    
                    // 分析响应结构
                    console.log('🚨 DEBUG: 响应结构分析:');
                    console.log('🚨 DEBUG: - status:', graphRAGResult.status);
                    console.log('🚨 DEBUG: - analysis存在:', !!graphRAGResult.analysis);
                    console.log('🚨 DEBUG: - extraction_method:', graphRAGResult.extraction_method);
                    console.log('🚨 DEBUG: - platform:', graphRAGResult.platform);
                    console.log('🚨 DEBUG: - extraction_type:', graphRAGResult.extraction_type);
                    
                    if (graphRAGResult.analysis) {
                        const analysis = graphRAGResult.analysis;
                        console.log('🚨 DEBUG: analysis对象详细信息:');
                        console.log('🚨 DEBUG: - content长度:', analysis.content?.length || 0);
                        console.log('🚨 DEBUG: - content预览（前200字符）:', analysis.content?.substring(0, 200) || 'N/A');
                        console.log('🚨 DEBUG: - entities数量:', analysis.entities?.length || 0);
                        console.log('🚨 DEBUG: - concepts数量:', analysis.concepts?.length || 0);
                        console.log('🚨 DEBUG: - relationships数量:', analysis.relationships?.length || 0);
                        console.log('🚨 DEBUG: - confidence:', analysis.confidence);
                        
                        // 检查内容质量
                        if (analysis.content) {
                            const isGeneric = analysis.content.includes('关于 新闻 版权');
                            const isShort = analysis.content.length < 200;
                            const hasVideoContent = analysis.content.includes('♪') || 
                                                  analysis.content.includes('lyrics') || 
                                                  analysis.content.includes('transcript');
                            
                            console.log('🚨 DEBUG: 内容质量分析:');
                            console.log('🚨 DEBUG: - 是通用YouTube页面:', isGeneric);
                            console.log('🚨 DEBUG: - 内容过短 (<200):', isShort);
                            console.log('🚨 DEBUG: - 包含视频内容标识:', hasVideoContent);
                            
                            if (isGeneric) {
                                console.log('🚨 DEBUG: ⚠️  问题确认：返回的是YouTube通用页面内容，不是视频转录！');
                                console.log('🚨 DEBUG: ⚠️  这表明后端没有正确检测到这是视频URL');
                            }
                            
                            if (hasVideoContent) {
                                console.log('🚨 DEBUG: ✅ 好消息：检测到视频内容，系统工作正常！');
                            }
                        }
                        
                        // 检查文件信息
                        if (analysis.fileInfo) {
                            console.log('🚨 DEBUG: fileInfo对象:');
                            console.log('🚨 DEBUG: - filename:', analysis.fileInfo.filename);
                            console.log('🚨 DEBUG: - type:', analysis.fileInfo.type);
                            console.log('🚨 DEBUG: - source_url:', analysis.fileInfo.source_url);
                            console.log('🚨 DEBUG: - textLength:', analysis.fileInfo.textLength);
                        }
                    }
                    
                    console.log('🚨 DEBUG: ======= GraphRAG响应分析完成 =======');
                    console.log('✅ GraphRAG Agent分析完成!');
                    console.log('🔍 完整分析结果:', JSON.stringify(graphRAGResult, null, 2));
                    
                    // 🎯 确认这是真正的GraphRAG分析
                    if (graphRAGResult.analysis) {
                        console.log('🧠 AI分析内容:', graphRAGResult.analysis.content?.substring(0, 100) + '...');
                        console.log('🏷️ 提取的概念:', graphRAGResult.analysis.concepts);
                        console.log('👥 识别的实体:', graphRAGResult.analysis.entities);
                        console.log('📍 建议位置:', graphRAGResult.analysis.knowledgeTreeSuggestion);
                        console.log('🎯 置信度:', graphRAGResult.analysis.confidence);
                    }
                    
                    // 转换GraphRAG结果为我们的格式 - 适配新API结构
                    const analysis = graphRAGResult.analysis || {};
                    const fileInfo = analysis.fileInfo || {};
                    
                    return {
                        fileName: file.name,
                        fileType: fileInfo.type || this.identifyFileType(file),
                        fileSize: fileInfo.size || file.size,
                        analysisTimestamp: new Date().toISOString(),
                        extractedContent: analysis.content || '文档分析完成',
                        concepts: analysis.concepts || [],
                        entities: analysis.entities || [],
                        relationships: analysis.relationships || [],
                        communities: analysis.communities || [],
                        positionSuggestion: {
                            primarySuggestion: {
                                path: analysis.knowledgeTreeSuggestion || this.mapGraphRAGToKnowledgeTree(analysis),
                                confidence: analysis.confidence || 0.88
                            },
                            alternatives: this.generateAlternativesFromGraphRAG(analysis)
                        },
                        processingStage: 'completed',
                        confidence: analysis.confidence || 0.88,
                        graphData: analysis.graph_data,
                        isGraphRAGAnalysis: true
                    };
                    
                } catch (error) {
                    console.error('❌ GraphRAG Agent调用失败:', error);
                    
                    // 如果是超时或网络错误，使用备用分析
                    if (error.name === 'AbortError') {
                        console.log('⏱️ GraphRAG API调用超时，使用备用分析');
                    } else {
                        console.log('🔄 GraphRAG API调用失败，使用备用分析');
                    }
                    
                    // 回退到内置分析
                    this.isConnected = false;
                    return this.fallbackAnalysis(file);
                }
            }
            
            // 🔄 备用分析方法（当GraphRAG失败时使用）
            async fallbackAnalysis(file) {
                console.log('🔄 使用备用分析方法:', file.name);
                
                try {
                    // 尝试使用内置AI分析
                    const content = await this.extractFileContent(file);
                    const analysis = await this.analyzeFileContent(file, content);
                    
                    if (analysis) {
                        console.log('✅ 备用分析成功');
                        return analysis;
                    }
                } catch (error) {
                    console.log('❌ 备用AI分析也失败:', error.message);
                }
                
                // 最后回退到基本分析
                console.log('🔧 使用基本文件分析');
                return {
                    fileName: file.name,
                    fileType: this.identifyFileType(file),
                    fileSize: file.size,
                    analysisTimestamp: new Date().toISOString(),
                    extractedContent: `这是文件 "${file.name}" 的基本信息。文件大小: ${(file.size/1024).toFixed(1)} KB`,
                    concepts: ['文档', '已上传'],
                    entities: [file.name.split('.')[0]],
                    relationships: [],
                    communities: [],
                    positionSuggestion: {
                        primarySuggestion: {
                            path: `文档管理/${this.identifyFileType(file).supportedFormat}文件`,
                            confidence: 0.6
                        },
                        alternatives: []
                    },
                    processingStage: 'completed',
                    confidence: 0.6,
                    isGraphRAGAnalysis: false
                };
            }
            
            // 将GraphRAG结果映射到知识树位置
            mapGraphRAGToKnowledgeTree(analysis) {
                // 优先使用API返回的knowledgeTreeSuggestion
                if (analysis.knowledgeTreeSuggestion) {
                    return analysis.knowledgeTreeSuggestion;
                }
                
                // 基于概念分析来建议位置
                if (analysis.concepts && analysis.concepts.length > 0) {
                    const primaryConcept = analysis.concepts[0];
                    return `概念知识/${primaryConcept}`;
                }
                
                // 基于实体分析来建议位置  
                if (analysis.entities && analysis.entities.length > 0) {
                    const primaryEntity = analysis.entities[0];
                    return `实体知识/${primaryEntity}`;
                }
                
                return '智能分类/GraphRAG分析';
            }
            
            // 从GraphRAG结果生成替代建议
            generateAlternativesFromGraphRAG(graphRAGResult) {
                const alternatives = [];
                
                if (graphRAGResult.communities) {
                    graphRAGResult.communities.slice(1, 4).forEach(community => {
                        alternatives.push({
                            path: `${community.category}/${community.subcategory}`,
                            confidence: community.confidence || 0.7,
                            reason: `基于社区检测: ${community.description}`
                        });
                    });
                }
                
                return alternatives;
            }
            
            // 智能内容分析 - 直接基于文件内容
            async analyzeFileContent(file, content) {
                console.log('🧠 智能分析文件内容:', file.name, '内容长度:', content ? content.length : 0);
                
                try {
                    // 使用GPT-4o进行真实内容分析
                    const analysis = await this.callOpenAIWithContent(file.name, content);
                    if (analysis) {
                        console.log('✅ OpenAI分析成功');
                        return analysis;
                    }
                } catch (error) {
                    console.log('❌ AI分析失败，使用智能规则引擎:', error.message);
                }
                
                // 备用方案：基于真实内容的智能分析
                return this.smartContentAnalysis(file.name, content);
            }
            
            // 基于真实内容的OpenAI分析
            async callOpenAIWithContent(fileName, content) {
                const apiKey = process.env.OPENAI_API_KEY || 'your-openai-api-key-here';
                
                if (!apiKey) {
                    throw new Error('No OpenAI API key configured');
                }
                
                // 增加内容提取长度以获得更丰富的分析
                const contentSample = content ? content.substring(0, 6000) : '';
                console.log(`📄 处理内容长度: ${contentSample.length} 字符`);
                
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [{
                            role: 'system',
                            content: '你是一个专业的知识图谱构建专家，专门从文档中提取丰富的实体、概念和关系。请返回详细的结构化分析结果。'
                        }, {
                            role: 'user',
                            content: `请对以下文档进行深度知识图谱分析：

文档名称: ${fileName}
文档内容: 
${contentSample}

分析要求：
1. 提取技术概念、工具、框架、方法论等专业实体
2. 识别业务概念、流程、角色、功能模块等业务实体  
3. 发现概念间的层次关系、依赖关系、关联关系
4. 提供详细的内容摘要和分析
5. 特别关注：系统架构、技术栈、业务流程、产品功能等核心要素

请返回JSON格式（无markdown包装）：
{
  "content": "详细的500-800字内容分析摘要，包含技术架构、业务流程、关键特性等",
  "concepts": [
    "核心业务概念1", "技术架构概念2", "方法论概念3", "工具框架4", "流程概念5",
    "系统模块6", "数据概念7", "用户体验8", "性能优化9", "安全机制10"
  ],
  "entities": [
    "具体技术工具1", "业务实体2", "系统组件3", "数据表4", "API接口5",
    "用户角色6", "功能模块7", "算法模型8", "平台服务9", "标准规范10"
  ],
  "relationships": [
    {"source": "实体A", "target": "实体B", "type": "contains", "description": "包含关系"},
    {"source": "概念C", "target": "概念D", "type": "implements", "description": "实现关系"},
    {"source": "工具E", "target": "流程F", "type": "supports", "description": "支持关系"}
  ],
  "knowledgeTreeSuggestion": "技术架构/智能内容工作流/产品需求管理",
  "confidence": 0.9
}`
                        }],
                        temperature: 0.2,
                        max_tokens: 2000
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`OpenAI API error: ${response.status}`);
                }
                
                const data = await response.json();
                const aiResponse = data.choices[0].message.content;
                
                console.log('🤖 OpenAI原始响应:', aiResponse);
                console.log('📏 响应长度:', aiResponse.length);
                console.log('🔍 响应前50字符:', aiResponse.substring(0, 50));
                
                try {
                    // 清理响应内容 - 移除可能的markdown代码块标记
                    let cleanResponse = aiResponse.trim();
                    if (cleanResponse.startsWith('```json')) {
                        cleanResponse = cleanResponse.replace(/^```json\s*/, '').replace(/```\s*$/, '');
                    }
                    if (cleanResponse.startsWith('```')) {
                        cleanResponse = cleanResponse.replace(/^```\s*/, '').replace(/```\s*$/, '');
                    }
                    
                    console.log('🧹 清理后的响应:', cleanResponse);
                    
                    const parsed = JSON.parse(cleanResponse);
                    console.log('✅ JSON解析成功:', parsed);
                    
                    return {
                        content: parsed.content || '智能分析的文档内容',
                        concepts: parsed.concepts || [],
                        entities: parsed.entities || [],
                        relationships: parsed.relationships || [],
                        knowledgeTreeSuggestion: parsed.knowledgeTreeSuggestion || '智能分类',
                        confidence: parsed.confidence || 0.8,
                        fileSize: content ? content.length : 0
                    };
                } catch (parseError) {
                    console.error('❌ AI响应JSON解析失败:', parseError);
                    console.log('🔍 原始响应内容:', aiResponse);
                    console.log('🔄 回退到智能规则引擎');
                    return this.smartContentAnalysis(fileName, content);
                }
            }
            
            // 智能内容分析 - 备用方案
            smartContentAnalysis(fileName, content) {
                console.log('🧮 使用智能规则引擎分析内容');
                
                const fileExt = fileName.split('.').pop().toLowerCase();
                const contentSample = content ? content.substring(0, 500) : '';
                
                // 基于内容的智能推断
                let category = '未分类';
                let concepts = [];
                let entities = [];
                
                if (fileExt === 'pdf') {
                    category = '文档/PDF资料';
                    concepts = ['PDF文档', '文件资料'];
                } else if (contentSample.includes('API') || contentSample.includes('接口')) {
                    category = '开发/API文档';
                    concepts = ['API', '接口文档'];
                } else if (contentSample.includes('需求') || contentSample.includes('功能')) {
                    category = '项目/需求文档';
                    concepts = ['产品需求', '功能设计'];
                } else if (contentSample.includes('代码') || contentSample.includes('function')) {
                    category = '开发/代码资料';
                    concepts = ['代码', '开发'];
                }
                
                return {
                    content: contentSample || `${fileName} 文档内容`,
                    concepts: concepts,
                    entities: entities,
                    knowledgeTreeSuggestion: category,
                    confidence: 0.6,
                    fileSize: content ? content.length : 0
                };
            }

            // 已废弃：使用新的analyzeFileContent方法代替
            async analyzeFileNameWithAI(fileName, fileSize) {
                console.log('⚠️  analyzeFileNameWithAI已废弃，请使用analyzeFileContent');
                // 为兼容性保留，但建议使用新方法
                return this.smartContentAnalysis(fileName, '');
            }
            
            // 已废弃：使用callOpenAIWithContent代替
            async callOpenAI(fileName, fileSize) {
                console.log('⚠️  callOpenAI已废弃，使用callOpenAIWithContent');
                return this.callOpenAIWithContent(fileName, `文件: ${fileName}`);
            }
            
            // 已删除：本地AI调用功能（简化系统架构）
            
            // 解析AI分析响应
            parseAIAnalysisResponse(aiContent, fileName, fileSize) {
                console.log('🔍 Parsing AI analysis response');
                
                return {
                    aiGenerated: true,
                    aiContent: aiContent,
                    inferredContent: this.extractInferredContent(aiContent),
                    aiEntities: this.extractAIEntities(aiContent),
                    aiConcepts: this.extractAIConcepts(aiContent),
                    aiClassification: this.extractAIClassification(aiContent),
                    confidence: 0.85,
                    source: 'AI Analysis',
                    fileName: fileName,
                    fileSize: fileSize
                };
            }
            
            // 增强的规则引擎分析
            async enhancedRuleBasedAnalysis(fileName, fileSize) {
                console.log('🧮 Using enhanced rule-based analysis (AI simulation)');
                
                const analysis = {
                    fileName,
                    fileSize,
                    aiGenerated: false,
                    confidence: 0.7,
                    source: 'Enhanced Rule Engine'
                };
                
                // 基于文件名的智能推断
                const lowerName = fileName.toLowerCase();
                
                // 检测中文内容
                const hasChinese = /[\u4e00-\u9fa5]/.test(fileName);
                
                // 智能内容推断
                if (lowerName.includes('需求') || lowerName.includes('requirement')) {
                    analysis.inferredContent = `这是一个需求文档，可能包含：\n- 产品功能需求\n- 用户故事和用例\n- 技术规格说明\n- 验收标准\n- 系统架构设计`;
                    analysis.aiEntities = ['产品需求', '功能规格', '用户体验', '系统设计'];
                    analysis.aiConcepts = ['需求管理', '产品设计', '用户研究'];
                    analysis.aiClassification = '文档/产品需求';
                } else if (lowerName.includes('insight') || lowerName.includes('分析')) {
                    analysis.inferredContent = `这是一个洞察分析文档，可能包含：\n- 数据分析结果\n- 市场调研发现\n- 用户行为洞察\n- 商业智能报告\n- 趋势分析`;
                    analysis.aiEntities = ['数据分析', '市场洞察', '用户行为', '商业智能'];
                    analysis.aiConcepts = ['数据科学', '市场研究', '用户分析'];
                    analysis.aiClassification = '数据/分析报告';
                } else if (lowerName.includes('api') || lowerName.includes('接口')) {
                    analysis.inferredContent = `这是一个API文档，可能包含：\n- 接口规范说明\n- 请求响应格式\n- 认证方式\n- 错误代码\n- 使用示例`;
                    analysis.aiEntities = ['API接口', 'REST', 'JSON', 'HTTP'];
                    analysis.aiConcepts = ['接口设计', 'Web服务', 'API管理'];
                    analysis.aiClassification = '技术/API文档';
                } else if (lowerName.includes('report') || lowerName.includes('报告')) {
                    analysis.inferredContent = `这是一个报告文档，可能包含：\n- 执行摘要\n- 详细分析\n- 结论建议\n- 数据图表\n- 附录资料`;
                    analysis.aiEntities = ['报告', '分析结果', '建议', '数据'];
                    analysis.aiConcepts = ['商业分析', '报告撰写', '数据呈现'];
                    analysis.aiClassification = '文档/分析报告';
                } else {
                    // 通用分析
                    analysis.inferredContent = `基于文件名"${fileName}"的分析：\n- 文件大小: ${Math.round(fileSize/1024)}KB\n- 可能是${hasChinese ? '中文' : '英文'}文档\n- 需要进一步内容分析确定具体类型`;
                    analysis.aiEntities = [fileName.split('.')[0], '文档内容'];
                    analysis.aiConcepts = ['文档管理', '内容分析'];
                    analysis.aiClassification = '文档/其他';
                }
                
                return analysis;
            }
            
            // 从AI响应中提取推断内容
            extractInferredContent(aiContent) {
                const lines = aiContent.split('\n').filter(line => line.trim().length > 0);
                return lines.slice(0, 5).join('\n');
            }
            
            // 从AI响应中提取实体
            extractAIEntities(aiContent) {
                const entities = [];
                const lowerContent = aiContent.toLowerCase();
                
                // 寻找实体相关的关键词
                const patterns = [
                    /实体[：:]\s*([^。\n]+)/g,
                    /entities[：:]\s*([^.\n]+)/g,
                    /关键词[：:]\s*([^。\n]+)/g,
                    /keywords[：:]\s*([^.\n]+)/g
                ];
                
                patterns.forEach(pattern => {
                    let match;
                    while ((match = pattern.exec(aiContent)) !== null) {
                        const entityText = match[1];
                        const entityList = entityText.split(/[,，、]/).map(e => e.trim()).filter(e => e.length > 0);
                        entities.push(...entityList);
                    }
                });
                
                // 过滤掉动作短语和不合适的实体
                const filteredEntities = entities.filter(entity => this.isValidEntity(entity));
                
                return filteredEntities.slice(0, 10); // 限制数量
            }

            // 实体验证函数，优化过滤逻辑保留更多有效实体
            isValidEntity(entity) {
                if (!entity || entity.length < 2) return false;
                
                const entityLower = entity.toLowerCase().trim();
                
                // 只过滤明显的动作短语开头（减少过滤）
                const strictActionPhrases = [
                    '提升', '优化', '改进', '增强', '建立', '创建', '开发', '设计', '实现', '构建',
                    '制定', '执行', '推进', '强化', '加强', '完善'
                ];
                
                // 检查是否以动作词开头
                for (const action of strictActionPhrases) {
                    if (entityLower.startsWith(action) && entityLower.length <= action.length + 2) {
                        return false; // 只过滤纯动作词，不过滤复合概念
                    }
                }
                
                // 过滤掉太短或太长的实体
                if (entityLower.length < 2 || entityLower.length > 30) return false;
                
                // 过滤掉纯数字或纯符号
                if (/^[\d\s\-_]+$/.test(entityLower) || /^[^\w\u4e00-\u9fa5]+$/.test(entityLower)) {
                    return false;
                }
                
                // 只过滤最基础的停用词
                const basicStopWords = [
                    '的', '和', '与', '或', '但', '而', '在', '为', '从', '到', '由',
                    '这', '那', '这个', '那个', '什么', '如何', '为什么', '怎么',
                    '是', '有', '没有', '可以', '应该', '必须',
                    'the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by',
                    'is', 'are', 'was', 'were', 'be', 'been', 'have', 'has', 'had'
                ];
                
                if (basicStopWords.includes(entityLower)) {
                    return false;
                }
                
                // 允许更多技术和业务概念通过（减少通用词过滤）
                const allowedPatterns = [
                    /系统/, /平台/, /服务/, /模块/, /组件/, /架构/, /框架/, /工具/, /技术/, /方案/,
                    /流程/, /管理/, /分析/, /设计/, /开发/, /产品/, /用户/, /功能/, /接口/, /数据/,
                    /智能/, /算法/, /模型/, /引擎/, /网络/, /安全/, /性能/, /优化/, /配置/, /部署/
                ];
                
                for (const pattern of allowedPatterns) {
                    if (pattern.test(entityLower)) {
                        return true; // 技术和业务相关概念直接通过
                    }
                }
                
                return true; // 默认保留其他实体
            }
            
            // 从AI响应中提取概念
            extractAIConcepts(aiContent) {
                const concepts = [];
                const conceptPatterns = [
                    /概念[：:]\s*([^。\n]+)/g,
                    /concepts[：:]\s*([^.\n]+)/g,
                    /主题[：:]\s*([^。\n]+)/g,
                    /topics[：:]\s*([^.\n]+)/g
                ];
                
                conceptPatterns.forEach(pattern => {
                    let match;
                    while ((match = pattern.exec(aiContent)) !== null) {
                        const conceptText = match[1];
                        const conceptList = conceptText.split(/[,，、]/).map(c => c.trim()).filter(c => c.length > 0);
                        concepts.push(...conceptList);
                    }
                });
                
                return concepts.slice(0, 8); // 限制数量
            }
            
            // 从AI响应中提取分类
            extractAIClassification(aiContent) {
                const classificationPatterns = [
                    /分类[：:]\s*([^。\n]+)/g,
                    /classification[：:]\s*([^.\n]+)/g,
                    /类别[：:]\s*([^。\n]+)/g,
                    /category[：:]\s*([^.\n]+)/g
                ];
                
                for (const pattern of classificationPatterns) {
                    const match = pattern.exec(aiContent);
                    if (match) {
                        return match[1].trim();
                    }
                }
                
                return '文档/其他';
            }
            
            // 分析PDF结构
            analyzePDFStructure(content) {
                return {
                    isPDF: true,
                    contentLength: content.inferredContent?.length || 0,
                    hasAIAnalysis: content.aiGenerated || false,
                    confidence: content.confidence || 0.7,
                    analysisMethod: content.source || 'Rule-based'
                };
            }
            
            processGraphRAGResult(result) {
                return {
                    entities: result.entities || [],
                    relationships: result.relationships || [],
                    concepts: result.concepts || [],
                    categories: result.categories || [],
                    graphData: result.graph_data || null,
                    reasoning: result.reasoning_chain || [],
                    confidence: result.confidence || 0.8,
                    summary: result.summary || '',
                    keyInsights: result.key_insights || [],
                    suggestedActions: result.suggested_actions || []
                };
            }
            
            async enhancedSimulatedAnalysis(file, additionalContext) {
                console.log('🔬 Running enhanced simulated GraphRAG analysis');
                
                // 使用我们改进的分析系统作为回退
                const basicAnalysis = await performEnhancedAnalysis(file, 
                    this.getExistingCategories(), 
                    this.getPotentialNewCategories()
                );
                
                // 模拟GraphRAG的额外功能
                const simulatedGraphRAGFeatures = this.simulateGraphRAGFeatures(file, basicAnalysis);
                
                return {
                    ...basicAnalysis,
                    ...simulatedGraphRAGFeatures,
                    isSimulated: true,
                    serviceStatus: 'offline'
                };
            }
            
            simulateGraphRAGFeatures(file, basicAnalysis) {
                const filename = file.name.toLowerCase();
                
                // 模拟实体提取
                const entities = this.extractSimulatedEntities(filename);
                
                // 模拟关系识别
                const relationships = this.generateSimulatedRelationships(entities);
                
                // 模拟概念聚类
                const concepts = this.identifySimulatedConcepts(filename, basicAnalysis);
                
                // 模拟推理链
                const reasoning = this.generateReasoningChain(basicAnalysis);
                
                return {
                    entities: entities,
                    relationships: relationships,
                    concepts: concepts,
                    reasoning: reasoning,
                    keyInsights: this.generateKeyInsights(filename, entities),
                    graphData: this.generateSimulatedGraphData(entities, relationships)
                };
            }
            
            extractSimulatedEntities(filename) {
                const entities = [];
                const entityPatterns = {
                    'ORGANIZATION': ['company', 'corp', 'inc', 'ltd', 'agency'],
                    'PERSON': ['ceo', 'manager', 'director', 'analyst'],
                    'LOCATION': ['sydney', 'melbourne', 'australia', 'china', 'usa'],
                    'PRODUCT': ['app', 'software', 'platform', 'service'],
                    'CONCEPT': ['strategy', 'analysis', 'research', 'campaign', 'content']
                };
                
                Object.entries(entityPatterns).forEach(([type, patterns]) => {
                    patterns.forEach(pattern => {
                        if (filename.includes(pattern)) {
                            entities.push({
                                name: pattern.charAt(0).toUpperCase() + pattern.slice(1),
                                type: type,
                                confidence: Math.random() * 0.3 + 0.7,
                                mentions: Math.floor(Math.random() * 5) + 1
                            });
                        }
                    });
                });
                
                // 添加一些通用实体
                if (entities.length < 3) {
                    entities.push(
                        {name: 'Content Marketing', type: 'CONCEPT', confidence: 0.8, mentions: 3},
                        {name: 'Digital Strategy', type: 'CONCEPT', confidence: 0.75, mentions: 2},
                        {name: 'Market Analysis', type: 'CONCEPT', confidence: 0.7, mentions: 1}
                    );
                }
                
                return entities;
            }
            
            generateSimulatedRelationships(entities) {
                const relationships = [];
                const relationTypes = ['RELATED_TO', 'PART_OF', 'INFLUENCES', 'DEPENDS_ON', 'CREATES'];
                
                for (let i = 0; i < entities.length - 1; i++) {
                    for (let j = i + 1; j < entities.length && relationships.length < 5; j++) {
                        if (Math.random() > 0.6) {
                            relationships.push({
                                source: entities[i].name,
                                target: entities[j].name,
                                relationship: relationTypes[Math.floor(Math.random() * relationTypes.length)],
                                confidence: Math.random() * 0.4 + 0.6,
                                strength: Math.random() * 0.5 + 0.5
                            });
                        }
                    }
                }
                
                return relationships;
            }
            
            identifySimulatedConcepts(filename, basicAnalysis) {
                const concepts = [];
                const conceptMap = {
                    'market': ['Market Segmentation', 'Competitive Analysis', 'Consumer Behavior'],
                    'content': ['Content Strategy', 'Editorial Planning', 'Brand Voice'],
                    'social': ['Social Engagement', 'Community Building', 'Influencer Marketing'],
                    'data': ['Data Analytics', 'Performance Metrics', 'Business Intelligence'],
                    'campaign': ['Campaign Management', 'Marketing Automation', 'Lead Generation']
                };
                
                Object.entries(conceptMap).forEach(([keyword, relatedConcepts]) => {
                    if (filename.includes(keyword)) {
                        relatedConcepts.forEach(concept => {
                            concepts.push({
                                name: concept,
                                relevance: Math.random() * 0.3 + 0.7,
                                category: basicAnalysis.bestMatch?.name || 'General'
                            });
                        });
                    }
                });
                
                return concepts.slice(0, 5); // 限制为5个概念
            }
            
            generateReasoningChain(basicAnalysis) {
                return [
                    {
                        step: 1,
                        action: 'Document Analysis',
                        description: `Analyzed file structure and metadata`,
                        confidence: 0.9
                    },
                    {
                        step: 2,
                        action: 'Entity Recognition',
                        description: `Identified key entities and concepts`,
                        confidence: 0.85
                    },
                    {
                        step: 3,
                        action: 'Relationship Mapping',
                        description: `Mapped relationships between entities`,
                        confidence: 0.8
                    },
                    {
                        step: 4,
                        action: 'Category Classification',
                        description: `Classified content into ${basicAnalysis.bestMatch?.name || 'appropriate category'}`,
                        confidence: basicAnalysis.confidence || 0.75
                    }
                ];
            }
            
            generateKeyInsights(filename, entities) {
                const insights = [];
                
                if (entities.some(e => e.type === 'ORGANIZATION')) {
                    insights.push('📊 Document contains organizational structure information');
                }
                
                if (entities.some(e => e.type === 'CONCEPT')) {
                    insights.push('💡 Strategic concepts and methodologies identified');
                }
                
                if (filename.includes('2024') || filename.includes('2025')) {
                    insights.push('📅 Contains current/future planning information');
                }
                
                insights.push(`🔍 ${entities.length} key entities extracted for knowledge graph`);
                
                return insights;
            }
            
            generateSimulatedGraphData(entities, relationships) {
                const nodes = entities.map(entity => ({
                    id: entity.name,
                    label: entity.name,
                    type: entity.type,
                    size: entity.confidence * 20 + 10,
                    color: this.getNodeColor(entity.type)
                }));
                
                const edges = relationships.map(rel => ({
                    source: rel.source,
                    target: rel.target,
                    label: rel.relationship,
                    weight: rel.strength
                }));
                
                return { nodes, edges };
            }
            
            getNodeColor(type) {
                const colors = {
                    'ORGANIZATION': '#ff6b6b',
                    'PERSON': '#4ecdc4',
                    'LOCATION': '#45b7d1',
                    'PRODUCT': '#f9ca24',
                    'CONCEPT': '#6c5ce7'
                };
                return colors[type] || '#a0a0a0';
            }
            
            getExistingCategories() {
                return [
                    { 
                        name: "📊 Market Research", 
                        confidence: 0.85, 
                        reason: "Contains market data and consumer insights",
                        keywords: ["market", "research", "survey", "consumer", "audience", "demographic", "trend", "analysis"],
                        fileTypes: ["xlsx", "csv", "pdf", "docx"],
                        minConfidence: 0.7
                    },
                    { 
                        name: "✍️ Content Strategy", 
                        confidence: 0.78, 
                        reason: "Includes content planning and editorial guidelines",
                        keywords: ["content", "blog", "editorial", "writing", "article", "copy", "seo", "publishing"],
                        fileTypes: ["docx", "txt", "md", "pdf"],
                        minConfidence: 0.6
                    },
                    { 
                        name: "📱 Social Media", 
                        confidence: 0.92, 
                        reason: "Social media metrics and campaign data detected",
                        keywords: ["social", "instagram", "tiktok", "facebook", "twitter", "linkedin", "engagement", "follower"],
                        fileTypes: ["png", "jpg", "jpeg", "pdf", "xlsx"],
                        minConfidence: 0.8
                    },
                    { 
                        name: "📈 Analytics & Data", 
                        confidence: 0.89, 
                        reason: "Performance metrics and statistical analysis",
                        keywords: ["analytics", "data", "kpi", "metrics", "performance", "dashboard", "report", "statistics"],
                        fileTypes: ["xlsx", "csv", "json", "pdf"],
                        minConfidence: 0.75
                    },
                    { 
                        name: "🎯 Campaign Planning", 
                        confidence: 0.74, 
                        reason: "Campaign objectives and target audience info",
                        keywords: ["campaign", "strategy", "plan", "launch", "marketing", "promotion", "advertising"],
                        fileTypes: ["pptx", "pdf", "docx"],
                        minConfidence: 0.65
                    }
                ];
            }
            
            getPotentialNewCategories() {
                return [
                    { name: "🎨 Brand Design", confidence: 0.88, reason: "Visual branding and design assets detected" },
                    { name: "📧 Email Marketing", confidence: 0.82, reason: "Email campaign templates and automation workflows" },
                    { name: "🎥 Video Content", confidence: 0.90, reason: "Video production scripts and multimedia content" },
                    { name: "📞 Customer Support", confidence: 0.75, reason: "Support documentation and customer service materials" },
                    { name: "💰 Sales Materials", confidence: 0.83, reason: "Sales presentations and lead generation content" },
                    { name: "🔍 SEO & Keywords", confidence: 0.87, reason: "Search engine optimization and keyword research" },
                    { name: "📱 Mobile App", confidence: 0.79, reason: "Mobile application development and UX content" },
                    { name: "🛒 E-commerce", confidence: 0.85, reason: "Product descriptions and online store content" },
                    { name: "📊 Business Intelligence", confidence: 0.91, reason: "Business reporting and data visualization" },
                    { name: "🎓 Training & Education", confidence: 0.73, reason: "Educational materials and training content" }
                ];
            }
        }
        
        // Initialize GraphRAG Service
        const graphRAGService = new GraphRAGService();

        // Multi-modal Input Functions
        let currentInputMode = 'text';
        let recognition = null;
        
        // Manual input tracking for Send button restriction
        let isManualInput = false;

        // Switch input modes
        window.switchInputMode = function(mode) {
            console.log('🔄 Switching to mode:', mode);
            // Update button states
            document.querySelectorAll('.input-mode-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.mode === mode) {
                    btn.classList.add('active');
                }
            });
            
            // Hide all mode contents
            document.querySelectorAll('.input-mode-content').forEach(content => {
                content.style.display = 'none';
            });
            
            // Show selected mode
            const targetMode = document.getElementById(mode + 'InputMode');
            if (targetMode) {
                targetMode.style.display = 'block';
                console.log('✅ Switched to', mode, 'mode');
            } else {
                console.error('❌ Mode not found:', mode + 'InputMode');
            }
            currentInputMode = mode;
        }

        // 🤖 Smart Input Handlers - Auto-detect content type
        
        // Handle smart text input - detects URLs and other patterns
        window.handleSmartInput = function(value) {
            console.log('🤖 Smart input analysis:', value.length, 'chars');
            
            // URL detection
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            const urls = value.match(urlRegex);
            
            if (urls && urls.length > 0) {
                console.log('🔗 URL detected:', urls[0]);
                // Auto-fetch URL content if it's the only content
                if (value.trim() === urls[0]) {
                    setTimeout(() => {
                        fetchUrlContentFromInput(urls[0]);
                    }, 1000);
                }
            }
        };

        // Handle smart file drop
        window.handleSmartDrop = function(event) {
            console.log('📁 Smart drop handler triggered');
            event.preventDefault();
            event.stopPropagation();
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                console.log('📁 Files dropped:', files.length);
                handleFileInput(files);
            }
            
            // Reset visual state
            event.target.style.borderColor = '#cbd5e1';
            event.target.style.backgroundColor = '#f8fafc';
        };

        // Handle file input (from file picker or drag-drop)
        window.handleFileInput = function(files) {
            console.log('📁 Processing files through smart input:', files.length);
            if (files && files.length > 0) {
                // Use existing file processing logic
                processUploadedFiles(files);
            }
        };

        // Fetch URL content from input and save to knowledge tree
        window.fetchUrlContentFromInput = async function(url) {
            console.log('🔗 Auto-fetching URL:', url);
            console.log('🔍 DEBUG: 开始URL类型检测...');
            console.log('🔍 DEBUG: URL包含youtube.com/watch?', url.includes('youtube.com/watch'));
            console.log('🔍 DEBUG: URL包含youtu.be/?', url.includes('youtu.be/'));
            
            // 🔥 YouTube URL 直接处理 - 使用视频提取管道
            if (url.includes('youtube.com/watch') || url.includes('youtu.be/') || url.includes('bilibili.com') || url.includes('vimeo.com')) {
                console.log('🎬 检测到视频URL，启用视频提取模式');
                console.log('🔍 DEBUG: 视频检测逻辑命中，准备调用/api/scrape');
                
                // Show video specific loading state
                const urlContent = document.getElementById('urlContent');
                if (urlContent) {
                    urlContent.style.display = 'block';
                    urlContent.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
                            <div style="width: 24px; height: 24px; border: 2px solid #3b82f6; border-top: transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                            <span>🎬 视频内容提取中: ${url}</span>
                        </div>
                    `;
                }
                
                try {
                    // 直接调用视频分析API，不走文件上传流程
                    console.log('🔄 启动视频内容提取...');
                    console.log('🔍 DEBUG: 发送API请求到 /api/scrape');
                    console.log('🔍 DEBUG: 请求体:', { url: url });
                    
                    const response = await fetch('http://localhost:8000/api/scrape', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ url: url })
                    });
                    
                    console.log('🔍 DEBUG: API响应状态:', response.status, response.statusText);
                    
                    if (!response.ok) {
                        console.log('❌ DEBUG: API请求失败:', response.status);
                        throw new Error(`视频分析失败: ${response.status}`);
                    }
                    
                    const analysisResult = await response.json();
                    console.log('🔍 DEBUG: API返回结果:', analysisResult);
                    console.log('🔍 DEBUG: 结果状态:', analysisResult.status);
                    console.log('🔍 DEBUG: 内容长度:', analysisResult?.analysis?.content?.length || 'N/A');
                    
                    if (analysisResult.status === 'success') {
                        console.log('✅ 视频内容提取成功');
                        console.log('🔍 DEBUG: 成功路径 - 准备显示结果');
                        
                        // 显示视频分析结果
                        displayURLAnalysisResults(analysisResult.analysis, url);
                        
                        // 保存到知识树
                        const videoFile = new File([analysisResult.analysis.content], 
                            `video_${new URL(url).hostname}_${Date.now()}.txt`, 
                            { type: 'text/plain' });
                        videoFile.sourceUrl = url;
                        
                        await autoSaveToKnowledgeTree(videoFile, analysisResult);
                        
                        showNotification('🎬 视频内容提取完成并保存到知识库!');
                        
                        // 清理输入区域
                        setTimeout(() => {
                            clearUploadArea();
                        }, 3000);
                        
                        return; // 直接返回，不继续常规流程
                    } else {
                        console.log('❌ DEBUG: 视频分析API返回失败状态');
                        console.log('🔍 DEBUG: 失败消息:', analysisResult.message || 'N/A');
                        throw new Error(analysisResult.message || '视频分析失败');
                    }
                    
                } catch (error) {
                    console.error('❌ 视频提取失败:', error);
                    console.log('🔍 DEBUG: 进入视频提取错误处理分支');
                    console.log('🔍 DEBUG: 错误类型:', error.name);
                    console.log('🔍 DEBUG: 错误消息:', error.message);
                    
                    // 显示错误状态
                    if (urlContent) {
                        urlContent.innerHTML = `
                            <h4 style="margin: 0 0 12px 0; color: #dc2626;">❌ 视频提取失败</h4>
                            <p style="color: #6b7280; margin: 0 0 8px 0;">URL: ${url}</p>
                            <div style="background: #fef2f2; border: 1px solid #fecaca; border-radius: 8px; padding: 12px; color: #dc2626;">
                                ${error.message}
                            </div>
                        `;
                    }
                    
                    showNotification('❌ 视频内容提取失败', 'error');
                    console.log('🔍 DEBUG: 视频处理失败，即将返回，不继续通用URL流程');
                    return; // 失败也直接返回，不继续常规流程
                }
            }

            // 🔥 GitHub URL 直接处理 - 避免HTML文件转换
            if (url.includes('github.com/') && url.match(/github\.com\/[^\/]+\/[^\/]+/)) {
                console.log('🎯 检测到GitHub URL，启用直接处理模式');
                console.log('🔍 DEBUG: GitHub URL处理分支开始');
                
                // Show GitHub specific loading state
                const urlContent = document.getElementById('urlContent');
                if (urlContent) {
                    urlContent.style.display = 'block';
                    urlContent.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
                            <div style="width: 24px; height: 24px; border: 2px solid #3b82f6; border-top: transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                            <span>🔍 GitHub项目分析中: ${url}</span>
                        </div>
                    `;
                }
                
                try {
                    // 创建简单的文本文件而不是HTML文件
                    const githubFile = new File([url], 'github_url.txt', { type: 'text/plain' });
                    githubFile.sourceUrl = url;
                    githubFile.title = `GitHub项目: ${url}`;
                    githubFile.description = 'GitHub repository analysis';
                    
                    console.log('🔄 GitHub项目深度分析启动...');
                    
                    // 直接调用GraphRAG分析
                    const analysisResult = await graphRAGService.analyzeFileOnUpload(githubFile);
                    
                    // 保存到知识树
                    console.log('🎯 GitHub分析完成，保存到知识树');
                    await autoSaveToKnowledgeTree(githubFile, analysisResult);
                    
                    // 显示成功状态
                    if (urlContent) {
                        urlContent.innerHTML = `
                            <h4 style="margin: 0 0 12px 0; color: #374151;">✅ GitHub项目分析完成</h4>
                            <p style="color: #6b7280; margin: 0 0 8px 0;">URL: ${url}</p>
                            <div style="background: #dcfce7; border: 1px solid #bbf7d0; border-radius: 8px; padding: 12px; color: #166534;">
                                ✅ GitHub项目分析完成并保存到知识树
                            </div>
                        `;
                    }
                    
                    showNotification('🔗 GitHub项目分析完成并保存到知识库!');
                    
                    // 清理输入区域
                    setTimeout(() => {
                        clearUploadArea();
                    }, 3000);
                    
                    return; // 直接返回，不继续常规流程
                    
                } catch (error) {
                    console.error('❌ GitHub直接分析失败:', error);
                    // 继续走常规流程作为备选
                }
            }
            
            // 🚨 DEBUG: 进入通用URL处理区域 - 这里可能拦截YouTube链接！
            console.log('🚨 DEBUG: 进入通用URL处理区域');
            console.log('🚨 DEBUG: 当前URL:', url);
            console.log('🚨 DEBUG: YouTube检测结果 - isYouTube:', isYouTube);
            console.log('🚨 DEBUG: 如果isYouTube为true但仍进入此区域，则说明YouTube检测有问题');
            
            // Show URL content area with loading state
            const urlContent = document.getElementById('urlContent');
            if (urlContent) {
                urlContent.style.display = 'block';
                urlContent.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
                        <div style="width: 24px; height: 24px; border: 2px solid #3b82f6; border-top: transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                        <span>Fetching content from: ${url}</span>
                    </div>
                `;
            }
            
            try {
                // 🔧 DEBUG: 开始内容获取
                console.log('🔧 DEBUG: 开始尝试获取URL内容');
                
                // Try multiple approaches to fetch URL content
                let content = '';
                let fetchError = null;
                
                // Method 1: Try direct fetch first (may fail due to CORS)
                try {
                    console.log('🔧 DEBUG: 尝试直接fetch');
                    const response = await fetch(url, {
                        method: 'GET',
                        mode: 'cors',
                        headers: {
                            'User-Agent': 'Mozilla/5.0 (compatible; ContentFetcher/1.0)'
                        }
                    });
                    
                    if (response.ok) {
                        content = await response.text();
                        console.log('✅ DEBUG: 直接fetch成功，内容长度:', content.length);
                        console.log('🔧 DEBUG: 内容预览:', content.substring(0, 200));
                    } else {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                } catch (directError) {
                    console.log('❌ DEBUG: 直接fetch失败 (CORS):', directError.message);
                    fetchError = directError;
                    
                    // Method 2: Try CORS proxy services
                    const proxyUrls = [
                        `https://corsproxy.io/?${encodeURIComponent(url)}`,
                        `https://cors-anywhere.herokuapp.com/${url}`,
                        `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`
                    ];
                    
                    for (const proxyUrl of proxyUrls) {
                        try {
                            console.log('🔄 Trying proxy:', proxyUrl);
                            const proxyResponse = await fetch(proxyUrl);
                            
                            if (proxyResponse.ok) {
                                if (proxyUrl.includes('allorigins')) {
                                    const jsonData = await proxyResponse.json();
                                    content = jsonData.contents;
                                } else {
                                    content = await proxyResponse.text();
                                }
                                console.log('✅ Proxy fetch successful');
                                fetchError = null;
                                break;
                            }
                        } catch (proxyError) {
                            console.log('❌ Proxy failed:', proxyUrl, proxyError.message);
                            continue;
                        }
                    }
                    
                    // Method 3: If all proxies fail, use a mock content approach
                    if (!content && fetchError) {
                        console.log('🔄 Using fallback content extraction...');
                        content = await generateMockContentFromUrl(url);
                    }
                }
                if (!content || content.length === 0) {
                    throw new Error('No content could be retrieved from the URL');
                }
                
                console.log('✅ URL content fetched, length:', content.length);
                
                // 🚨 DEBUG: 开始HTML文本提取和元数据解析
                console.log('🚨 DEBUG: 开始从HTML提取纯文本内容');
                console.log('🚨 DEBUG: 原始HTML内容长度:', content.length);
                console.log('🚨 DEBUG: HTML内容预览:', content.substring(0, 300));
                
                // 🔥 从HTML中提取纯文本内容
                const cleanText = extractTextFromHTML(content);
                console.log('🔧 HTML纯文本提取完成，长度:', cleanText.length);
                console.log('🚨 DEBUG: 提取的纯文本预览:', cleanText.substring(0, 200));
                
                // 🚨 DEBUG: 开始解析HTML元数据
                console.log('🚨 DEBUG: 开始解析HTML元数据');
                
                // Extract basic information from HTML
                const parser = new DOMParser();
                const doc = parser.parseFromString(content, 'text/html');
                const title = doc.querySelector('title')?.textContent || new URL(url).hostname;
                const description = doc.querySelector('meta[name="description"]')?.content || 
                                   doc.querySelector('meta[property="og:description"]')?.content || 
                                   'Web content analysis';
                
                console.log('🚨 DEBUG: 解析的标题:', title);
                console.log('🚨 DEBUG: 解析的描述:', description);
                console.log('🚨 DEBUG: 如果这是YouTube URL，标题应该包含视频信息，而不是通用页面标题');
                
                // 🚨 DEBUG: File对象创建过程追踪
                console.log('🚨 DEBUG: ======= 关键问题点：File对象创建 =======');
                console.log('🚨 DEBUG: 即将创建File对象，这里可能就是YouTube URL被错误处理的地方');
                console.log('🚨 DEBUG: cleanText内容长度:', cleanText.length);
                console.log('🚨 DEBUG: cleanText内容预览（前100字符）:', cleanText.substring(0, 100));
                console.log('🚨 DEBUG: 文件名将设为:', `${title}.html`);
                console.log('🚨 DEBUG: 文件类型将设为: text/html');
                console.log('🚨 DEBUG: ⚠️  如果这是YouTube URL，这里应该检测到视频内容而不是通用HTML！');
                
                // Create a virtual file object for processing (使用提取的纯文本)
                const urlFile = new File(
                    [cleanText], 
                    `${title}.html`, 
                    { type: 'text/html' }
                );
                
                console.log('🚨 DEBUG: File对象已创建');
                console.log('🚨 DEBUG: 创建的File对象大小:', urlFile.size, '字节');
                console.log('🚨 DEBUG: 创建的File对象名称:', urlFile.name);
                console.log('🚨 DEBUG: 创建的File对象类型:', urlFile.type);
                
                // Add URL metadata
                urlFile.sourceUrl = url;
                urlFile.title = title;
                urlFile.description = description;
                
                console.log('🚨 DEBUG: 元数据已添加到File对象');
                console.log('🚨 DEBUG: sourceUrl:', urlFile.sourceUrl);
                console.log('🚨 DEBUG: ======= File对象创建完成，即将发送到后端 =======');
                
                console.log('🔄 Starting GraphRAG analysis for URL content...');
                
                // Show success message and start analysis
                if (urlContent) {
                    urlContent.innerHTML = `
                        <h4 style="margin: 0 0 12px 0; color: #374151;">🔗 ${title}</h4>
                        <p style="color: #6b7280; margin: 0 0 8px 0;">URL: ${url}</p>
                        <p style="color: #6b7280; margin: 0 0 16px 0;">${description}</p>
                        <div style="display: flex; align-items: center; gap: 8px; color: #3b82f6;">
                            <div style="width: 16px; height: 16px; border: 2px solid #3b82f6; border-top: transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                            <span>Analyzing content with GraphRAG...</span>
                        </div>
                    `;
                }
                
                // 🚨 DEBUG: 后端分析服务调用追踪
                console.log('🚨 DEBUG: ======= 即将发送到GraphRAG后端分析 =======');
                console.log('🚨 DEBUG: 准备调用 graphRAGService.analyzeFileOnUpload()');
                console.log('🚨 DEBUG: 传递的urlFile对象详情:');
                console.log('🚨 DEBUG: - File名称:', urlFile.name);
                console.log('🚨 DEBUG: - File大小:', urlFile.size, '字节');
                console.log('🚨 DEBUG: - File类型:', urlFile.type);
                console.log('🚨 DEBUG: - sourceUrl:', urlFile.sourceUrl);
                console.log('🚨 DEBUG: - title:', urlFile.title);
                console.log('🚨 DEBUG: ⚠️  关键问题：如果这是YouTube URL，后端应该检测到视频内容！');
                console.log('🚨 DEBUG: ⚠️  期望结果：2694字符的视频转录，而不是98字符的HTML页面！');
                console.log('🚨 DEBUG: 正在发送到后端...');
                
                // Use GraphRAG service to analyze the content
                const analysisResult = await graphRAGService.analyzeFileOnUpload(urlFile);
                
                console.log('🚨 DEBUG: ======= 后端分析结果返回 =======');
                console.log('🚨 DEBUG: 分析结果状态:', analysisResult?.status);
                console.log('🚨 DEBUG: 返回内容长度:', analysisResult?.analysis?.content?.length);
                console.log('🚨 DEBUG: 内容预览（前100字符）:', analysisResult?.analysis?.content?.substring(0, 100));
                console.log('🚨 DEBUG: 提取方法:', analysisResult?.extraction_method);
                console.log('🚨 DEBUG: 平台检测:', analysisResult?.platform);
                console.log('🚨 DEBUG: ⚠️  检查：如果是YouTube，应该显示"YouTube"平台和视频内容！');
                console.log('🚨 DEBUG: ======= 后端分析完成 =======');
                
                // Save to knowledge tree automatically
                console.log('🎯 URL analysis completed, auto-saving to knowledge tree');
                await autoSaveToKnowledgeTree(urlFile, analysisResult);
                
                // Update display with success
                if (urlContent) {
                    urlContent.innerHTML = `
                        <h4 style="margin: 0 0 12px 0; color: #374151;">✅ ${title}</h4>
                        <p style="color: #6b7280; margin: 0 0 8px 0;">URL: ${url}</p>
                        <p style="color: #6b7280; margin: 0 0 16px 0;">${description}</p>
                        <div style="background: #dcfce7; border: 1px solid #bbf7d0; border-radius: 8px; padding: 12px; color: #166534;">
                            ✅ Content analyzed and saved to knowledge tree
                        </div>
                    `;
                }
                
                showNotification('🔗 URL content analyzed and saved to knowledge base!');
                
                // Clear the input after successful processing
                setTimeout(() => {
                    clearUploadArea();
                }, 3000);
                
            } catch (error) {
                console.error('❌ URL fetching failed:', error);
                
                // Show error message
                if (urlContent) {
                    urlContent.innerHTML = `
                        <h4 style="margin: 0 0 12px 0; color: #dc2626;">❌ Failed to fetch URL</h4>
                        <p style="color: #6b7280; margin: 0 0 8px 0;">URL: ${url}</p>
                        <div style="background: #fef2f2; border: 1px solid #fecaca; border-radius: 8px; padding: 12px; color: #dc2626;">
                            Error: ${error.message}
                            <br><br>
                            <strong>CORS Solutions:</strong>
                            <br>• Try copying and pasting the content manually
                            <br>• Use a browser extension like "CORS Unblock"
                            <br>• For GitHub: Try the raw file URL instead
                            <br>• Consider using a local server with CORS proxy
                            <br><br>
                            <button onclick="retryUrlWithFallback('${url}')" style="
                                background: #dc2626; color: white; border: none; padding: 8px 16px;
                                border-radius: 4px; cursor: pointer; font-size: 12px;
                            ">🔄 Retry with Fallback</button>
                        </div>
                    `;
                }
                
                showNotification('❌ Failed to fetch URL content. Please check the URL or try manual content input.');
            }
        };

        // Retry URL fetch with fallback approach
        window.retryUrlWithFallback = async function(url) {
            console.log('🔄 Retrying URL with fallback approach:', url);
            
            const urlContent = document.getElementById('urlContent');
            if (urlContent) {
                urlContent.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
                        <div style="width: 24px; height: 24px; border: 2px solid #3b82f6; border-top: transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                        <span>Retrying with fallback approach...</span>
                    </div>
                `;
            }
            
            try {
                // Force use fallback approach
                const content = await generateMockContentFromUrl(url);
                
                // Extract information
                const parser = new DOMParser();
                const doc = parser.parseFromString(content, 'text/html');
                const title = doc.querySelector('title')?.textContent || new URL(url).hostname;
                const description = doc.querySelector('meta[name="description"]')?.content || 'Web content analysis';
                
                // Create virtual file
                const urlFile = new File([content], `${title}.html`, { type: 'text/html' });
                urlFile.sourceUrl = url;
                urlFile.title = title;
                urlFile.description = description;
                
                // Analyze with GraphRAG
                const analysisResult = await graphRAGService.analyzeFileOnUpload(urlFile);
                await autoSaveToKnowledgeTree(urlFile, analysisResult);
                
                // Show success
                if (urlContent) {
                    urlContent.innerHTML = `
                        <h4 style="margin: 0 0 12px 0; color: #374151;">✅ ${title} (Fallback)</h4>
                        <p style="color: #6b7280; margin: 0 0 8px 0;">URL: ${url}</p>
                        <p style="color: #6b7280; margin: 0 0 16px 0;">${description}</p>
                        <div style="background: #dcfce7; border: 1px solid #bbf7d0; border-radius: 8px; padding: 12px; color: #166534;">
                            ✅ Content analyzed using fallback method and saved to knowledge tree
                            <br><small>Note: Used structured content extraction due to CORS restrictions</small>
                        </div>
                    `;
                }
                
                showNotification('🔗 URL processed with fallback method and saved to knowledge base!');
                setTimeout(() => clearUploadArea(), 3000);
                
            } catch (error) {
                console.error('❌ Fallback retry failed:', error);
                if (urlContent) {
                    urlContent.innerHTML = `
                        <h4 style="margin: 0 0 12px 0; color: #dc2626;">❌ Retry Failed</h4>
                        <p style="color: #6b7280; margin: 0 0 8px 0;">URL: ${url}</p>
                        <div style="background: #fef2f2; border: 1px solid #fecaca; border-radius: 8px; padding: 12px; color: #dc2626;">
                            Unable to process URL even with fallback methods.
                            <br>Please try copying and pasting the content manually into the text area.
                        </div>
                    `;
                }
            }
        };

        // Generate mock content from URL when direct fetching fails
        window.generateMockContentFromUrl = async function(url) {
            console.log('🔄 Generating mock content for URL:', url);
            
            try {
                const urlObj = new URL(url);
                const domain = urlObj.hostname;
                const path = urlObj.pathname;
                
                // Extract potential information from URL structure
                const pathParts = path.split('/').filter(part => part.length > 0);
                const title = pathParts.length > 0 ? pathParts[pathParts.length - 1].replace(/[-_]/g, ' ') : domain;
                
                // Generate structured mock content based on domain patterns
                let mockContent = '';
                
                if (domain.includes('github.com')) {
                    const [user, repo] = pathParts;
                    mockContent = `
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <title>${user}/${repo || 'repository'} - GitHub</title>
                            <meta name="description" content="GitHub repository for ${user}/${repo || 'software project'}">
                        </head>
                        <body>
                            <h1>${user}/${repo || 'Repository'}</h1>
                            <p>This is a GitHub repository containing source code and documentation.</p>
                            <div>
                                <h2>About</h2>
                                <p>GitHub repository: ${url}</p>
                                <p>This appears to be a software development project hosted on GitHub.</p>
                                <p>Repository owner: ${user}</p>
                                ${repo ? `<p>Repository name: ${repo}</p>` : ''}
                            </div>
                            <div>
                                <h2>Content Type</h2>
                                <p>Source code repository, documentation, software project</p>
                            </div>
                        </body>
                        </html>
                    `;
                } else if (domain.includes('medium.com') || domain.includes('blog')) {
                    mockContent = `
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <title>${title} - Article</title>
                            <meta name="description" content="Article or blog post from ${domain}">
                        </head>
                        <body>
                            <h1>${title}</h1>
                            <p>This appears to be an article or blog post.</p>
                            <div>
                                <h2>Source</h2>
                                <p>URL: ${url}</p>
                                <p>Domain: ${domain}</p>
                                <p>Content Type: Article/Blog Post</p>
                            </div>
                        </body>
                        </html>
                    `;
                } else {
                    // Generic web content
                    mockContent = `
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <title>${title || domain} - Web Content</title>
                            <meta name="description" content="Web content from ${domain}">
                        </head>
                        <body>
                            <h1>${title || domain}</h1>
                            <p>Web content from: ${url}</p>
                            <div>
                                <h2>Content Information</h2>
                                <p>URL: ${url}</p>
                                <p>Domain: ${domain}</p>
                                <p>Path: ${path}</p>
                                <p>Content Type: Web Page</p>
                                <p>Note: This content was generated as a fallback due to CORS restrictions.</p>
                                <p>For full content analysis, consider using a browser extension or server-side solution.</p>
                            </div>
                        </body>
                        </html>
                    `;
                }
                
                console.log('✅ Mock content generated');
                return mockContent;
                
            } catch (error) {
                console.error('❌ Failed to generate mock content:', error);
                // Return minimal content as last resort
                return `
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>Web Content - ${url}</title>
                        <meta name="description" content="Web content analysis">
                    </head>
                    <body>
                        <h1>Web Content Analysis</h1>
                        <p>URL: ${url}</p>
                        <p>This URL was processed for content analysis.</p>
                        <p>Due to CORS restrictions, detailed content extraction was not possible.</p>
                    </body>
                    </html>
                `;
            }
        };

        // File drag and drop handling (renamed to avoid conflict)
        window.handleFileDragOver = function(e) {
            console.log('🔍 File drag over detected');
            e.preventDefault();
            e.stopPropagation();
            const container = e.target.closest('.multimodal-input-container');
            if (container) {
                console.log('✅ Adding dragover to container');
                container.classList.add('dragover');
            }
            const dropZone = e.target.closest('.file-drop-zone');
            if (dropZone) {
                console.log('✅ Adding dragover to dropzone');
                dropZone.classList.add('dragover');
            }
        }

        window.handleFileDragLeave = function(e) {
            e.preventDefault();
            e.stopPropagation();
            const container = e.target.closest('.multimodal-input-container');
            if (container) {
                container.classList.remove('dragover');
            }
            const dropZone = e.target.closest('.file-drop-zone');
            if (dropZone) {
                dropZone.classList.remove('dragover');
            }
        }

        window.handleFileDrop = function(e) {
            console.log('🔍 File drop detected!');
            e.preventDefault();
            e.stopPropagation();
            const container = e.target.closest('.multimodal-input-container');
            if (container) {
                container.classList.remove('dragover');
            }
            const dropZone = e.target.closest('.file-drop-zone');
            if (dropZone) {
                dropZone.classList.remove('dragover');
            }
            
            const files = e.dataTransfer.files;
            console.log('📁 Files dropped:', files.length);
            console.log('🔥 GLOBAL handleFileDrop - 跳过处理，让专门的fileDropZone处理');
            // 🔥 不在全局处理文件，让专门的fileDropZone处理以避免重复
        }

        // Process uploaded files - 简化版本
        async function processUploadedFiles(files) {
            console.log('📁 Processing', files.length, 'files');
            const container = document.getElementById('uploadedFiles');
            
            if (!container) {
                console.error('❌ uploadedFiles container not found!');
                return;
            }
            
            container.innerHTML = '';
            
            // 简单的重复检查
            if (window.isProcessingFiles) {
                console.log('⚠️ Already processing files, skipping');
                return;
            }
            
            window.isProcessingFiles = true;
            
            try {
                // 存储当前上传的文件供后续使用
                window.currentUploadedFiles = Array.from(files);
                
                // 🔥 串行处理文件，避免并发问题
                for (let index = 0; index < files.length; index++) {
                    const file = files[index];
                    console.log(`🚀 Starting immediate analysis for file ${index + 1}:`, file.name);
                    
                    // 创建文件处理卡片
                    const fileCard = await createIntelligentFileCard(file, index);
                    container.appendChild(fileCard);
                    
                    // 立即开始智能分析
                    try {
                        const analysisResult = await graphRAGService.analyzeFileOnUpload(file);
                        
                        // 🔥 存储分析结果到全局变量供后续使用
                        if (!window.currentAnalysisResults) {
                            window.currentAnalysisResults = {};
                        }
                        window.currentAnalysisResults[file.name] = analysisResult;
                        console.log('💾 Stored analysis result for:', file.name);
                        
                        // 更新文件卡片显示分析结果
                        await updateFileCardWithAnalysis(fileCard, file, analysisResult);
                        
                        // 🔥 智能分析完成后直接自动保存到知识树
                        console.log('🎯 AI分析完成，自动保存到知识树');
                        await autoSaveToKnowledgeTree(file, analysisResult);
                        
                        console.log('✅ File analysis and auto-save completed for:', file.name);
                        
                    } catch (error) {
                        console.error('❌ File analysis failed for:', file.name, error);
                        updateFileCardWithError(fileCard, file, error);
                    }
                }
                
            } finally {
                // 🔥 确保无论如何都重置处理标志
                window.isProcessingFiles = false;
                console.log('✅ File processing completed, processing flag reset');
                
                // 🧹 文件处理完成后延迟清理上传区域
                setTimeout(() => {
                    clearUploadArea();
                    console.log('🧹 Upload area cleared after successful processing');
                }, 2000);
            }
            // 延迟清理文件签名，允许相同文件在5秒后重新上传
            setTimeout(() => {
                window.lastProcessedSignature = null;
            }, 5000);
            console.log('✅ All files processed, reset processing flag');
            
            showNotification(`📁 ${files.length} file(s) uploaded successfully!`);
        }
        
        // 📄 显示文件文本内容
        function showFileTextContent(fileName, textContent) {
            console.log('📄 显示文件文本内容:', fileName);
            
            // 创建内容显示模态框
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.6); z-index: 5000; display: flex; 
                align-items: center; justify-content: center;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white; padding: 32px; border-radius: 16px; 
                width: 800px; max-width: 90vw; max-height: 80vh; overflow-y: auto;
                box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            `;
            
            modalContent.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 24px;">
                    <h2 style="margin: 0; color: #1f2937; display: flex; align-items: center; gap: 12px;">
                        📄 ${fileName}
                    </h2>
                    <button id="closeContent" style="
                        background: #f3f4f6; border: none; width: 32px; height: 32px; 
                        border-radius: 50%; cursor: pointer; font-size: 16px;
                    ">✕</button>
                </div>
                <div style="
                    background: #f9fafb; border-radius: 12px; padding: 24px; 
                    line-height: 1.6; font-size: 15px; color: #374151; white-space: pre-wrap;
                    max-height: 400px; overflow-y: auto;
                ">
                    ${textContent.replace(/\n/g, '<br>').replace(/\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;')}
                </div>
                <div style="margin-top: 24px; text-align: right;">
                    <button id="closeContentBtn" style="
                        padding: 10px 20px; background: linear-gradient(135deg, #6b7280, #4b5563); 
                        color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500;
                    ">Close</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // 添加关闭事件
            const closeBtn = modalContent.querySelector('#closeContent');
            const closeContentBtn = modalContent.querySelector('#closeContentBtn');
            
            const closeModal = () => {
                document.body.removeChild(modal);
            };
            
            closeBtn.addEventListener('click', closeModal);
            closeContentBtn.addEventListener('click', closeModal);
            
            // 点击背景关闭
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeModal();
                }
            });
        }
        
        // 🧠 简化且可靠的文件预览模态框
        function showIntelligentFileModal(fileName, fileData) {
            console.log('🧠 显示文档预览窗口:', fileName);
            
            // 清理现有模态框
            document.querySelectorAll('[style*="position: fixed"]').forEach(modal => {
                if (modal.style.zIndex >= '5000') {
                    modal.remove();
                }
            });
            console.log('🔍 文件数据结构:', {
                name: fileData.name,
                type: fileData.type,
                size: fileData.size,
                hasTextContent: !!fileData.textContent,
                textContentLength: fileData.textContent?.length || 0,
                hasLocalContent: !!fileData.hasLocalContent,
                dataLength: fileData.data?.length || 0,
                savedAt: fileData.savedAt,
                lastModified: fileData.lastModified
            });
            
            // 🔍 详细检查文本内容
            if (fileData.textContent) {
                console.log('📝 文本内容存在，长度:', fileData.textContent.length);
                console.log('📝 文本内容预览(前200字符):', fileData.textContent.substring(0, 200));
            } else {
                console.log('⚠️ 文本内容不存在，检查原因...');
            }
            
            // 🔍 检查GraphRAG分析数据
            const analysisDB = JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}');
            
            // 🔥 修复：查找包含文件名的键（因为键包含时间戳）
            const matchingKey = Object.keys(analysisDB).find(key => key.includes(fileName));
            const fileAnalysis = matchingKey ? analysisDB[matchingKey] : null;
            
            console.log('🧠 GraphRAG分析数据:', fileAnalysis ? '存在' : '不存在');
            console.log('🔑 匹配的键名:', matchingKey || '未找到');
            if (fileAnalysis) {
                console.log('📊 分析内容长度:', fileAnalysis.extractedContent?.length || 0);
                if (fileAnalysis.extractedContent) {
                    console.log('📊 分析内容预览:', fileAnalysis.extractedContent.substring(0, 200));
                }
            }
            
            // 创建模态框
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.7); z-index: 6000; display: flex; 
                align-items: center; justify-content: center;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white; border-radius: 20px; 
                width: 1200px; max-width: 95vw; max-height: 95vh; overflow-y: auto;
                box-shadow: 0 25px 80px rgba(0,0,0,0.4); animation: modalSlideIn 0.3s ease;
                display: flex; flex-direction: column;
            `;
            
            // 📊 文件信息分析
            const hasTextContent = fileData.textContent && fileData.textContent.length > 0;
            const hasFullContent = fileData.hasLocalContent && fileData.data;
            const fileSize = fileData.size ? (fileData.size / 1024 / 1024).toFixed(2) + 'MB' : 'Unknown';
            const fileIcon = getFileTypeIcon(fileData.type, fileName);
            
            // 🧠 不再在这里显示摘要，避免重复
            let graphragSummary = '';
            
            // 获取文件内容用于生成文档结构 - 优先使用GraphRAG分析结果
            let content;
            if (fileAnalysis && fileAnalysis.extractedContent) {
                console.log('🚀 使用GraphRAG增强内容生成文档结构');
                content = fileAnalysis.extractedContent;
            } else {
                console.log('⚠️ GraphRAG内容不可用，使用原始文本内容');
                content = fileData.textContent || `文档: ${fileName}\n类型: ${fileData.type}\n大小: ${(fileData.size / 1024 / 1024).toFixed(2)}MB`;
            }
            
            modalContent.innerHTML = `
                <!-- 头部 -->
                <div style="padding: 20px 30px; border-bottom: 1px solid #e5e7eb; display: flex; justify-content: space-between; align-items: center;">
                    <div style="display: flex; align-items: center; gap: 16px;">
                        <div style="font-size: 36px;">${fileIcon}</div>
                        <div>
                            <h2 style="margin: 0 0 4px 0; color: #1f2937; font-size: 20px;">${fileName}</h2>
                            <div style="color: #6b7280; font-size: 14px;">${fileData.type || 'Unknown type'} • ${fileSize}</div>
                        </div>
                    </div>
                    <button id="closeFileModal" style="
                        background: #f3f4f6; border: none; width: 36px; height: 36px; 
                        border-radius: 50%; cursor: pointer; font-size: 18px; color: #6b7280;
                        display: flex; align-items: center; justify-content: center;
                    ">✕</button>
                </div>
                
                <!-- 工具栏 -->
                <div style="padding: 15px 30px; border-bottom: 1px solid #e5e7eb; display: flex; justify-content: flex-end;">
                    <button onclick="console.log('🔧 编辑按钮点击'); openDocumentEditor('${fileName}')" style="
                        background: #3b82f6; color: white; border: none; 
                        padding: 10px 20px; border-radius: 8px; cursor: pointer; 
                        font-size: 14px; display: flex; align-items: center; gap: 8px; font-weight: 500;
                    ">
                        ✏️ Edit Document
                    </button>
                </div>
                
                <!-- 主要内容区域 -->
                <div style="flex: 1; display: grid; grid-template-columns: 400px 1fr; gap: 20px; padding: 20px 30px; overflow: hidden;">
                    <!-- 左侧：文档目录 -->
                    <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 12px; overflow: hidden; display: flex; flex-direction: column;">
                        <div style="background: #e2e8f0; padding: 12px 16px; border-bottom: 1px solid #d1d5db;">
                            <h4 style="margin: 0; color: #1f2937; font-size: 14px; font-weight: 600;">📋 Document Outline</h4>
                        </div>
                        <div style="flex: 1; padding: 12px; overflow-y: auto;" id="documentStructure">
                            <div style="text-align: center; padding: 40px 20px; color: #6b7280;">
                                <div style="font-size: 24px; margin-bottom: 12px;">📋</div>
                                <p style="margin: 0; font-size: 14px;">Loading document structure...</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 右侧：内容预览 -->
                    <div style="background: white; border: 1px solid #e2e8f0; border-radius: 12px; overflow: hidden; display: flex; flex-direction: column;">
                        <div style="background: #f8fafc; padding: 12px 16px; border-bottom: 1px solid #e2e8f0;">
                            <h4 style="margin: 0; color: #1f2937; font-size: 14px; font-weight: 600;">👁️ Content Preview</h4>
                        </div>
                        <div id="documentPreviewContent" style="
                            flex: 1; padding: 20px; overflow-y: auto;
                            line-height: 1.6; color: #374151; font-size: 15px;
                        ">
                            <div style="text-align: center; padding: 60px 20px; color: #9ca3af;">
                                <div style="font-size: 48px; margin-bottom: 16px;">📖</div>
                                <h3 style="margin: 0 0 8px 0; color: #6b7280;">Select a section to view content</h3>
                                <p style="margin: 0; font-size: 14px;">Click on any section in the left outline to view its content here</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 底部按钮 -->
                <div style="padding: 15px 30px; border-top: 1px solid #e5e7eb; display: flex; justify-content: flex-end;">
                    <button id="closeModalBtn" style="
                        padding: 8px 16px; background: #f3f4f6; color: #374151; border: none; 
                        border-radius: 6px; cursor: pointer; font-size: 14px;
                    ">Close</button>
                </div>
            `;
            
            // 添加模态窗口到页面
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // 🔥 重要：确保模态框DOM完全渲染后再重新生成文档结构  
            setTimeout(() => {
                const structureContainer = document.getElementById('documentStructure');
                if (structureContainer) {
                    try {
                        structureContainer.innerHTML = generateDocumentStructure(content, fileName);
                        console.log('🎯 模态框DOM完全渲染后重新生成文档结构');
                    } catch (error) {
                        console.error('重新生成文档结构失败:', error);
                        structureContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #6b7280;">文档结构生成失败</div>';
                    }
                }
            }, 50);
            
            // 事件处理
            const closeModal = () => {
                if (document.body.contains(modal)) {
                    document.body.removeChild(modal);
                }
            };
            
            // 绑定关闭事件
            modalContent.querySelector('#closeFileModal')?.addEventListener('click', closeModal);
            modalContent.querySelector('#closeModalBtn')?.addEventListener('click', closeModal);
            
            // 点击背景关闭
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeModal();
            });
        }
        
        // 📁 获取文件类型图标
        function getFileTypeIcon(mimeType, fileName) {
            if (mimeType?.includes('pdf') || fileName?.endsWith('.pdf')) return '📄';
            if (mimeType?.includes('word') || fileName?.endsWith('.doc') || fileName?.endsWith('.docx')) return '📝';
            if (mimeType?.includes('excel') || fileName?.endsWith('.xls') || fileName?.endsWith('.xlsx')) return '📊';
            if (mimeType?.includes('image')) return '🖼️';
            if (mimeType?.includes('text') || fileName?.endsWith('.txt') || fileName?.endsWith('.md')) return '📃';
            if (fileName?.endsWith('.json')) return '🔧';
            if (fileName?.endsWith('.csv')) return '📋';
            return '📄';
        }
        
        // 创建智能文件卡片
        async function createIntelligentFileCard(file, index) {
            const fileCard = document.createElement('div');
            fileCard.id = `file-card-${index}`;
            fileCard.style.cssText = `
                background: white; border: 2px solid #e2e8f0; border-radius: 12px;
                padding: 16px; margin-bottom: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                animation: slideInUp 0.5s ease ${index * 0.1}s both; position: relative;
            `;
            
            const fileInfo = getFileIcon(file.type) + ' ' + file.name + ' (' + formatFileSize(file.size) + ')';
            
            fileCard.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                    <span style="font-size: 14px; color: #374151; font-weight: 500;">${fileInfo}</span>
                    <button onclick="removeFile(this)" style="
                        background: #ef4444; color: white; border: none; 
                        padding: 6px 10px; border-radius: 6px; cursor: pointer; font-size: 12px;
                    ">Remove</button>
                </div>
                
                <!-- Processing Status -->
                <div id="processing-status-${index}" style="
                    background: linear-gradient(135deg, #667eea, #764ba2);
                    color: white; padding: 12px; border-radius: 8px; margin-bottom: 8px;
                ">
                    <div style="display: flex; align-items: center;">
                        <div class="spinner" style="
                            width: 16px; height: 16px; border: 2px solid rgba(255,255,255,0.3);
                            border-top: 2px solid white; border-radius: 50%; 
                            animation: spin 1s linear infinite; margin-right: 8px;
                        "></div>
                        <span style="font-size: 12px;">🚀 正在启动智能分析...</span>
                    </div>
                    <div style="
                        background: rgba(255,255,255,0.2); height: 4px; border-radius: 2px; 
                        margin-top: 8px; overflow: hidden;
                    ">
                        <div id="progress-bar-${index}" style="
                            background: white; height: 100%; width: 10%; border-radius: 2px;
                            transition: width 0.3s ease;
                        "></div>
                    </div>
                </div>
                
                <!-- Analysis Results (initially hidden) -->
                <div id="analysis-results-${index}" style="display: none;"></div>
                
                <!-- Knowledge Tree Suggestion (initially hidden) -->
                <div id="tree-suggestion-${index}" style="display: none;"></div>
            `;
            
            return fileCard;
        }
        
        // 更新文件卡片显示分析结果
        async function updateFileCardWithAnalysis(fileCard, file, analysisResult) {
            const index = fileCard.id.split('-')[2];
            const statusDiv = document.getElementById(`processing-status-${index}`);
            const resultsDiv = document.getElementById(`analysis-results-${index}`);
            
            // 隐藏处理状态
            statusDiv.style.display = 'none';
            
            // 显示分析结果
            resultsDiv.style.display = 'block';
            resultsDiv.innerHTML = `
                <div style="background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 8px; padding: 12px; margin-bottom: 8px;">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                        <h4 style="margin: 0; color: #0c4a6e; font-size: 14px;">
                            🧠 智能分析完成
                        </h4>
                        <div style="
                            background: ${analysisResult.processingStage === 'completed' ? '#10b981' : '#f59e0b'};
                            color: white; padding: 4px 8px; border-radius: 4px; font-size: 10px;
                        ">
                            ${analysisResult.processingStage === 'completed' ? '✅ 完成' : '⚠️ 部分完成'}
                        </div>
                    </div>
                    
                    <!-- 文档类型 -->
                    <div style="margin-bottom: 8px;">
                        <span style="font-size: 12px; color: #0369a1;">
                            📄 文档类型: <strong>${analysisResult.documentAnalysis?.fileType?.supportedFormat || 'Unknown'}</strong>
                        </span>
                    </div>
                    
                    <!-- 提取的实体 -->
                    ${analysisResult.entityAnalysis?.entities?.length > 0 ? `
                    <div style="margin-bottom: 8px;">
                        <div style="font-size: 12px; color: #0369a1; margin-bottom: 4px;">🔍 识别实体:</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 4px;">
                            ${analysisResult.entityAnalysis.entities.slice(0, 6).map(entity => `
                                <span style="
                                    background: #ddd6fe; color: #5b21b6; padding: 2px 6px; 
                                    border-radius: 10px; font-size: 10px;
                                ">
                                    ${typeof entity === 'string' ? entity : entity.value || entity.label}
                                </span>
                            `).join('')}
                            ${analysisResult.entityAnalysis.entities.length > 6 ? `
                                <span style="color: #6b7280; font-size: 10px;">+${analysisResult.entityAnalysis.entities.length - 6} more</span>
                            ` : ''}
                        </div>
                    </div>
                    ` : ''}
                    
                    <!-- 社区检测 -->
                    ${analysisResult.communityAnalysis?.totalCommunities > 0 ? `
                    <div style="margin-bottom: 8px;">
                        <span style="font-size: 12px; color: #0369a1;">
                            🏘️ 概念社区: <strong>${analysisResult.communityAnalysis.totalCommunities}</strong>
                        </span>
                    </div>
                    ` : ''}
                    
                    <!-- 处理时间 -->
                    <div style="text-align: right; margin-top: 8px;">
                        <span style="font-size: 10px; color: #6b7280;">
                            ⏱️ 分析耗时: ${analysisResult.processingTime || 0}ms
                        </span>
                    </div>
                </div>
            `;
        }
        
        // 显示知识树位置建议
        async function showKnowledgeTreeSuggestion(file, analysisResult, fileIndex) {
            const suggestionDiv = document.getElementById(`tree-suggestion-${fileIndex}`);
            if (!suggestionDiv) return;
            
            if (!analysisResult.positionSuggestion) return;
            
            suggestionDiv.style.display = 'block';
            suggestionDiv.innerHTML = `
                <div style="
                    background: linear-gradient(135deg, #10b981, #059669);
                    color: white; padding: 12px; border-radius: 8px; margin-bottom: 8px;
                ">
                    <h4 style="margin: 0 0 8px 0; font-size: 14px; display: flex; align-items: center;">
                        🌳 知识树位置建议
                        <div style="
                            background: rgba(255,255,255,0.2); padding: 2px 6px; border-radius: 4px; 
                            font-size: 10px; margin-left: 8px;
                        ">
                            ${safePercent(analysisResult.positionSuggestion.confidence)}% 置信度
                        </div>
                    </h4>
                    
                    <div style="background: rgba(255,255,255,0.1); padding: 8px; border-radius: 6px; margin-bottom: 8px;">
                        <div style="font-size: 12px; margin-bottom: 4px;">📍 推荐位置:</div>
                        <div style="font-weight: 600; font-size: 14px;">
                            ${analysisResult.positionSuggestion.primarySuggestion?.path || '其他/未分类'}
                        </div>
                    </div>
                    
                    ${analysisResult.positionSuggestion.reasoning ? `
                    <div style="font-size: 11px; opacity: 0.9; margin-bottom: 8px;">
                        💡 ${analysisResult.positionSuggestion.reasoning}
                    </div>
                    ` : ''}
                    
                    <div style="
                        background: rgba(255,255,255,0.1); color: rgba(255,255,255,0.9); 
                        padding: 8px 12px; border-radius: 6px; margin-top: 8px;
                        font-size: 11px; text-align: center; border: 1px solid rgba(255,255,255,0.2);
                    ">
                        ✅ 已自动保存到知识树
                    </div>
                </div>
            `;
        }
        
        // 更新处理进度
        function updateProcessingProgress(index, stage, progress) {
            const progressBar = document.getElementById(`progress-bar-${index}`);
            const statusText = document.querySelector(`#processing-status-${index} span`);
            
            if (progressBar && statusText) {
                progressBar.style.width = `${progress}%`;
                
                const stageMessages = {
                    'document_processing': '📄 处理文档格式...',
                    'entity_extraction': '🤖 提取实体关系...',
                    'community_detection': '🏘️ 检测概念社区...',
                    'position_suggestion': '🌳 生成位置建议...',
                    'completed': '✅ 分析完成!'
                };
                
                statusText.textContent = stageMessages[stage] || '🔄 处理中...';
            }
        }
        
        // 处理文件卡片错误
        function updateFileCardWithError(fileCard, file, error) {
            const index = fileCard.id.split('-')[2];
            const statusDiv = document.getElementById(`processing-status-${index}`);
            const resultsDiv = document.getElementById(`analysis-results-${index}`);
            
            statusDiv.style.display = 'none';
            resultsDiv.style.display = 'block';
            resultsDiv.innerHTML = `
                <div style="background: #fef2f2; border: 1px solid #ef4444; border-radius: 8px; padding: 12px;">
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <span style="color: #dc2626; font-size: 14px;">❌ 分析失败</span>
                    </div>
                    <div style="font-size: 12px; color: #7f1d1d; margin-bottom: 8px;">
                        ${error.message || '未知错误'}
                    </div>
                    <button onclick="retryAnalysis('${file.name}', ${index})" style="
                        background: #ef4444; color: white; border: none;
                        padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 11px;
                    ">
                        🔄 重试分析
                    </button>
                </div>
            `;
        }
        
        // 🔥 自动保存到知识树（无需用户确认）
        async function autoSaveToKnowledgeTree(file, analysisResult) {
            console.log('🤖 根据AI分析结果自动保存文件:', file.name);
            
            try {
                // 🔍 检查内容重复 - 基于URL或内容哈希
                const isDuplicate = await checkContentDuplicate(file, analysisResult);
                if (isDuplicate.found) {
                    console.log('⚠️ 检测到重复内容，跳过保存:', isDuplicate.reason);
                    showNotification(`⚠️ 内容已存在：${isDuplicate.existingFile} (${isDuplicate.reason})`, 'warning');
                    
                    // 直接导航到已存在的文件
                    setTimeout(() => {
                        openKnowledgePanel();
                        navigateToKnowledgeTree(isDuplicate.category, isDuplicate.existingFile);
                    }, 1000);
                    return;
                }
                
                // 🎯 改进分类准确性 - 基于内容类型和来源
                const improvedPath = improveClassificationAccuracy(file, analysisResult);
                console.log('📍 原AI路径:', analysisResult.positionSuggestion?.primarySuggestion?.path || '智能分类/AI分析');
                console.log('📍 优化后路径:', improvedPath);
                
                // 🔥 保存原始文件到本地（用于后续用本地工具打开）
                const fileStorageKey = await saveFileLocally(file);
                
                // 🔥 存储GraphRAG分析数据（用于知识图谱构建）
                await storeGraphRAGAnalysis(file.name, analysisResult);
                
                // 🔥 自动添加到知识树，使用优化的路径和存储键
                await addFileWithAIGuidanceAndStorage(file.name, improvedPath, analysisResult, file, fileStorageKey);
                
                // 显示成功通知（只显示主要分类）
                const mainCategory = improvedPath.split(/[/>]/).filter(p => p.trim())[0] || '智能分类';
                showNotification(`🎯 AI已自动将 "${file.name}" 分类到 "${mainCategory}"`, 'success');
                
                // 🔄 自动跳转到知识库显示结果
                setTimeout(() => {
                    openKnowledgePanel();
                    navigateToKnowledgeTree(mainCategory, file.name);
                }, 1000);
                
                console.log('✅ 文件已自动保存到知识树');
                
            } catch (error) {
                console.error('❌ 自动保存失败:', error);
                showNotification(`❌ 自动保存失败: ${error.message}`, 'error');
            }
        }
        
        // 🔍 检查内容重复 - 基于URL、内容哈希或相似性检测
        async function checkContentDuplicate(file, analysisResult) {
            console.log('🔍 开始检查内容重复:', file.name);
            
            try {
                const knowledgeTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
                
                // 1. 检查URL重复（对于网页内容）
                if (file.sourceUrl) {
                    for (const [categoryName, categoryData] of Object.entries(knowledgeTree)) {
                        if (categoryData.files) {
                            for (const existingFile of categoryData.files) {
                                // 检查是否是同一个URL
                                const storedFileData = localStorage.getItem(existingFile.storageKey);
                                if (storedFileData) {
                                    const fileData = JSON.parse(storedFileData);
                                    if (fileData.sourceUrl === file.sourceUrl) {
                                        return {
                                            found: true,
                                            reason: '相同URL',
                                            existingFile: existingFile.name,
                                            category: categoryName,
                                            url: file.sourceUrl
                                        };
                                    }
                                }
                            }
                        }
                    }
                }
                
                // 2. 检查内容哈希重复（对于文件内容）
                const currentContent = analysisResult.analysis?.content || analysisResult.content || '';
                if (currentContent.length > 100) {
                    // 生成内容哈希
                    const contentHash = await generateContentHash(currentContent);
                    
                    for (const [categoryName, categoryData] of Object.entries(knowledgeTree)) {
                        if (categoryData.files) {
                            for (const existingFile of categoryData.files) {
                                // 检查现有文件的内容哈希
                                const storedFileData = localStorage.getItem(existingFile.storageKey);
                                if (storedFileData) {
                                    const fileData = JSON.parse(storedFileData);
                                    const existingContent = fileData.textContent || '';
                                    
                                    if (existingContent.length > 100) {
                                        const existingHash = await generateContentHash(existingContent);
                                        if (contentHash === existingHash) {
                                            return {
                                                found: true,
                                                reason: '内容完全相同',
                                                existingFile: existingFile.name,
                                                category: categoryName,
                                                similarity: 1.0
                                            };
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                // 3. 检查内容相似性（标题相似度检测）
                const currentTitle = analysisResult.analysis?.fileInfo?.filename || file.name;
                for (const [categoryName, categoryData] of Object.entries(knowledgeTree)) {
                    if (categoryData.files) {
                        for (const existingFile of categoryData.files) {
                            const similarity = calculateStringSimilarity(currentTitle, existingFile.name);
                            if (similarity > 0.85) { // 85%以上相似度认为可能重复
                                // 进一步检查内容相似性
                                const storedFileData = localStorage.getItem(existingFile.storageKey);
                                if (storedFileData) {
                                    const fileData = JSON.parse(storedFileData);
                                    const existingContent = fileData.textContent || '';
                                    const currentContent = analysisResult.analysis?.content || analysisResult.content || '';
                                    
                                    const contentSimilarity = calculateContentSimilarity(currentContent, existingContent);
                                    if (contentSimilarity > 0.8) { // 80%以上内容相似度
                                        return {
                                            found: true,
                                            reason: `高度相似 (${Math.round(similarity * 100)}%标题相似, ${Math.round(contentSimilarity * 100)}%内容相似)`,
                                            existingFile: existingFile.name,
                                            category: categoryName,
                                            similarity: Math.max(similarity, contentSimilarity)
                                        };
                                    }
                                }
                            }
                        }
                    }
                }
                
                console.log('✅ 未发现重复内容');
                return { found: false };
                
            } catch (error) {
                console.error('❌ 检查重复内容失败:', error);
                return { found: false };
            }
        }
        
        // 🎯 改进分类准确性 - 基于内容类型、来源和实际内容分析
        function improveClassificationAccuracy(file, analysisResult) {
            console.log('🎯 开始改进分类准确性');
            
            try {
                // 获取原始AI建议路径
                const originalPath = analysisResult.positionSuggestion?.primarySuggestion?.path || '智能分类/AI分析';
                
                // 1. 基于文件来源的分类优化
                if (file.sourceUrl) {
                    const url = new URL(file.sourceUrl);
                    const hostname = url.hostname.toLowerCase();
                    
                    // YouTube视频分类
                    if (hostname.includes('youtube.com') || hostname.includes('youtu.be')) {
                        const title = analysisResult.analysis?.fileInfo?.filename || file.name;
                        
                        // 音乐类内容
                        if (title.match(/(music|song|album|artist|mv|official|video)/i) ||
                            analysisResult.analysis?.content?.match(/♪|♫|lyrics|歌词/g)) {
                            return '多媒体内容/YouTube/音乐视频';
                        }
                        
                        // 教育类内容
                        if (title.match(/(tutorial|course|lesson|education|learn|how to)/i) ||
                            analysisResult.analysis?.concepts?.some(c => 
                                c.match(/(教程|课程|学习|教育|培训)/i))) {
                            return '学习资料/在线教程/YouTube教学';
                        }
                        
                        // 技术类内容
                        if (analysisResult.analysis?.concepts?.some(c => 
                            c.match(/(技术|编程|开发|coding|programming|tech)/i))) {
                            return '技术资料/视频教程/YouTube技术';
                        }
                        
                        // 默认YouTube分类
                        return '多媒体内容/YouTube/视频内容';
                    }
                    
                    // GitHub项目分类
                    if (hostname.includes('github.com')) {
                        // 检测编程语言
                        const content = analysisResult.analysis?.content || '';
                        if (content.includes('package.json') || content.includes('node_modules')) {
                            return '技术资料/开源项目/JavaScript项目';
                        }
                        if (content.includes('requirements.txt') || content.includes('setup.py')) {
                            return '技术资料/开源项目/Python项目';
                        }
                        if (content.includes('Cargo.toml') || content.includes('.rs')) {
                            return '技术资料/开源项目/Rust项目';
                        }
                        if (content.includes('pom.xml') || content.includes('.java')) {
                            return '技术资料/开源项目/Java项目';
                        }
                        return '技术资料/开源项目/代码仓库';
                    }
                    
                    // 其他网站分类
                    return `网页内容/${hostname.replace('www.', '')}/网页资料`;
                }
                
                // 2. 基于文件类型的分类优化
                const fileExtension = file.name.split('.').pop()?.toLowerCase();
                if (fileExtension) {
                    const documentTypes = ['pdf', 'doc', 'docx', 'txt', 'md', 'rtf'];
                    const imageTypes = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'webp'];
                    const codeTypes = ['js', 'ts', 'py', 'java', 'cpp', 'c', 'rs', 'go', 'php'];
                    const dataTypes = ['json', 'csv', 'xml', 'yaml', 'yml'];
                    
                    if (documentTypes.includes(fileExtension)) {
                        // 基于内容进一步分类文档
                        const concepts = analysisResult.analysis?.concepts || [];
                        if (concepts.some(c => c.match(/(技术|编程|开发|API|代码)/i))) {
                            return `文档资料/技术文档/${fileExtension.toUpperCase()}文件`;
                        }
                        if (concepts.some(c => c.match(/(商业|业务|管理|报告)/i))) {
                            return `文档资料/商业文档/${fileExtension.toUpperCase()}文件`;
                        }
                        return `文档资料/一般文档/${fileExtension.toUpperCase()}文件`;
                    }
                    
                    if (imageTypes.includes(fileExtension)) {
                        return `多媒体内容/图片文件/${fileExtension.toUpperCase()}图片`;
                    }
                    
                    if (codeTypes.includes(fileExtension)) {
                        return `技术资料/源代码/${fileExtension.toUpperCase()}代码`;
                    }
                    
                    if (dataTypes.includes(fileExtension)) {
                        return `数据文件/结构化数据/${fileExtension.toUpperCase()}数据`;
                    }
                }
                
                // 3. 基于内容概念的分类优化
                const concepts = analysisResult.analysis?.concepts || [];
                const entities = analysisResult.analysis?.entities || [];
                const allTerms = [...concepts, ...entities].join(' ').toLowerCase();
                
                // 技术相关内容
                if (allTerms.match(/(技术|开发|编程|代码|api|系统|架构|framework|库)/)) {
                    return '技术资料/开发文档/技术分析';
                }
                
                // 学习相关内容
                if (allTerms.match(/(学习|教育|课程|教程|培训|知识|学科)/)) {
                    return '学习资料/教育内容/知识文档';
                }
                
                // 商业相关内容
                if (allTerms.match(/(商业|业务|管理|市场|营销|策略|方案)/)) {
                    return '商业资料/业务文档/管理资料';
                }
                
                // 4. 使用原始AI路径但改进主要分类
                const pathParts = originalPath.split(/[/>]/).filter(p => p.trim());
                if (pathParts.length > 0) {
                    const mainCategory = pathParts[0];
                    
                    // 改进主要分类的准确性
                    const improvedMainCategory = improveMainCategoryName(mainCategory, allTerms);
                    
                    // 重构路径
                    if (improvedMainCategory !== mainCategory) {
                        return `${improvedMainCategory}/${pathParts.slice(1).join('/')}`;
                    }
                }
                
                console.log('📍 使用原始AI路径:', originalPath);
                return originalPath;
                
            } catch (error) {
                console.error('❌ 改进分类准确性失败:', error);
                return analysisResult.positionSuggestion?.primarySuggestion?.path || '智能分类/AI分析';
            }
        }
        
        // 🔧 辅助函数：改进主要分类名称
        function improveMainCategoryName(categoryName, contentTerms) {
            const categoryLower = categoryName.toLowerCase();
            
            // 技术类别映射
            if (categoryLower.match(/(tech|技术|开发|代码|programming)/)) {
                return '技术资料';
            }
            
            // 学习类别映射
            if (categoryLower.match(/(learn|学习|教育|course|tutorial)/)) {
                return '学习资料';
            }
            
            // 文档类别映射
            if (categoryLower.match(/(document|文档|doc|资料)/)) {
                if (contentTerms.match(/(技术|开发|api|代码)/)) {
                    return '技术资料';
                }
                if (contentTerms.match(/(商业|业务|管理)/)) {
                    return '商业资料';
                }
                return '文档资料';
            }
            
            // 多媒体类别映射
            if (categoryLower.match(/(media|多媒体|视频|音频|图片)/)) {
                return '多媒体内容';
            }
            
            return categoryName; // 如果没有匹配，保持原名
        }
        
        // 🔨 辅助函数：生成内容哈希
        async function generateContentHash(content) {
            // 简化的哈希函数（基于内容的前1000字符）
            const normalizedContent = content.trim().substring(0, 1000).replace(/\s+/g, ' ');
            let hash = 0;
            for (let i = 0; i < normalizedContent.length; i++) {
                const char = normalizedContent.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // 转为32位整数
            }
            return hash.toString();
        }
        
        // 🔨 辅助函数：计算字符串相似度
        function calculateStringSimilarity(str1, str2) {
            if (!str1 || !str2) return 0;
            
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;
            
            if (longer.length === 0) return 1.0;
            
            const distance = levenshteinDistance(longer, shorter);
            return (longer.length - distance) / longer.length;
        }
        
        // 🔨 辅助函数：计算内容相似度
        function calculateContentSimilarity(content1, content2) {
            if (!content1 || !content2) return 0;
            
            // 基于关键词重叠度计算相似性
            const words1 = content1.toLowerCase().split(/\s+/).filter(w => w.length > 3);
            const words2 = content2.toLowerCase().split(/\s+/).filter(w => w.length > 3);
            
            if (words1.length === 0 || words2.length === 0) return 0;
            
            const uniqueWords1 = new Set(words1);
            const uniqueWords2 = new Set(words2);
            
            const intersection = new Set([...uniqueWords1].filter(w => uniqueWords2.has(w)));
            const union = new Set([...uniqueWords1, ...uniqueWords2]);
            
            return union.size > 0 ? intersection.size / union.size : 0;
        }
        
        // 🔨 辅助函数：编辑距离算法
        function levenshteinDistance(str1, str2) {
            const matrix = [];
            
            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }
            
            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }
            
            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            
            return matrix[str2.length][str1.length];
        }
        
        // 💾 智能存储管理器
        const StorageManager = {
            // 存储策略配置
            config: {
                localStorageLimit: 100 * 1024 * 1024, // 增加到100MB限制
                maxFileSize: 10 * 1024 * 1024, // 10MB以下存储完整内容
                textContentLimit: 500 * 1024, // 增加到500KB文本内容限制
                cleanupThreshold: 0.6, // 60%时开始清理
                maxFiles: 500, // 最多存储500个文件
                compressionEnabled: true, // 启用压缩
                cloudStorageEnabled: false // 未来扩展
            },
            
            // 检查存储空间
            checkStorage() {
                const usedSpace = new Blob(Object.values(localStorage)).size;
                const remainingSpace = this.config.localStorageLimit - usedSpace;
                
                console.log('💾 存储使用情况:', {
                    used: (usedSpace / 1024 / 1024).toFixed(2) + 'MB',
                    remaining: (remainingSpace / 1024 / 1024).toFixed(2) + 'MB',
                    utilization: Math.round((usedSpace / this.config.localStorageLimit) * 100) + '%'
                });
                
                return { usedSpace, remainingSpace };
            },
            
            // 智能存储策略
            async saveFile(file) {
                console.log('💾 开始智能文件存储:', file.name);
                
                try {
                    const { remainingSpace } = this.checkStorage();
                    
                    // 强制清理存储空间
                    console.log('🧹 执行强制存储清理...');
                    await this.forceStorageCleanup();
                    
                    // 重新检查空间
                    const newCheck = this.checkStorage();
                    console.log('🔍 清理后存储状态:', {
                        used: (newCheck.usedSpace / 1024 / 1024).toFixed(2) + 'MB',
                        remaining: (newCheck.remainingSpace / 1024 / 1024).toFixed(2) + 'MB'
                    });
                    
                    // 创建优化的文件数据结构
                    const fileData = await this.createOptimizedFileData(file);
                    
                    // 生成存储键
                    const storageKey = `file_${file.name}_${Date.now()}`;
                    
                    // 尝试存储，如果失败则先清理再重试
                    try {
                        localStorage.setItem(storageKey, JSON.stringify(fileData));
                        console.log('✅ 文件存储成功:', storageKey);
                        return storageKey;
                    } catch (quotaError) {
                        console.log('⚠️ 存储配额不足，执行自动清理...');
                        
                        // 执行智能清理
                        await this.smartCleanup();
                        
                        // 清理后重试存储
                        try {
                            localStorage.setItem(storageKey, JSON.stringify(fileData));
                            console.log('✅ 清理后存储成功:', storageKey);
                            return storageKey;
                        } catch (retryError) {
                            console.log('⚠️ 清理后仍无法存储，压缩内容...');
                            
                            // 压缩内容：只保留前50000字符
                            if (fileData.textContent.length > 50000) {
                                fileData.textContent = fileData.textContent.substring(0, 50000) + '\n\n... (内容已截断，节省存储空间)';
                                fileData.storageMode = 'compressed';
                            }
                            
                            try {
                                localStorage.setItem(storageKey, JSON.stringify(fileData));
                                console.log('✅ 压缩后存储成功:', storageKey);
                                return storageKey;
                            } catch (finalError) {
                                console.log('⚠️ 最终使用极简模式...');
                                const minimalData = this.createMinimalFileData(file);
                                localStorage.setItem(storageKey, JSON.stringify(minimalData));
                                console.log('✅ 极简模式存储成功:', storageKey);
                                return storageKey;
                            }
                        }
                    }
                    
                } catch (error) {
                    console.error('❌ 文件存储失败:', error);
                    // 显示用户友好的错误信息
                    this.showStorageUpgradePrompt();
                    throw error;
                }
            },
            
            // 创建优化的文件数据
            async createOptimizedFileData(file) {
                const fileData = {
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    lastModified: file.lastModified,
                    savedAt: new Date().toISOString(),
                    hasLocalContent: false,
                    textContent: null,
                    storageMode: 'optimized'
                };
                
                // 只对小文件存储完整内容
                if (file.size <= this.config.maxFileSize && !file.type.includes('pdf')) {
                    const arrayBuffer = await file.arrayBuffer();
                    fileData.data = Array.from(new Uint8Array(arrayBuffer));
                    fileData.hasLocalContent = true;
                    console.log('📄 小文件，存储完整内容');
                } else {
                    console.log('📄 大文件，仅存储元数据和文本');
                }
                
                // 提取并限制文本内容
                try {
                    let text = await extractTextFromFile(file);
                    if (text.length > this.config.textContentLimit) {
                        text = text.substring(0, this.config.textContentLimit) + '\n\n📋 内容已优化截断，完整内容请使用本地工具打开或升级存储空间';
                    }
                    fileData.textContent = text;
                } catch (error) {
                    fileData.textContent = `📄 ${file.name}\n存储空间优化模式\n完整内容分析请升级存储方案`;
                }
                
                return fileData;
            },
            
            // 创建极简文件数据（紧急情况）
            createMinimalFileData(file) {
                return {
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    savedAt: new Date().toISOString(),
                    storageMode: 'minimal',
                    textContent: `📄 ${file.name}\n\n⚠️ 存储空间已满\n这是极简存储模式，仅保存基本信息。\n\n💡 建议：\n• 清理旧文件释放空间\n• 升级到云存储方案\n• 使用本地工具打开完整文件`,
                    hasLocalContent: false
                };
            },
            
            // 智能清理策略
            async smartCleanup() {
                console.log('🧹 开始智能清理...');
                
                const keys = Object.keys(localStorage);
                const fileKeys = keys.filter(key => key.startsWith('file_'));
                
                if (fileKeys.length === 0) {
                    console.log('🧹 没有文件需要清理');
                    return;
                }
                
                console.log(`🧹 发现 ${fileKeys.length} 个文件，开始清理...`);
                
                // 按时间排序，优先删除最旧的
                const sortedKeys = fileKeys.sort((a, b) => {
                    const timeA = parseInt(a.split('_').pop()) || 0;
                    const timeB = parseInt(b.split('_').pop()) || 0;
                    return timeA - timeB;
                });
                
                // 更激进的清理策略：删除最旧的50%文件
                const deleteCount = Math.max(1, Math.floor(sortedKeys.length * 0.5));
                
                for (let i = 0; i < deleteCount; i++) {
                    const key = sortedKeys[i];
                    try {
                        localStorage.removeItem(key);
                        console.log('🗑️ 清理旧文件:', key);
                    } catch (error) {
                        console.error('❌ 清理文件失败:', key, error);
                    }
                }
                
                // 额外清理：删除所有极简模式的文件
                const remainingKeys = Object.keys(localStorage).filter(key => key.startsWith('file_'));
                let minimalCleared = 0;
                
                for (const key of remainingKeys) {
                    try {
                        const data = JSON.parse(localStorage.getItem(key) || '{}');
                        if (data.storageMode === 'minimal') {
                            localStorage.removeItem(key);
                            minimalCleared++;
                            console.log('🗑️ 清理极简模式文件:', key);
                        }
                    } catch (error) {
                        // 损坏的数据也删除
                        localStorage.removeItem(key);
                        console.log('🗑️ 清理损坏文件:', key);
                    }
                }
                
                console.log(`✅ 智能清理完成，释放了 ${deleteCount + minimalCleared} 个文件的空间`);
            },
            
            // 主动存储维护
            async proactiveMaintenance() {
                const keys = Object.keys(localStorage);
                const fileKeys = keys.filter(key => key.startsWith('file_'));
                
                // 如果文件数量超过10个，自动清理
                if (fileKeys.length > 10) {
                    console.log(`🔧 检测到 ${fileKeys.length} 个存储文件，执行主动维护`);
                    await this.smartCleanup();
                }
                
                // 检查存储使用情况
                const storageSize = JSON.stringify(localStorage).length;
                const maxSize = 5 * 1024 * 1024; // 5MB估计限制
                
                if (storageSize > maxSize * 0.8) {
                    console.log('🔧 存储使用率过高，执行预防性清理');
                    await this.smartCleanup();
                }
            },
            
            // 显示存储升级提示
            showStorageUpgradePrompt() {
                const message = `
🔄 存储空间优化建议

当前使用本地存储已接近上限。建议：

💡 立即可做：
• 删除不需要的旧文件
• 系统会自动清理最旧的文件

🚀 升级方案：
• 云存储空间：无限量文件存储
• 跨设备同步：手机、电脑无缝切换  
• 高级AI分析：更深度的内容洞察
• 数据安全：专业级加密保护

是否需要了解云存储升级方案？
                `;
                
                console.log(message);
                this.showStorageStatusModal();
            },
            
            // 显示存储状态模态框
            showStorageStatusModal() {
                const { usedSpace, remainingSpace } = this.checkStorage();
                const utilizationPercent = Math.round((usedSpace / this.config.localStorageLimit) * 100);
                
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                    background: rgba(0,0,0,0.7); z-index: 10000; display: flex; 
                    align-items: center; justify-content: center;
                `;
                
                modal.innerHTML = `
                    <div style="
                        background: white; border-radius: 20px; padding: 30px; 
                        width: 500px; max-width: 90vw; box-shadow: 0 25px 80px rgba(0,0,0,0.3);
                    ">
                        <div style="text-align: center; margin-bottom: 24px;">
                            <div style="font-size: 48px; margin-bottom: 12px;">💾</div>
                            <h2 style="margin: 0; color: #1f2937;">存储空间管理</h2>
                        </div>
                        
                        <div style="background: #f8fafc; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                                <span style="font-weight: 600; color: #374151;">本地存储使用情况</span>
                                <span style="color: ${utilizationPercent > 80 ? '#ef4444' : '#10b981'}; font-weight: 600;">
                                    ${utilizationPercent}%
                                </span>
                            </div>
                            <div style="
                                background: #e5e7eb; height: 12px; border-radius: 6px; overflow: hidden;
                            ">
                                <div style="
                                    background: ${utilizationPercent > 80 ? '#ef4444' : '#10b981'}; 
                                    height: 100%; width: ${utilizationPercent}%; 
                                    border-radius: 6px; transition: width 0.3s ease;
                                "></div>
                            </div>
                            <div style="
                                display: flex; justify-content: space-between; 
                                margin-top: 8px; font-size: 14px; color: #6b7280;
                            ">
                                <span>已用: ${(usedSpace / 1024 / 1024).toFixed(2)}MB</span>
                                <span>剩余: ${(remainingSpace / 1024 / 1024).toFixed(2)}MB</span>
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 24px;">
                            <h3 style="margin: 0 0 12px 0; color: #1f2937;">💡 优化建议</h3>
                            <div style="color: #4b5563; line-height: 1.6;">
                                ${utilizationPercent > 90 ? 
                                    `⚠️ 存储空间严重不足，系统已启用极简模式<br>
                                     • 自动清理最旧的文件<br>
                                     • 仅保存文件基本信息<br>
                                     • 建议立即升级存储方案` :
                                utilizationPercent > 70 ?
                                    `🔄 存储空间紧张，已启用优化模式<br>
                                     • 限制文本内容长度<br>
                                     • 大文件不存储完整内容<br>
                                     • 建议考虑升级存储` :
                                    `✅ 存储空间充足<br>
                                     • 系统运行正常<br>
                                     • 文件完整存储<br>
                                     • 继续享受智能工作流`
                                }
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 24px; padding: 16px; background: #dbeafe; border-radius: 8px;">
                            <h4 style="margin: 0 0 8px 0; color: #1e40af;">🚀 云存储升级方案</h4>
                            <div style="color: #1e40af; font-size: 14px; line-height: 1.5;">
                                • <strong>无限存储空间</strong>：支持大量文件上传<br>
                                • <strong>跨设备同步</strong>：手机、平板、电脑无缝访问<br>
                                • <strong>数据安全保护</strong>：企业级加密和备份<br>
                                • <strong>高级AI分析</strong>：更深度的内容洞察
                            </div>
                        </div>
                        
                        <div style="display: flex; gap: 12px; justify-content: center; margin-bottom: 16px;">
                            <button onclick="StorageManager.performQuickCleanup(); this.parentElement.parentElement.parentElement.remove();" style="
                                background: #10b981; border: none; padding: 12px 24px; 
                                border-radius: 8px; cursor: pointer; color: white; font-weight: 600;
                            ">🧹 立即清理</button>
                            <button onclick="StorageManager.clearOldAnalysisData(); this.parentElement.parentElement.parentElement.remove();" style="
                                background: #f59e0b; border: none; padding: 12px 24px; 
                                border-radius: 8px; cursor: pointer; color: white; font-weight: 600;
                            ">🗑️ 清理旧数据</button>
                        </div>
                        
                        <div style="display: flex; gap: 12px; justify-content: flex-end;">
                            <button onclick="this.parentElement.parentElement.parentElement.remove()" style="
                                background: #f3f4f6; border: none; padding: 8px 16px; 
                                border-radius: 6px; cursor: pointer; color: #374151; font-size: 14px;
                            ">稍后提醒</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // 点击背景关闭
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            },
            
            // 快速清理函数
            performQuickCleanup() {
                console.log('🧹 开始快速存储清理...');
                try {
                    // 清理临时章节数据
                    let sectionsCleared = 0;
                    Object.keys(window).filter(key => key.startsWith('sections_')).forEach(key => {
                        delete window[key];
                        sectionsCleared++;
                    });
                    
                    // 清理知识树中的大文件数据，保留文本摘要
                    const knowledgeTreeData = JSON.parse(localStorage.getItem('knowledgeTreeData') || '{}');
                    let fileDataCleared = 0;
                    Object.keys(knowledgeTreeData).forEach(key => {
                        const item = knowledgeTreeData[key];
                        if (item.data && item.data.length > 100000) { // 清理大于100KB的数据
                            item.data = null;
                            fileDataCleared++;
                        }
                    });
                    
                    if (fileDataCleared > 0) {
                        localStorage.setItem('knowledgeTreeData', JSON.stringify(knowledgeTreeData));
                    }
                    
                    showNotification(`🧹 快速清理完成！清理了${sectionsCleared}个临时数据和${fileDataCleared}个大文件`);
                    console.log('✅ 快速清理完成');
                    
                } catch (error) {
                    console.error('❌ 快速清理失败:', error);
                    showNotification('❌ 清理失败，请稍后重试');
                }
            },
            
            // 强制清理存储空间
            async forceStorageCleanup() {
                console.log('🧹 开始强制存储清理...');
                try {
                    // 1. 立即清理所有临时数据
                    Object.keys(window).filter(key => key.startsWith('sections_')).forEach(key => {
                        delete window[key];
                    });
                    console.log('✅ 清理了所有临时章节数据');
                    
                    // 2. 大幅简化GraphRAG分析数据库，只保留最新5个
                    const analysisDB = JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}');
                    const keys = Object.keys(analysisDB);
                    if (keys.length > 5) {
                        const sortedKeys = keys.sort((a, b) => {
                            const timestampA = a.split('_').pop() || '0';
                            const timestampB = b.split('_').pop() || '0';
                            return parseInt(timestampB) - parseInt(timestampA);
                        });
                        const keysToKeep = sortedKeys.slice(0, 5);
                        const cleanedDB = {};
                        keysToKeep.forEach(key => {
                            // 只保留核心信息，去掉大的内容
                            const item = analysisDB[key];
                            cleanedDB[key] = {
                                fileName: item.fileName,
                                extractedContent: item.extractedContent || '', // 保留完整内容
                                entities: item.entities || [],
                                timestamp: item.timestamp
                            };
                        });
                        localStorage.setItem('graphRAGAnalysisDB', JSON.stringify(cleanedDB));
                        console.log('✅ 清理了', keys.length - 5, '个分析数据，压缩了内容');
                    }
                    
                    // 3. 清理知识树中的所有文件数据，只保留基本信息
                    const knowledgeTreeData = JSON.parse(localStorage.getItem('knowledgeTreeData') || '{}');
                    let cleaned = 0;
                    Object.keys(knowledgeTreeData).forEach(key => {
                        const item = knowledgeTreeData[key];
                        if (item.data) {
                            item.data = null; // 完全清理文件数据
                            cleaned++;
                        }
                        if (item.textContent && item.textContent.length > 50000) {
                            // 只在内容超过50KB时才截断
                            item.textContent = item.textContent.substring(0, 50000) + '\n\n[为节省存储空间，内容已截断]';
                        }
                    });
                    if (cleaned > 0) {
                        localStorage.setItem('knowledgeTreeData', JSON.stringify(knowledgeTreeData));
                        console.log('✅ 清理了', cleaned, '个文件的存储数据');
                    }
                    
                    // 4. 清理其他可能的大数据
                    ['fileProcessingResults', 'uploadHistory', 'analysisCache'].forEach(key => {
                        if (localStorage.getItem(key)) {
                            localStorage.removeItem(key);
                            console.log('✅ 清理了', key);
                        }
                    });
                    
                    console.log('✅ 强制清理完成');
                    return true;
                    
                } catch (error) {
                    console.error('❌ 强制清理失败:', error);
                    return false;
                }
            },
            
            // 清理旧分析数据
            clearOldAnalysisData() {
                console.log('🗑️ 开始清理旧分析数据...');
                try {
                    const analysisDB = JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}');
                    const keys = Object.keys(analysisDB);
                    
                    if (keys.length > 10) {
                        // 只保留最新的10个分析结果
                        const sortedKeys = keys.sort((a, b) => {
                            const timestampA = a.split('_').pop() || '0';
                            const timestampB = b.split('_').pop() || '0';
                            return parseInt(timestampB) - parseInt(timestampA);
                        });
                        
                        const keysToKeep = sortedKeys.slice(0, 10);
                        const cleanedDB = {};
                        keysToKeep.forEach(key => {
                            cleanedDB[key] = analysisDB[key];
                        });
                        
                        localStorage.setItem('graphRAGAnalysisDB', JSON.stringify(cleanedDB));
                        
                        const deletedCount = keys.length - keysToKeep.length;
                        showNotification(`🗑️ 清理完成！删除了${deletedCount}个旧分析数据，释放了存储空间`);
                        console.log('✅ 清理了', deletedCount, '个旧分析数据');
                    } else {
                        showNotification('💡 当前分析数据不多，无需清理');
                    }
                    
                } catch (error) {
                    console.error('❌ 清理分析数据失败:', error);
                    showNotification('❌ 清理失败，请稍后重试');
                }
            }
        };
        
        // 💾 保存文件元数据（使用智能存储管理器）
        async function saveFileLocally(file) {
            return await StorageManager.saveFile(file);
        }
        
        // 🧹 页面加载时执行一次存储清理
        window.addEventListener('DOMContentLoaded', function() {
            setTimeout(async () => {
                try {
                    console.log('🧹 执行启动时存储检查和清理...');
                    
                    // 执行主动存储维护
                    await StorageManager.proactiveMaintenance();
                    
                    const { usedSpace } = StorageManager.checkStorage();
                    
                    // 如果使用超过50MB，立即清理
                    if (usedSpace > 50 * 1024 * 1024) {
                        console.log('⚠️ 存储使用量过大，执行自动清理');
                        await StorageManager.forceStorageCleanup();
                        showNotification('🧹 已自动清理存储空间，可以正常使用了');
                    } else {
                        console.log('✅ 存储空间健康，当前使用:', (usedSpace / (1024 * 1024)).toFixed(2) + 'MB');
                    }
                } catch (error) {
                    console.error('❌ 启动清理失败:', error);
                }
            }, 2000);
        });
        
        // 创建备用文档结构
        function createFallbackStructure(fileName, originalContent = '') {
            console.log('📋 创建备用文档结构:', fileName);
            console.log('📋 原始内容长度:', originalContent.length);
            
            const displayContent = originalContent || '文档内容加载中或内容为空。请尝试重新上传文件或检查文件内容。';
            const sections = [{
                id: 'section_0',
                title: '📄 文档内容',
                preview: displayContent.length > 60 ? displayContent.substring(0, 60) + '...' : displayContent,
                content: displayContent,
                wordCount: displayContent.split(/\s+/).length
            }];
            
            // 存储备用章节数据
            window[`sections_${fileName.replace(/[^a-zA-Z0-9]/g, '_')}`] = sections;
            
            return `
                <div style="margin-bottom: 16px;">
                    <div style="
                        background: #fef3c7; color: #92400e; padding: 12px; 
                        border-radius: 8px; font-size: 13px; text-align: center;
                    ">
                        📄 1 section • Content loading...
                    </div>
                </div>
                <div onclick="showSectionInModal('section_0', '${fileName}')" style="
                    padding: 12px; margin-bottom: 8px; border-radius: 8px; 
                    background: white; border: 1px solid #e2e8f0; cursor: pointer;
                    transition: all 0.2s ease;
                " onmouseover="this.style.backgroundColor='#f0f9ff'; this.style.borderColor='#3b82f6'" 
                   onmouseout="this.style.backgroundColor='white'; this.style.borderColor='#e2e8f0'">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 6px;">
                        <span style="font-weight: 600; color: #1f2937; font-size: 13px;">📄 文档内容</span>
                        <span style="font-size: 11px; color: #6b7280;">0 words</span>
                    </div>
                    <div style="color: #4b5563; font-size: 12px; line-height: 1.4;">
                        点击查看完整文档内容...
                    </div>
                </div>
            `;
        }

        // 📋 生成文档结构目录
        function generateDocumentStructure(content, fileName) {
            console.log('📋 生成文档结构目录:', fileName);
            console.log('📋 内容长度:', content.length);
            console.log('📋 内容类型:', typeof content);
            console.log('📋 内容前200字符:', content.substring(0, 200));
            
            // 强制处理空或无效内容
            if (!content || content.length < 10) {
                console.warn('⚠️ 内容为空或太短，使用备用结构');
                return createFallbackStructure(fileName, content);
            }
            
            try {
                // 多种方式分割内容以获得更好的结构
                let paragraphs = [];
                
                // 智能分段：优先使用有意义的分割点
                paragraphs = [];
                
                // 方法1: 按双换行分割（最理想的段落分隔）
                let tempParagraphs = content.split(/\n\s*\n/).filter(p => p.trim().length > 30);
                console.log('📋 按双换行分割找到段落数:', tempParagraphs.length);
                
                if (tempParagraphs.length >= 2 && tempParagraphs.length <= 50) {
                    paragraphs = tempParagraphs;
                    console.log('📋 使用双换行分割结果');
                } else {
                    // 方法2: 按句号和问号分割（适合长文本）
                    tempParagraphs = content.split(/[.。！!？?]\s+/).filter(p => p.trim().length > 50);
                    console.log('📋 按句号分割找到段落数:', tempParagraphs.length);
                    
                    if (tempParagraphs.length >= 2 && tempParagraphs.length <= 100) {
                        paragraphs = tempParagraphs;
                        console.log('📋 使用句号分割结果');
                    } else {
                        // 方法3: 固定长度分割（最后的选择）
                        console.log('📋 使用固定长度分割');
                        const chunkSize = Math.max(200, Math.min(800, Math.floor(content.length / 10)));
                        paragraphs = [];
                        for (let i = 0; i < content.length; i += chunkSize) {
                            const chunk = content.slice(i, i + chunkSize).trim();
                            if (chunk.length > 50) {
                                paragraphs.push(chunk);
                            }
                        }
                        console.log('📋 固定长度分割后段落数:', paragraphs.length);
                    }
                }
                
                // 最终检查：确保内容不为空
                if (paragraphs.length === 0) {
                    paragraphs = [content.trim()];
                    console.log('📋 无法分段，使用完整内容');
                }
                
                const finalParagraphs = paragraphs;
                
                // 生成章节结构
                const sections = finalParagraphs.map((paragraph, index) => {
                    const trimmed = paragraph.trim();
                    const preview = trimmed.substring(0, 60) + (trimmed.length > 60 ? '...' : '');
                    // 对中文文本使用字符数，对英文使用单词数
                    const wordCount = trimmed.length > 100 && /[\u4e00-\u9fff]/.test(trimmed) 
                        ? trimmed.length 
                        : trimmed.split(/\s+/).length;
                    
                    // 对于AI分析内容，使用更合适的标题
                    let title;
                    if (finalParagraphs.length === 1 && content.length < 500) {
                        title = '🧠 AI分析摘要';
                    } else {
                        title = `第 ${index + 1} 段`;
                    }
                    
                    const sectionData = {
                        id: `section_${index}`,
                        title: title,
                        preview: preview,
                        content: trimmed,
                        wordCount: wordCount
                    };
                    
                    console.log(`📋🔥 生成章节 ${index}:`, {
                        id: sectionData.id,
                        title: sectionData.title,
                        contentLength: sectionData.content.length,
                        preview: sectionData.preview
                    });
                    
                    return sectionData;
                });
                
                console.log('📋🔥 生成的章节数:', sections.length);
                console.log('📋🔥 所有章节ID:', sections.map(s => s.id));
                
                // 生成目录HTML
                let structureHtml = `
                    <div style="margin-bottom: 16px;">
                        <div style="
                            background: #e0f2fe; color: #0c4a6e; padding: 12px; 
                            border-radius: 8px; font-size: 13px; text-align: center;
                        ">
                            📊 ${sections.length} sections • ${/[\u4e00-\u9fff]/.test(content) ? content.length + ' characters' : content.split(/\s+/).length + ' words'}
                        </div>
                    </div>
                `;
                
                sections.forEach((section, index) => {
                    structureHtml += `
                        <div onclick="console.log('📋🔥 模态框目录项被点击:', '${section.id}', '${fileName}'); event.preventDefault(); event.stopPropagation(); window.showSectionInModal('${section.id}', '${fileName}'); return false;" style="
                            padding: 12px; margin-bottom: 8px; border-radius: 8px; 
                            background: white; border: 1px solid #e2e8f0; cursor: pointer;
                            transition: all 0.2s ease; hover:bg-blue-50;
                        " onmouseover="this.style.backgroundColor='#f0f9ff'; this.style.borderColor='#3b82f6'" 
                           onmouseout="this.style.backgroundColor='white'; this.style.borderColor='#e2e8f0'">
                            <div style="
                                display: flex; justify-content: space-between; align-items: flex-start; 
                                margin-bottom: 6px;
                            ">
                                <span style="
                                    font-weight: 600; color: #1f2937; font-size: 13px;
                                ">${section.title}</span>
                                <span style="
                                    font-size: 11px; color: #6b7280; margin-left: auto;
                                ">${section.wordCount} ${/[\u4e00-\u9fff]/.test(section.content) ? 'characters' : 'words'}</span>
                            </div>
                            <div style="
                                color: #4b5563; font-size: 12px; line-height: 1.4;
                            ">${section.preview}</div>
                        </div>
                    `;
                });
                
                // 存储章节数据以供后续使用
                const sectionsKey = `sections_${fileName.replace(/[^a-zA-Z0-9]/g, '_')}`;
                window[sectionsKey] = sections;
                
                console.log('💾 存储章节数据，键名:', sectionsKey);
                console.log('💾 存储的章节数量:', sections.length);
                console.log('💾 验证存储成功:', !!window[sectionsKey]);
                console.log('💾 存储后立即检查数据:', window[sectionsKey] ? window[sectionsKey].length : '未找到');
                
                console.log('📋 最终生成的HTML长度:', structureHtml.length);
                console.log('📋 HTML预览:', structureHtml.substring(0, 300));
                
                return structureHtml;
                
            } catch (error) {
                console.error('❌ 生成文档结构失败:', error);
                return `
                    <div style="text-align: center; padding: 20px; color: #6b7280;">
                        <div style="font-size: 24px; margin-bottom: 8px;">📄</div>
                        <p>文档结构生成中...</p>
                    </div>
                `;
            }
        }
        
        // 🔍 测试函数：直接显示内容到右侧区域
        window.testContentDisplay = function(text) {
            const container = document.getElementById('documentPreviewContent');
            if (container) {
                container.innerHTML = `<div style="padding: 20px;"><h3>测试内容</h3><p>${text}</p></div>`;
                console.log('✅ 测试内容已显示');
            } else {
                console.log('❌ 找不到容器 documentPreviewContent');
            }
        };
        
        // 🔧 强制修复右侧预览区域
        window.forceFixPreview = function() {
            console.log('🔧 开始强制修复右侧预览区域...');
            
            // 查找所有可能的右侧区域
            const allDivs = document.querySelectorAll('div');
            let found = false;
            
            allDivs.forEach((div, index) => {
                const text = div.textContent || '';
                const style = div.style.cssText || '';
                
                // 寻找包含 "Content Preview" 文本或相关样式的元素
                if (text.includes('Content Preview') || text.includes('Select a section')) {
                    console.log('🎯 找到可能的预览区域:', div);
                    div.id = 'documentPreviewContent'; // 强制设置ID
                    div.innerHTML = `
                        <div style="padding: 20px; text-align: center; color: #6b7280;">
                            <h3>✅ 预览区域已修复</h3>
                            <p>现在可以点击左侧目录查看内容了</p>
                        </div>
                    `;
                    found = true;
                    return;
                }
                
                // 寻找右侧的空白区域（可能是预览容器）
                if (style.includes('background: white') && 
                    style.includes('border-radius: 16px') &&
                    div.children.length === 0) {
                    console.log('🎯 找到可能的空白预览容器:', div);
                    div.id = 'documentPreviewContent';
                    div.innerHTML = `
                        <div style="padding: 20px; text-align: center; color: #6b7280;">
                            <h3>🔧 预览容器已激活</h3>
                            <p>点击左侧文档目录查看具体内容</p>
                        </div>
                    `;
                    found = true;
                    return;
                }
            });
            
            if (!found) {
                console.log('❌ 未找到预览容器，创建新的');
                showNotification('❌ 预览区域丢失，请刷新页面');
            } else {
                console.log('✅ 预览区域修复完成');
                showNotification('✅ 预览区域已修复，可以点击目录查看内容了');
            }
        };
        
        // 🧹 清理不必要的弹窗
        window.cleanupPopups = function() {
            console.log('🧹 清理页面中的弹窗...');
            
            // 清理所有可能的临时弹窗
            const popups = document.querySelectorAll('[id*="temp"], [id*="Temp"], [style*="position: fixed"]');
            let cleanedCount = 0;
            
            popups.forEach(popup => {
                if (popup.style.zIndex > '7000' || 
                    popup.id.includes('temp') || 
                    popup.id.includes('Temp') ||
                    (popup.style.position === 'fixed' && popup.style.transform && popup.style.transform.includes('translate'))) {
                    console.log('🗑️ 移除弹窗:', popup.id || popup.className);
                    popup.remove();
                    cleanedCount++;
                }
            });
            
            console.log(`✅ 清理完成，移除了 ${cleanedCount} 个弹窗`);
            
            if (cleanedCount > 0) {
                showNotification(`🧹 已清理 ${cleanedCount} 个弹窗`);
            }
        };
        
        // 📌 添加快捷键清理弹窗 (Ctrl+Shift+C)
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                e.preventDefault();
                window.cleanupPopups();
                console.log('⌨️ 使用快捷键清理弹窗');
            }
        });

        // 📖 在模态框内显示章节内容
        window.showSectionInModal = function showSectionInModal(sectionId, fileName) {
            console.log('📖🔥 在模态框内显示章节内容:', sectionId, fileName);
            
            // 阻止事件冒泡
            event && event.preventDefault();
            event && event.stopPropagation();
            
            try {
                // 首先检查模态框预览容器是否存在
                const modalPreviewContainer = document.getElementById('documentPreviewContent');
                console.log('🔍 检查模态框预览容器:', !!modalPreviewContainer);
                
                if (!modalPreviewContainer) {
                    console.error('❌ 模态框预览容器不存在，等待DOM渲染...');
                    setTimeout(() => showSectionInModal(sectionId, fileName), 100);
                    return;
                }
                
                const sectionsKey = `sections_${fileName.replace(/[^a-zA-Z0-9]/g, '_')}`;
                console.log('🔑 计算的章节键名:', sectionsKey);
                
                const sections = window[sectionsKey];
                console.log('🔍 查找章节数据，键名:', sectionsKey);
                console.log('🔍 章节数据存在:', !!sections);
                console.log('🔍 章节数量:', sections ? sections.length : 0);
                
                // 调试所有可能的键名
                const allWindowKeys = Object.keys(window).filter(key => key.startsWith('sections_'));
                console.log('🔍 所有章节键名:', allWindowKeys);
                
                if (!sections) {
                    console.error('❌ 找不到章节数据，尝试显示错误信息');
                    
                    // 在模态框内显示错误信息
                    const modalPreviewContainer = document.getElementById('documentPreviewContent');
                    if (modalPreviewContainer) {
                        modalPreviewContainer.innerHTML = `
                            <div style="text-align: center; padding: 60px 20px; color: #ef4444;">
                                <div style="font-size: 48px; margin-bottom: 16px;">❌</div>
                                <h3 style="margin: 0 0 8px 0; color: #dc2626;">章节数据未找到</h3>
                                <p style="margin: 0; font-size: 14px;">键名: ${sectionsKey}</p>
                                <p style="margin: 8px 0 0 0; font-size: 14px;">可用键名: ${allWindowKeys.join(', ')}</p>
                            </div>
                        `;
                    }
                    return;
                }
                
                console.log('📋 所有章节:', sections.map(s => ({ id: s.id, title: s.title, contentLength: s.content?.length })));
                
                const section = sections.find(s => s.id === sectionId);
                if (!section) {
                    console.error('❌ 找不到指定章节:', sectionId);
                    console.log('📋 可用章节ID:', sections.map(s => s.id));
                    
                    // 在模态框内显示错误信息
                    const modalPreviewContainer = document.getElementById('documentPreviewContent');
                    if (modalPreviewContainer) {
                        modalPreviewContainer.innerHTML = `
                            <div style="text-align: center; padding: 60px 20px; color: #ef4444;">
                                <div style="font-size: 48px; margin-bottom: 16px;">❌</div>
                                <h3 style="margin: 0 0 8px 0; color: #dc2626;">章节未找到</h3>
                                <p style="margin: 0; font-size: 14px;">查找章节: ${sectionId}</p>
                                <p style="margin: 8px 0 0 0; font-size: 14px;">可用章节: ${sections.map(s => s.id).join(', ')}</p>
                            </div>
                        `;
                    }
                    return;
                }
                
                console.log('✅ 找到章节:', section.title, '内容长度:', section.content?.length);
                
                // 确认模态框预览容器仍然存在
                console.log('🔍 再次确认模态框预览容器:', !!modalPreviewContainer);
                
                if (!modalPreviewContainer) {
                    console.error('❌ 模态框预览容器已不存在');
                    return;
                }
                
                // 显示内容
                displaySectionContent(modalPreviewContainer, section);
            
                
            } catch (error) {
                console.error('❌ 显示模态框章节内容失败:', error);
                console.error('❌ 错误堆栈:', error.stack);
                
                // 在模态框内显示错误信息
                const modalPreviewContainer = document.getElementById('documentPreviewContent');
                if (modalPreviewContainer) {
                    modalPreviewContainer.innerHTML = `
                        <div style="text-align: center; padding: 60px 20px; color: #ef4444;">
                            <div style="font-size: 48px; margin-bottom: 16px;">💥</div>
                            <h3 style="margin: 0 0 8px 0; color: #dc2626;">显示章节时出错</h3>
                            <p style="margin: 0; font-size: 14px;">${error.message}</p>
                        </div>
                    `;
                }
            }
        };

        // 📖 显示章节内容的辅助函数
        function displaySectionContent(container, section) {
            console.log('🎨 开始显示章节内容:', section.title);
            console.log('🎨 容器元素:', container);
            console.log('🎨 章节数据:', section);
            
            if (!container) {
                console.error('❌ 容器元素为空！');
                return;
            }
            
            if (!section) {
                console.error('❌ 章节数据为空！');
                return;
            }
            
            // 在模态框内显示章节内容
            const displayContent = section.content || '章节内容为空';
            console.log('🎨 要显示的内容长度:', displayContent.length);
            console.log('🎨 内容预览:', displayContent.substring(0, 200));
            
            // 🔥 临时测试：强制显示一些内容
            const testContent = displayContent.length > 0 ? displayContent : '测试内容 - 如果你看到这个，说明显示功能正常';
            console.log('🔥 测试内容长度:', testContent.length);
            
            const htmlContent = `
                <div style="margin-bottom: 20px;">
                    <h3 style="margin: 0 0 12px 0; color: #1f2937; font-size: 18px; font-weight: 600;">
                        ${section.title}
                    </h3>
                    <div style="color: #6b7280; font-size: 14px; margin-bottom: 16px;">
                        ${section.wordCount || '未知'} ${/[\u4e00-\u9fff]/.test(testContent) ? 'characters' : 'words'}
                    </div>
                </div>
                <div style="
                    line-height: 1.8; color: #374151; font-size: 15px;
                    white-space: pre-wrap; word-wrap: break-word; background: #f9f9f9; padding: 15px; border-radius: 8px;
                ">
                    ${testContent}
                </div>
                <div style="margin-top: 15px; padding: 10px; background: #e3f2fd; border-radius: 8px; font-size: 12px; color: #1565c0;">
                    🔍 调试信息: 原始内容长度 ${displayContent.length}, 显示内容长度 ${testContent.length}
                </div>
            `;
            
            console.log('🎨 生成的HTML长度:', htmlContent.length);
            console.log('🎨 将要设置的HTML内容预览:', htmlContent.substring(0, 500));
            
            container.innerHTML = htmlContent;
            
            console.log('✅ 模态框内章节内容显示完成');
            console.log('🔍 容器更新后的innerHTML长度:', container.innerHTML.length);
            console.log('🔍 容器更新后的innerHTML预览:', container.innerHTML.substring(0, 500));
            console.log('🔍 容器的可见性:', window.getComputedStyle(container).display);
            console.log('🔍 容器的高度:', container.offsetHeight, 'px');
            console.log('🔍 容器的父元素:', container.parentElement);
        }

        // 📖 显示章节内容 (修复版本)
        window.showSectionContent = function showSectionContent(sectionId, fileName) {
            console.log('📖 显示章节内容:', sectionId, fileName);
            
            // 阻止任何弹窗行为
            event && event.preventDefault();
            event && event.stopPropagation();
            
            // 首先清理不必要的弹窗
            window.cleanupPopups();
            
            try {
                const sectionsKey = `sections_${fileName.replace(/[^a-zA-Z0-9]/g, '_')}`;
                const sections = window[sectionsKey];
                
                console.log('🔍 查找章节数据，键名:', sectionsKey);
                console.log('🔍 章节数据存在:', !!sections);
                console.log('🔍 章节数量:', sections ? sections.length : 0);
                
                if (!sections) {
                    console.error('❌ 找不到章节数据，显示错误提示');
                    showNotification('❌ 章节数据丢失，请重新打开文档');
                    return false; // 阻止弹窗
                }
                
                const section = sections.find(s => s.id === sectionId);
                if (!section) {
                    console.error('❌ 找不到指定章节:', sectionId);
                    showNotification(`❌ 找不到章节: ${sectionId}`);
                    return false; // 阻止弹窗
                }
                
                console.log('✅ 找到章节:', section.title);
                console.log('📖 章节内容长度:', section.content.length);
                
                // 获取知识库面板右侧的预览容器
                let previewContainer = document.getElementById('contentPreview');
                console.log('🔍 查找知识库预览容器:', !!previewContainer);
                
                // 如果找不到预览容器，不要显示弹窗，而是显示通知
                if (!previewContainer) {
                    console.error('❌ 无法找到预览容器，显示通知而不是弹窗');
                    showNotification('❌ 预览区域不可用，请重新打开文档窗口', 'error');
                    return false; // 阻止弹窗
                }
                
                console.log('✅ 找到预览容器，开始更新内容');
                console.log('📖 章节内容:', section.content.substring(0, 100) + '...');
                
                // 显示关闭按钮
                const closePreviewBtn = document.getElementById('closePreview');
                if (closePreviewBtn) {
                    closePreviewBtn.style.display = 'block';
                }
                
                previewContainer.innerHTML = `
                    <div style="padding: 20px;">
                        <div style="margin-bottom: 20px; border-bottom: 2px solid #e2e8f0; padding-bottom: 15px;">
                            <h2 style="margin: 0; color: #1f2937; font-size: 20px;">${section.title}</h2>
                            <p style="margin: 5px 0 0 0; color: #6b7280; font-size: 13px;">
                                ${section.wordCount} words • ${Math.ceil(section.wordCount / 200)} min read
                            </p>
                        </div>
                        
                        <div style="
                            line-height: 1.6; font-size: 15px; color: #374151;
                            white-space: pre-wrap; padding: 15px; background: #f8f9fa;
                            border-radius: 8px; border-left: 3px solid #3b82f6;
                        ">
                            ${section.content}
                        </div>
                        
                        <div style="
                            margin-top: 15px; padding: 12px; background: #f0f9ff; 
                            border-radius: 6px; font-size: 12px; color: #1e40af;
                        ">
                            💡 <strong>提示：</strong>这是文档的第${section.id.split('_')[1]}部分内容
                        </div>
                    </div>
                `;
                
                // 滚动到顶部
                previewContainer.scrollTop = 0;
                
                console.log('✅ 章节内容显示成功');
                
            } catch (error) {
                console.error('❌ 显示章节内容失败:', error);
                console.error('错误详情:', error.stack);
                
                // 显示错误通知而不是弹窗
                showNotification('❌ 章节内容加载失败，请重试', 'error');
                
                // 尝试在预览容器中显示错误信息
                const previewContainer = document.getElementById('documentPreviewContent');
                if (previewContainer) {
                    previewContainer.innerHTML = `
                        <div style="text-align: center; padding: 60px 20px; color: #dc2626;">
                            <div style="font-size: 48px; margin-bottom: 16px;">❌</div>
                            <h3 style="margin: 0 0 12px 0; color: #dc2626;">内容加载错误</h3>
                            <p style="margin: 0; font-size: 15px; color: #6b7280;">
                                章节内容加载失败，请重试或重新打开文档。
                            </p>
                            <button onclick="location.reload()" style="
                                margin-top: 20px; padding: 10px 20px; border: none; 
                                background: #3b82f6; color: white; border-radius: 6px; cursor: pointer;
                            ">刷新页面</button>
                        </div>
                    `;
                }
            }
        }
        
        // ✏️ 打开文档编辑器
        // 📝 编辑器工具函数
        window.formatText = function(type) {
            const textarea = document.querySelector('#documentEditor');
            if (!textarea) return;
            
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const selectedText = textarea.value.substring(start, end);
            
            let formattedText = '';
            switch(type) {
                case 'bold':
                    formattedText = `**${selectedText}**`;
                    break;
                case 'italic':
                    formattedText = `*${selectedText}*`;
                    break;
            }
            
            textarea.value = textarea.value.substring(0, start) + formattedText + textarea.value.substring(end);
            textarea.focus();
            textarea.setSelectionRange(start + formattedText.length, start + formattedText.length);
        };
        
        window.insertText = function(text) {
            const textarea = document.querySelector('#documentEditor');
            if (!textarea) return;
            
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            
            textarea.value = textarea.value.substring(0, start) + text + textarea.value.substring(end);
            textarea.focus();
            textarea.setSelectionRange(start + text.length, start + text.length);
        };
        
        window.closeDocumentEditor = function() {
            console.log('关闭文档编辑器');
            const modal = document.querySelector('[style*="position: fixed"][style*="z-index: 10000"]');
            if (modal) {
                modal.remove();
                console.log('编辑器已关闭');
            } else {
                console.log('未找到编辑器模态框');
            }
        };
        
        window.openDocumentEditor = function openDocumentEditor(fileName, sectionId = null) {
            console.log('✏️ 打开文档编辑器:', fileName, sectionId);
            
            // 获取文件内容
            const analysisDB = JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}');
            const matchingKey = Object.keys(analysisDB).find(key => key.includes(fileName));
            const fileAnalysis = matchingKey ? analysisDB[matchingKey] : null;
            
            if (!fileAnalysis || !fileAnalysis.extractedContent) {
                alert('Unable to find file content, please re-upload the file');
                return;
            }
            
            let editContent = fileAnalysis.extractedContent;
            let editTitle = `Edit Document: ${fileName}`;
            
            // 如果指定了章节，只编辑该章节
            if (sectionId) {
                const sectionsKey = `sections_${fileName.replace(/[^a-zA-Z0-9]/g, '_')}`;
                const sections = window[sectionsKey];
                const section = sections?.find(s => s.id === sectionId);
                
                if (section) {
                    editContent = section.content;
                    editTitle = `Edit ${section.title} - ${fileName}`;
                }
            }
            
            // 创建编辑器模态框
            showDocumentEditorModal(fileName, editContent, editTitle, sectionId);
        }
        
        // 📝 显示文档编辑器模态框
        function showDocumentEditorModal(fileName, content, title, sectionId = null) {
            console.log('📝 显示文档编辑器模态框');
            
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.8); z-index: 10000; display: flex; 
                align-items: center; justify-content: center;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white; border-radius: 16px; 
                    width: 90vw; max-width: 1000px; height: 85vh; 
                    box-shadow: 0 25px 80px rgba(0,0,0,0.4); 
                    display: flex; flex-direction: column; overflow: hidden;
                ">
                    <!-- 编辑器头部 -->
                    <div style="
                        background: linear-gradient(135deg, #3b82f6, #1d4ed8); 
                        color: white; padding: 20px 30px; display: flex; 
                        align-items: center; justify-content: space-between;
                    ">
                        <div>
                            <h2 style="margin: 0; font-size: 20px; font-weight: 600;">${title}</h2>
                            <p style="margin: 6px 0 0 0; opacity: 0.9; font-size: 14px;">
                                Real-time editing • Auto-save • ${new Date().toLocaleString()}
                            </p>
                        </div>
                        <button onclick="closeDocumentEditor()" style="
                            background: rgba(255,255,255,0.2); border: none; 
                            width: 40px; height: 40px; border-radius: 50%; 
                            cursor: pointer; color: white; font-size: 18px;
                            display: flex; align-items: center; justify-content: center;
                            transition: all 0.2s ease;
                        " onmouseover="this.style.background='rgba(255,255,255,0.3)'" 
                           onmouseout="this.style.background='rgba(255,255,255,0.2)'">✕</button>
                    </div>
                    
                    <!-- 编辑器工具栏 -->
                    <div style="
                        background: #f8fafc; padding: 12px 30px; border-bottom: 1px solid #e2e8f0;
                        display: flex; align-items: center; gap: 12px;
                    ">
                        <button onclick="formatText('bold'); this.style.background='#3b82f6'; this.style.color='white'; setTimeout(() => {this.style.background='#e2e8f0'; this.style.color='#374151';}, 150)" style="
                            background: #e2e8f0; border: none; padding: 8px 12px; 
                            border-radius: 6px; cursor: pointer; font-weight: bold;
                            transition: all 0.15s ease; color: #374151;
                        " onmouseover="this.style.background='#d1d5db'" 
                           onmouseout="this.style.background='#e2e8f0'">B</button>
                        <button onclick="formatText('italic'); this.style.background='#3b82f6'; this.style.color='white'; setTimeout(() => {this.style.background='#e2e8f0'; this.style.color='#374151';}, 150)" style="
                            background: #e2e8f0; border: none; padding: 8px 12px; 
                            border-radius: 6px; cursor: pointer; font-style: italic;
                            transition: all 0.15s ease; color: #374151;
                        " onmouseover="this.style.background='#d1d5db'" 
                           onmouseout="this.style.background='#e2e8f0'">I</button>
                        <div style="width: 1px; height: 24px; background: #d1d5db;"></div>
                        <button onclick="insertText('## '); this.style.background='#3b82f6'; this.style.color='white'; setTimeout(() => {this.style.background='#e2e8f0'; this.style.color='#374151';}, 150)" style="
                            background: #e2e8f0; border: none; padding: 8px 12px; 
                            border-radius: 6px; cursor: pointer; font-size: 12px;
                            transition: all 0.15s ease; color: #374151;
                        " onmouseover="this.style.background='#d1d5db'" 
                           onmouseout="this.style.background='#e2e8f0'">Header</button>
                        <button onclick="insertText('- '); this.style.background='#3b82f6'; this.style.color='white'; setTimeout(() => {this.style.background='#e2e8f0'; this.style.color='#374151';}, 150)" style="
                            background: #e2e8f0; border: none; padding: 8px 12px; 
                            border-radius: 6px; cursor: pointer; font-size: 12px;
                            transition: all 0.15s ease; color: #374151;
                        " onmouseover="this.style.background='#d1d5db'" 
                           onmouseout="this.style.background='#e2e8f0'">List</button>
                        <div style="margin-left: auto; display: flex; align-items: center; gap: 12px;">
                            <span id="documentWordCount" style="color: #6b7280; font-size: 13px;">
                                ${content.split(/\s+/).length} words
                            </span>
                        </div>
                    </div>
                    
                    <!-- 编辑器主体 -->
                    <div style="flex: 1; display: flex; overflow: hidden;">
                        <!-- 编辑区域 -->
                        <div style="flex: 1; padding: 0; display: flex; flex-direction: column;">
                            <textarea id="documentEditor" style="
                                flex: 1; border: none; outline: none; padding: 30px; 
                                font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
                                font-size: 15px; line-height: 1.8; color: #374151;
                                background: white; resize: none;
                            " placeholder="Start editing your document...">${content}</textarea>
                        </div>
                        
                        <!-- 预览区域 -->
                        <div id="documentPreview" style="
                            flex: 1; padding: 30px; background: #fafafa; 
                            border-left: 1px solid #e2e8f0; overflow-y: auto;
                            font-size: 15px; line-height: 1.8; color: #374151;
                        ">
                            <div style="color: #6b7280; text-align: center; padding: 40px;">
                                <div style="font-size: 32px; margin-bottom: 12px;">👁️</div>
                                <p>Real-time preview will appear here</p>
                                <p style="font-size: 13px;">Start editing content on the left to see preview</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 编辑器底部 -->
                    <div style="
                        background: #f8fafc; padding: 20px 30px; border-top: 1px solid #e2e8f0;
                        display: flex; align-items: center; justify-content: space-between;
                    ">
                        <div style="display: flex; align-items: center; gap: 16px;">
                            <div style="
                                display: flex; align-items: center; gap: 6px; 
                                color: #10b981; font-size: 13px;
                            ">
                                <span>💾</span>
                                <span>Auto-save enabled</span>
                            </div>
                            <div style="
                                display: flex; align-items: center; gap: 6px; 
                                color: #6b7280; font-size: 13px;
                            ">
                                <span>📝</span>
                                <span>Last saved: just now</span>
                            </div>
                        </div>
                        
                        <div style="display: flex; gap: 12px;">
                            <button onclick="closeDocumentEditor()" style="
                                background: #e5e7eb; border: none; padding: 10px 20px; 
                                border-radius: 8px; cursor: pointer; color: #374151;
                                transition: all 0.2s ease;
                            " onmouseover="this.style.background='#d1d5db'" 
                               onmouseout="this.style.background='#e5e7eb'">Cancel</button>
                            <button onclick="saveDocumentChanges('${fileName}', '${sectionId}')" style="
                                background: #3b82f6; color: white; border: none; 
                                padding: 10px 20px; border-radius: 8px; cursor: pointer;
                                font-weight: 600; display: flex; align-items: center; gap: 6px;
                                transition: all 0.2s ease;
                            " onmouseover="this.style.background='#2563eb'; this.style.transform='translateY(-1px)'" 
                               onmouseout="this.style.background='#3b82f6'; this.style.transform='translateY(0)'">
                                💾 Save Changes
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // 初始化编辑器功能
            initializeDocumentEditor();
            
            // 点击背景关闭
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        
        // 🔧 初始化文档编辑器功能
        function initializeDocumentEditor() {
            const editor = document.getElementById('documentEditor');
            const preview = document.getElementById('documentPreview');
            const wordCount = document.getElementById('documentWordCount');
            
            if (!editor || !preview) return;
            
            // 实时预览更新
            function updatePreview() {
                const content = editor.value;
                const words = content.trim() ? content.trim().split(/\s+/).length : 0;
                
                // 更新字数统计
                if (wordCount) {
                    wordCount.textContent = `${words} words`;
                }
                
                // 简单的Markdown渲染
                let html = content
                    .replace(/^### (.*$)/gim, '<h3 style="color: #1f2937; margin: 24px 0 12px 0;">$1</h3>')
                    .replace(/^## (.*$)/gim, '<h2 style="color: #1f2937; margin: 28px 0 16px 0;">$1</h2>')
                    .replace(/^# (.*$)/gim, '<h1 style="color: #1f2937; margin: 32px 0 20px 0;">$1</h1>')
                    .replace(/\*\*(.*?)\*\*/g, '<strong style="color: #1f2937;">$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em style="color: #4b5563;">$1</em>')
                    .replace(/^- (.*$)/gim, '<li style="margin-bottom: 4px;">$1</li>')
                    .replace(/\n\n/g, '</p><p style="margin-bottom: 16px;">')
                    .replace(/\n/g, '<br>');
                
                // 包装段落
                if (html && !html.includes('<h1>') && !html.includes('<h2>')) {
                    html = '<p style="margin-bottom: 16px;">' + html + '</p>';
                }
                
                preview.innerHTML = html || '<div style="color: #6b7280; text-align: center; padding: 40px;"><p>开始编辑查看预览</p></div>';
            }
            
            // 监听输入
            editor.addEventListener('input', updatePreview);
            
            // 初始预览
            updatePreview();
            
            // 自动保存
            let saveTimer;
            editor.addEventListener('input', () => {
                clearTimeout(saveTimer);
                saveTimer = setTimeout(() => {
                    console.log('🔄 自动保存文档更改');
                    // 这里可以实现自动保存逻辑
                }, 2000);
            });
        }
        
        // 💾 保存文档更改
        function saveDocumentChanges(fileName, sectionId = null) {
            console.log('💾 保存文档更改:', fileName, sectionId);
            
            const editor = document.getElementById('documentEditor');
            if (!editor) {
                alert('编辑器未找到');
                return;
            }
            
            const newContent = editor.value;
            
            try {
                // 获取现有的分析数据
                const analysisDB = JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}');
                const matchingKey = Object.keys(analysisDB).find(key => key.includes(fileName));
                
                if (!matchingKey) {
                    alert('未找到文件分析数据');
                    return;
                }
                
                // 更新内容
                if (sectionId) {
                    // 更新特定章节
                    const sectionsKey = `sections_${fileName.replace(/[^a-zA-Z0-9]/g, '_')}`;
                    const sections = window[sectionsKey];
                    if (sections) {
                        const sectionIndex = sections.findIndex(s => s.id === sectionId);
                        if (sectionIndex >= 0) {
                            sections[sectionIndex].content = newContent;
                            sections[sectionIndex].wordCount = newContent.split(/\s+/).length;
                            
                            // 重新组合完整内容
                            const fullContent = sections.map(s => s.content).join('\n\n');
                            analysisDB[matchingKey].extractedContent = fullContent;
                        }
                    }
                } else {
                    // 更新整个文档
                    analysisDB[matchingKey].extractedContent = newContent;
                }
                
                // 保存到localStorage
                localStorage.setItem('graphRAGAnalysisDB', JSON.stringify(analysisDB));
                
                // 关闭编辑器
                document.querySelector('[style*="position: fixed"]').remove();
                
                // 显示成功消息
                showNotification('✅ 文档更改已保存', 'success');
                
                console.log('✅ 文档更改保存成功');
                
            } catch (error) {
                console.error('❌ 保存文档更改失败:', error);
                alert('保存失败: ' + error.message);
            }
        }
        
        // 🧹 清理旧的文件数据以释放localStorage空间
        async function cleanupOldFileData() {
            console.log('🧹 开始清理localStorage中的旧文件数据...');
            
            const keys = Object.keys(localStorage);
            const fileKeys = keys.filter(key => key.startsWith('file_'));
            
            // 按时间戳排序，删除最旧的文件
            const sortedKeys = fileKeys.sort((a, b) => {
                const timeA = parseInt(a.split('_').pop());
                const timeB = parseInt(b.split('_').pop());
                return timeA - timeB; // 升序，最旧的在前
            });
            
            // 删除一半的旧文件
            const toDelete = Math.min(5, Math.floor(sortedKeys.length / 2));
            for (let i = 0; i < toDelete; i++) {
                const key = sortedKeys[i];
                localStorage.removeItem(key);
                console.log('🗑️ 删除旧文件数据:', key);
            }
            
            console.log(`✅ 清理完成，删除了 ${toDelete} 个旧文件数据`);
        }
        
        // 📄 提取PDF文本内容（智能版本）
        async function extractTextFromPDF(file) {
            console.log('🔍 开始PDF内容提取...');
            
            try {
                // 调用GraphRAG API提取PDF内容
                const formData = new FormData();
                formData.append('file', file);
                
                const response = await fetch('http://127.0.0.1:8000/api/graphrag/analyze', {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.status === 'success' && result.analysis && result.analysis.content) {
                        console.log('✅ PDF内容提取成功，长度:', result.analysis.content.length);
                        return result.analysis.content;
                    }
                }
                
                // 如果API调用失败，返回备用摘要
                throw new Error('PDF内容提取失败');
                
            } catch (error) {
                console.log('⚠️ PDF内容提取失败，使用摘要模式:', error);
                
                // 备用摘要
                const documentSummary = `📄 ${file.name}

📊 文档信息:
• 文件类型: PDF文档
• 文件大小: ${(file.size / 1024 / 1024).toFixed(2)} MB
• 预估页数: ${Math.ceil(file.size / 50000)} 页
• 上传时间: ${new Date().toLocaleString()}

⚠️ 内容提取状态:
PDF内容提取服务暂时不可用。

💡 建议:
• 检查GraphRAG服务是否正常运行
• 稍后重试文档处理
• 使用"用本地工具打开"查看完整内容`;

                return documentSummary;
            }
        }
        
        // 📝 从HTML中提取纯文本内容
        function extractTextFromHTML(htmlContent) {
            try {
                console.log('🔧 开始从HTML提取纯文本，原始长度:', htmlContent.length);
                
                // 移除脚本和样式标签及其内容
                let cleanText = htmlContent
                    .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
                    .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
                    .replace(/<head[^>]*>[\s\S]*?<\/head>/gi, '');
                
                // 移除所有HTML标签
                cleanText = cleanText.replace(/<[^>]*>/g, ' ');
                
                // 解码HTML实体
                cleanText = cleanText
                    .replace(/&nbsp;/g, ' ')
                    .replace(/&amp;/g, '&')
                    .replace(/&lt;/g, '<')
                    .replace(/&gt;/g, '>')
                    .replace(/&quot;/g, '"')
                    .replace(/&#39;/g, "'")
                    .replace(/&hellip;/g, '...');
                
                // 清理多余的空白字符
                cleanText = cleanText
                    .replace(/\s+/g, ' ')  // 多个空格变成单个空格
                    .replace(/\n\s*\n/g, '\n\n')  // 保留段落分隔
                    .trim();
                
                console.log('✅ HTML文本提取完成，清理后长度:', cleanText.length);
                console.log('📝 提取的文本预览:', cleanText.substring(0, 300));
                
                return cleanText;
            } catch (error) {
                console.error('❌ HTML文本提取失败:', error);
                return htmlContent; // 失败时返回原始内容
            }
        }

        // 📄 改进的文本文件处理
        async function extractTextFromFile(file) {
            console.log('📝 提取文本文件内容:', file.name);
            
            try {
                if (file.type === 'application/pdf') {
                    return await extractTextFromPDF(file);
                }
                
                // 处理文本类型文件
                if (file.type.includes('text') || 
                    file.name.endsWith('.md') || 
                    file.name.endsWith('.txt') || 
                    file.name.endsWith('.json') || 
                    file.name.endsWith('.csv') ||
                    file.name.endsWith('.yaml') ||
                    file.name.endsWith('.yml') ||
                    file.name.endsWith('.html') ||
                    file.name.endsWith('.htm')) {
                    
                    let text = await file.text();
                    
                    // 🔥 检查是否是HTML内容并进行处理
                    if (text.includes('<!DOCTYPE html') || text.includes('<html') || file.name.endsWith('.html') || file.name.endsWith('.htm')) {
                        console.log('🔧 检测到HTML内容，进行文本提取...');
                        text = extractTextFromHTML(text);
                    }
                    
                    console.log('✅ 文本内容提取成功，长度:', text.length);
                    return text;
                }
                
                // 对于其他文件类型，提供智能文件信息
                const fileInfo = `📁 ${file.name}

📊 文件信息:
• 文件类型: ${file.type || '未知格式'}
• 文件大小: ${(file.size / 1024 / 1024).toFixed(2)} MB
• 上传时间: ${new Date().toLocaleString()}

🧠 处理状态:
该文件已上传并准备进行AI分析。
根据文件类型，GraphRAG系统将:
• 识别文件格式和结构
• 提取可用的内容信息
• 分析文件在知识体系中的位置

💡 查看建议:
• 等待AI分析完成后查看智能摘要
• 点击"用本地工具打开"使用相应程序查看
• 通过知识图谱查看文件关联关系

该文件信息已保存到知识库中。`;
                
                return fileInfo;
                
            } catch (error) {
                console.error('❌ 文件内容提取失败:', error);
                return `文件: ${file.name}\n提取内容失败，请使用本地工具打开。`;
            }
        }
        
        // 🧠 存储GraphRAG分析数据（用于知识图谱）
        async function storeGraphRAGAnalysis(fileName, analysisResult) {
            console.log('🧠 存储GraphRAG分析数据:', fileName);
            
            try {
                // 获取现有的分析数据库
                let analysisDB = JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}');
                
                // 创建分析条目
                const analysisEntry = {
                    fileName: fileName,
                    timestamp: new Date().toISOString(),
                    concepts: analysisResult.concepts || [],
                    entities: analysisResult.entities || [],
                    relationships: analysisResult.relationships || [],
                    communities: analysisResult.communities || [],
                    extractedContent: analysisResult.extractedContent || '',
                    confidence: analysisResult.confidence || 0,
                    knowledgeTreePath: analysisResult.positionSuggestion?.primarySuggestion?.path || '',
                    graphData: analysisResult.graphData || null,
                    // 🔥 保存完整的原始GraphRAG响应
                    rawAnalysis: analysisResult
                };
                
                // 使用文件名和时间戳作为唯一键
                const entryKey = `${fileName}_${Date.now()}`;
                analysisDB[entryKey] = analysisEntry;
                
                // 保存到localStorage
                localStorage.setItem('graphRAGAnalysisDB', JSON.stringify(analysisDB));
                
                console.log('✅ GraphRAG分析数据已存储:', entryKey);
                console.log('📊 数据库中共有', Object.keys(analysisDB).length, '条分析记录');
                
            } catch (error) {
                console.error('❌ 存储GraphRAG数据失败:', error);
                throw error;
            }
        }
        
        // 🔥 知识库面板控制函数已在前面定义，这里删除重复定义

        function closeKnowledgePanel() {
            console.log('📚 Closing knowledge panel...');
            const knowledgePanel = document.getElementById('knowledgePanel');
            const panelOverlay = document.getElementById('panelOverlay');
            
            if (knowledgePanel) {
                knowledgePanel.classList.remove('open');
            }
            
            if (panelOverlay) {
                panelOverlay.classList.remove('show');
            }
        }
        
        // 🔥 智能版：结合AI分析结果和直接内容存储
        async function acceptSuggestion(fileName, suggestedPath) {
            console.log(`✅ 接受AI建议: ${fileName} -> ${suggestedPath}`);
            
            try {
                // 🔍 检查文件是否已经被自动保存了
                const knowledgeTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
                const pathParts = suggestedPath.split(/[/>]/).filter(p => p.trim());
                const mainCategory = pathParts[0] || '智能分类';
                
                // 检查是否已经存在于知识树中
                if (knowledgeTree[mainCategory] && knowledgeTree[mainCategory].files) {
                    const existingFile = knowledgeTree[mainCategory].files.find(f => f.name === fileName);
                    if (existingFile) {
                        console.log(`✅ 文件 "${fileName}" 已经存在于知识树中，直接跳转`);
                        showNotification(`✅ 文件 "${fileName}" 已在知识树中`);
                        
                        // 跳转到知识库
                        setTimeout(() => {
                            openKnowledgePanel();
                            navigateToKnowledgeTree(mainCategory, fileName);
                        }, 500);
                        
                        // 清理上传区域
                        clearUploadArea();
                        return;
                    }
                }
                
                // 如果文件不存在，则执行正常的保存流程
                console.log(`📄 文件 "${fileName}" 不存在于知识树中，执行保存`);
                
                // 🧠 获取AI分析结果（用于位置决策和内容理解）
                const analysisResult = window.currentAnalysisResults?.[fileName];
                if (!analysisResult) {
                    showNotification(`❌ 找不到AI分析结果: ${fileName}`);
                    return;
                }
                
                // 📄 获取原始文件（用于完整内容存储）
                const fileInput = document.querySelector('input[type="file"]');
                const uploadedFiles = window.currentUploadedFiles || [];
                const originalFile = Array.from(fileInput?.files || []).find(f => f.name === fileName) || 
                                   uploadedFiles.find(f => f.name === fileName);
                
                if (!originalFile) {
                    showNotification(`❌ 找不到原始文件: ${fileName}`);
                    return;
                }
                
                // 🔥 保存原始文件到本地（用于后续用本地工具打开）
                const fileStorageKey = await saveFileLocally(originalFile);
                
                // 🔥 使用统一的新版保存函数，避免重复分类
                await addFileWithAIGuidanceAndStorage(fileName, suggestedPath, analysisResult, originalFile, fileStorageKey);
                
                // 显示成功消息
                showNotification(`✅ AI已将 "${fileName}" 智能分类到 "${suggestedPath}"`);
                
                // 跳转到知识库
                setTimeout(() => {
                    openKnowledgePanel();
                    navigateToKnowledgeTree(mainCategory, fileName);
                }, 500);
                
                // 清理上传区域
                clearUploadArea();
                
            } catch (error) {
                console.error('❌ 智能分类失败:', error);
                showNotification(`❌ 智能分类失败: ${error.message}`, 'error');
            }
        }
        
        // 🔥 超简单：直接读取文件内容
        async function readFileDirectly(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    let content = e.target.result;
                    
                    // 如果是PDF，简单提取文本
                    if (file.type === 'application/pdf') {
                        // 这里可以用简单的文本提取，或者直接显示"PDF文件已上传"
                        console.log('📄 PDF文件，显示基本信息');
                        content = `PDF文件：${file.name}\n大小：${(file.size/1024).toFixed(1)} KB\n上传时间：${new Date().toLocaleString()}\n\n这是一个PDF文件，内容已成功保存到知识树中。`;
                    }
                    
                    resolve(content);
                };
                
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }
        
        // 🎯 简化版：一个文件只创建一个主要分类
        async function addFileWithAIGuidanceAndStorage(fileName, suggestedPath, analysisResult, originalFile, storageKey) {
            // 🔒 全局锁：防止同一文件被并发处理
            const lockKey = `saving_${fileName}`;
            if (window[lockKey]) {
                console.log(`⚠️ 文件 "${fileName}" 正在保存中，跳过重复操作`);
                return;
            }
            
            // 🔒 设置锁
            window[lockKey] = true;
            
            try {
                console.log('🎯 使用AI分析智能添加文件:', fileName);
                console.log('🧠 AI建议的完整路径:', suggestedPath);
                
                // 🔍 严格检查：检查localStorage中是否已存在
                const knowledgeTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
                const pathParts = suggestedPath.split(/[/>]/).filter(p => p.trim());
                const mainCategory = pathParts[0]?.trim() || '智能分类';
                
                // 检查该文件是否已经存在于任何分类中
                for (const [categoryName, categoryData] of Object.entries(knowledgeTree)) {
                    if (categoryData.files) {
                        const existingFile = categoryData.files.find(f => f.name === fileName);
                        if (existingFile) {
                            console.log(`✅ 文件 "${fileName}" 已存在于分类 "${categoryName}" 中，跳过保存`);
                            return;
                        }
                    }
                }
                
                console.log('📂 确认文件不存在，继续保存流程');
                
                console.log('📂 使用主要分类:', mainCategory);
                
                // 🏗️ 查找或创建主要分类
                let categoryNode = findNodeByTitle(mainCategory);
                
                if (!categoryNode) {
                    console.log(`🆕 创建新的主要分类: ${mainCategory}`);
                    categoryNode = createIntelligentCategoryNode(mainCategory, {
                        aiSuggested: true,
                        concepts: analysisResult.concepts,
                        confidence: analysisResult.confidence
                    }, true); // 🔥 新上传时才自动添加到DOM
                } else {
                    console.log(`✅ 找到现有分类: ${mainCategory}`);
                }
                
                // 🔥 直接在主分类下添加文件
                if (categoryNode) {
                    const fileNode = createIntelligentFileNodeWithStorage(fileName, analysisResult, originalFile, storageKey);
                    const childrenContainer = categoryNode.querySelector('.node-children');
                    if (childrenContainer) {
                        // 检查是否已存在同名文件
                        const existingFile = Array.from(childrenContainer.children).find(child => {
                            const title = child.querySelector('.node-title');
                            return title && title.textContent.trim() === fileName;
                        });
                        
                        if (!existingFile) {
                            childrenContainer.appendChild(fileNode);
                            expandNodePath(categoryNode);
                            console.log(`✅ 文件 "${fileName}" 已添加到 "${mainCategory}" 分类`);
                            
                            // 🔥 只有在DOM中成功添加新文件后才保存到localStorage
                            await saveFileToPeristentKnowledgeTree(mainCategory, fileName, analysisResult, originalFile, storageKey);
                        } else {
                            console.log(`⚠️ 文件 "${fileName}" 已存在于 "${mainCategory}" 分类中，跳过保存`);
                        }
                    }
                }
                
            } catch (error) {
                console.error(`❌ 保存文件 "${fileName}" 失败:`, error);
                throw error;
            } finally {
                // 🔓 释放锁
                window[lockKey] = false;
                console.log(`🔓 已释放文件 "${fileName}" 的保存锁`);
            }
        }
        
        // 💾 将文件持久化保存到localStorage知识树
        async function saveFileToPeristentKnowledgeTree(categoryName, fileName, analysisResult, originalFile, storageKey) {
            console.log('💾 持久化保存文件到知识树:', fileName, '->', categoryName);
            
            try {
                // 获取现有的知识树结构
                let knowledgeTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
                
                // 确保分类存在
                if (!knowledgeTree[categoryName]) {
                    knowledgeTree[categoryName] = {
                        type: 'category',
                        aiSuggested: true,
                        confidence: analysisResult.confidence || 0.8,
                        concepts: analysisResult.concepts || [],
                        files: [],
                        createdAt: new Date().toISOString()
                    };
                }
                
                // 检查文件是否已存在
                const existingFileIndex = knowledgeTree[categoryName].files.findIndex(f => f.name === fileName);
                
                // 创建文件条目
                const fileEntry = {
                    name: fileName,
                    type: originalFile.type,
                    size: originalFile.size,
                    storageKey: storageKey,
                    aiAnalysis: {
                        concepts: analysisResult.concepts || [],
                        entities: analysisResult.entities || [],
                        confidence: analysisResult.confidence || 0,
                        summary: analysisResult.extractedContent || '', // 保留完整内容
                        knowledgeTreePath: analysisResult.positionSuggestion?.primarySuggestion?.path || ''
                    },
                    addedAt: new Date().toISOString(),
                    lastModified: new Date().toISOString()
                };
                
                if (existingFileIndex >= 0) {
                    // 更新现有文件
                    knowledgeTree[categoryName].files[existingFileIndex] = fileEntry;
                    console.log('🔄 更新现有文件:', fileName);
                } else {
                    // 添加新文件
                    knowledgeTree[categoryName].files.push(fileEntry);
                    console.log('📄 添加新文件:', fileName);
                }
                
                // 保存到localStorage
                localStorage.setItem('intelligentWorkflowKnowledgeTree', JSON.stringify(knowledgeTree));
                
                console.log('✅ 文件已持久化保存到知识树');
                console.log('📊 知识树分类数:', Object.keys(knowledgeTree).length);
                console.log('📁 当前分类文件数:', knowledgeTree[categoryName].files.length);
                
            } catch (error) {
                console.error('❌ 持久化保存文件失败:', error);
                throw error;
            }
        }
        
        // 🤖 创建带存储键的智能文件节点
        function createIntelligentFileNodeWithStorage(fileName, analysisResult, originalFile, storageKey) {
            const fileNode = document.createElement('div');
            fileNode.className = 'tree-node';
            
            const confidenceIcon = analysisResult.confidence > 0.8 ? '🎯' : '📄';
            
            fileNode.innerHTML = `
                <div class="node-content" onclick="openFileWithLocalTool(event, this)" draggable="true" 
                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                    <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                    <div class="node-icon file">${confidenceIcon}</div>
                    <div class="node-title" ondblclick="editNodeTitle(event, this)">${fileName}</div>
                    <div class="node-actions">
                        <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                        <button class="node-action" onclick="editNode(event, this)">✏️</button>
                        <button class="node-action" onclick="deleteNode(event, this)">🗑️</button>
                        <button class="node-action" onclick="showGraphRAGAnalysis(event, this)" title="查看AI分析">🧠</button>
                    </div>
                </div>
                <div class="node-children"></div>
            `;
            
            // 🔥 存储完整的文件信息和AI分析
            fileNode.setAttribute('data-file-name', fileName);
            fileNode.setAttribute('data-file-size', originalFile.size);
            fileNode.setAttribute('data-file-type', originalFile.type);
            fileNode.setAttribute('data-file-storage-key', storageKey);
            fileNode.setAttribute('data-ai-concepts', JSON.stringify(analysisResult.concepts || []));
            fileNode.setAttribute('data-ai-confidence', analysisResult.confidence || 0);
            fileNode.setAttribute('data-ai-summary', analysisResult.extractedContent || ''); // 保留完整内容
            
            return fileNode;
        }
        
        // 🎯 结合AI分析的智能文件添加
        async function addFileWithAIGuidance(fileName, suggestedPath, fileContent, analysisResult, originalFile) {
            console.log('🎯 使用AI分析结果智能添加文件:', fileName);
            console.log('🧠 AI建议路径:', suggestedPath);
            console.log('📋 AI提取的概念:', analysisResult.concepts);
            
            // 解析AI建议的路径
            const pathParts = suggestedPath.split('/').filter(p => p.trim());
            
            // 🏗️ 根据AI分析逐级创建/查找路径
            let currentNode = null;
            let currentPath = '';
            
            for (let i = 0; i < pathParts.length; i++) {
                const part = pathParts[i];
                currentPath += (currentPath ? ' > ' : '') + part;
                
                // 查找这一级是否已存在
                let nodeAtLevel = findNodeByTitle(part);
                
                if (!nodeAtLevel) {
                    // 不存在则创建
                    console.log(`🆕 AI指导创建类别: ${part} (路径: ${currentPath})`);
                    nodeAtLevel = createIntelligentCategoryNode(part, {
                        aiSuggested: true,
                        concepts: analysisResult.concepts,
                        confidence: analysisResult.confidence
                    });
                    
                    if (currentNode) {
                        // 添加到父级节点
                        const childrenContainer = currentNode.querySelector('.node-children');
                        if (childrenContainer) {
                            childrenContainer.appendChild(nodeAtLevel);
                        }
                    }
                } else {
                    console.log(`✅ 找到现有类别: ${part}`);
                }
                
                currentNode = nodeAtLevel;
            }
            
            // 🔥 在最终位置添加文件，带AI分析信息
            if (currentNode) {
                console.log('📄 在AI建议位置创建文件节点:', fileName);
                const fileNode = createIntelligentFileNode(fileName, fileContent, analysisResult, originalFile);
                
                const childrenContainer = currentNode.querySelector('.node-children');
                if (childrenContainer) {
                    childrenContainer.appendChild(fileNode);
                    
                    // 确保路径是展开的
                    expandNodePath(currentNode);
                }
            }
            
            console.log('✅ AI指导的文件放置完成');
        }
        
        // 🧠 创建带AI信息的智能类别节点（不自动添加到DOM）
        function createIntelligentCategoryNode(categoryName, aiData, autoAppend = false) {
            const categoryNode = document.createElement('div');
            categoryNode.className = 'tree-node';
            
            const confidenceIcon = aiData.confidence > 0.8 ? '🎯' : '📁';
            
            categoryNode.innerHTML = `
                <div class="node-content" onclick="selectNode(this, event)" draggable="true" 
                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                    <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                    <div class="node-icon folder">${confidenceIcon}</div>
                    <div class="node-title" ondblclick="editNodeTitle(event, this)">${categoryName}</div>
                    <div class="node-actions">
                        <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                        <button class="node-action" onclick="editNode(event, this)">✏️</button>
                        <button class="node-action" onclick="deleteNode(event, this)">🗑️</button>
                    </div>
                </div>
                <div class="node-children"></div>
            `;
            
            // 🔥 只在明确指定时才自动添加到知识树根部
            if (autoAppend) {
                const knowledgeTree = document.getElementById('knowledgeTree');
                if (knowledgeTree) {
                    knowledgeTree.appendChild(categoryNode);
                    console.log('✅ 分类节点已添加到知识树:', categoryName);
                }
            }
            
            return categoryNode;
        }
        
        // 🤖 创建带AI分析的智能文件节点
        function createIntelligentFileNode(fileName, content, analysisResult, originalFile) {
            const fileNode = document.createElement('div');
            fileNode.className = 'tree-node';
            
            // 根据AI分析选择图标
            const confidenceIcon = analysisResult.confidence > 0.8 ? '🎯' : '📄';
            
            fileNode.innerHTML = `
                <div class="node-content" onclick="openFileWithLocalTool(event, this)" draggable="true" 
                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                    <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                    <div class="node-icon file">${confidenceIcon}</div>
                    <div class="node-title" ondblclick="editNodeTitle(event, this)">${fileName}</div>
                    <div class="node-actions">
                        <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                        <button class="node-action" onclick="editNode(event, this)">✏️</button>
                        <button class="node-action" onclick="deleteNode(event, this)">🗑️</button>
                        <button class="node-action" onclick="showGraphRAGAnalysis(event, this)" title="查看AI分析">🧠</button>
                    </div>
                </div>
                <div class="node-children"></div>
            `;
            
            // 🔥 存储文件引用和AI分析结果
            fileNode.setAttribute('data-file-name', fileName);
            fileNode.setAttribute('data-file-size', originalFile.size);
            fileNode.setAttribute('data-file-type', originalFile.type);
            fileNode.setAttribute('data-ai-concepts', JSON.stringify(analysisResult.concepts));
            fileNode.setAttribute('data-ai-confidence', analysisResult.confidence);
            fileNode.setAttribute('data-ai-summary', analysisResult.extractedContent || ''); // 保留完整内容
            // 🔥 存储文件存储键，用于检索原始文件
            fileNode.setAttribute('data-file-storage-key', `file_${fileName}_${Date.now()}`);
            
            return fileNode;
        }
        
        // 展开节点路径
        function expandNodePath(node) {
            const expandBtn = node.querySelector('.node-expand');
            const childrenContainer = node.querySelector('.node-children');
            
            if (expandBtn && childrenContainer) {
                expandBtn.textContent = '▼';
                childrenContainer.style.display = 'block';
            }
        }
        
        // 🔥 超简单：直接添加文件到知识树
        async function addFileDirectlyToKnowledgeTree(fileName, suggestedPath, fileContent, originalFile) {
            console.log('📁 直接添加文件到知识树:', fileName);
            
            // 获取路径的第一部分作为类别
            const pathParts = suggestedPath.split('/').filter(p => p.trim());
            const categoryName = pathParts[0] || '未分类';
            
            // 查找或创建类别节点
            let categoryNode = findNodeByTitle(categoryName);
            
            if (!categoryNode) {
                console.log('🆕 创建新类别:', categoryName);
                categoryNode = createNewCategoryNode(categoryName, {});
            }
            
            // 创建文件节点并添加到类别中
            console.log('📄 创建文件节点:', fileName);
            const fileNode = createSimpleFileNode(fileName, fileContent, originalFile);
            
            const childrenContainer = categoryNode.querySelector('.node-children');
            if (childrenContainer) {
                childrenContainer.appendChild(fileNode);
                
                // 确保类别是展开的，可以看到新文件
                const expandBtn = categoryNode.querySelector('.node-expand');
                if (expandBtn) {
                    expandBtn.textContent = '▼';
                    childrenContainer.style.display = 'block';
                }
            }
            
            console.log('✅ 文件已直接添加到知识树');
        }
        
        // 🔥 创建简单的文件节点
        function createSimpleFileNode(fileName, content, originalFile) {
            const fileNode = document.createElement('div');
            fileNode.className = 'tree-node';
            fileNode.innerHTML = `
                <div class="node-content" onclick="openFileWithLocalTool(event, this)" draggable="true" 
                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                    <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                    <div class="node-icon file">📄</div>
                    <div class="node-title" ondblclick="editNodeTitle(event, this)">${fileName}</div>
                    <div class="node-actions">
                        <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                        <button class="node-action" onclick="editNode(event, this)">✏️</button>
                        <button class="node-action" onclick="deleteNode(event, this)">🗑️</button>
                    </div>
                </div>
                <div class="node-children"></div>
            `;
            
            // 🔥 直接存储文件内容到DOM元素
            fileNode.setAttribute('data-file-content', content);
            fileNode.setAttribute('data-file-name', fileName);
            fileNode.setAttribute('data-file-size', originalFile.size);
            
            return fileNode;
        }
        
        // 💻 使用本地工具打开文件
        window.openFileWithLocalTool = function(event, nodeContent) {
            event.stopPropagation();
            
            // 防止点击操作按钮时触发
            if (event.target.classList.contains('node-action') || 
                event.target.closest('.node-actions')) {
                return;
            }
            
            const nodeElement = nodeContent.closest('.tree-node');
            const fileName = nodeElement.getAttribute('data-file-name');
            const fileType = nodeElement.getAttribute('data-file-type');
            const storageKey = nodeElement.getAttribute('data-file-storage-key');
            
            console.log('💻 尝试用本地工具打开文件:', fileName);
            console.log('🔑 使用存储键:', storageKey);
            
            try {
                // 🔥 从localStorage获取文件数据
                const fileDataStr = localStorage.getItem(storageKey);
                console.log('💾 localStorage中的数据:', fileDataStr ? '存在' : '不存在');
                
                if (!fileDataStr) {
                    console.error('❌ 文件数据不存在，存储键:', storageKey);
                    
                    // 🔍 尝试查找所有可能的存储键
                    const allKeys = Object.keys(localStorage);
                    const fileKeys = allKeys.filter(key => key.startsWith('file_') && key.includes(fileName));
                    console.log('🔍 找到的相关文件键:', fileKeys);
                    
                    if (fileKeys.length > 0) {
                        // 使用找到的第一个键重试
                        const alternativeKey = fileKeys[0];
                        const alternativeData = localStorage.getItem(alternativeKey);
                        console.log('🔄 使用替代键:', alternativeKey);
                        
                        if (alternativeData) {
                            const fileData = JSON.parse(alternativeData);
                            console.log('✅ 使用替代数据成功');
                            showIntelligentFileModal(fileName, fileData);
                            return;
                        }
                    }
                    
                    showNotification(`❌ 文件数据不存在，请重新上传`, 'warning');
                    return;
                }
                
                const fileData = JSON.parse(fileDataStr);
                console.log('📄 解析的文件数据:', {
                    hasTextContent: !!fileData.textContent,
                    textContentLength: fileData.textContent?.length || 0,
                    hasLocalContent: !!fileData.hasLocalContent,
                    dataSize: fileData.data?.length || 0,
                    fileSize: fileData.size,
                    fileName: fileData.name
                });
                
                // 🔥 调用智能文件预览模态框
                showIntelligentFileModal(fileName, fileData);
                
            } catch (error) {
                console.error('❌ 打开文件失败:', error);
                showNotification(`❌ 打开文件失败: ${error.message}`, 'error');
            }
        };
        
        // 🧠 显示GraphRAG分析结果
        window.showGraphRAGAnalysis = function(event, buttonElement) {
            event.stopPropagation();
            
            const nodeElement = buttonElement.closest('.tree-node');
            const fileName = nodeElement.getAttribute('data-file-name');
            const concepts = JSON.parse(nodeElement.getAttribute('data-ai-concepts') || '[]');
            const confidence = nodeElement.getAttribute('data-ai-confidence');
            const summary = nodeElement.getAttribute('data-ai-summary');
            
            console.log('🧠 显示GraphRAG分析结果:', fileName);
            
            // 🔍 从分析数据库获取完整数据
            const analysisDB = JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}');
            let fullAnalysis = null;
            
            // 查找匹配的分析记录
            for (const key in analysisDB) {
                if (analysisDB[key].fileName === fileName) {
                    fullAnalysis = analysisDB[key];
                    break;
                }
            }
            
            // 创建分析结果显示模态框
            const modal = document.createElement('div');
            modal.className = 'analysis-modal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.7); z-index: 6000; display: flex; 
                align-items: center; justify-content: center;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white; padding: 32px; border-radius: 16px; 
                width: 700px; max-width: 90vw; max-height: 80vh; overflow-y: auto;
                box-shadow: 0 20px 60px rgba(0,0,0,0.4);
            `;
            
            modalContent.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3 style="margin: 0; color: #1f2937;">🧠 GraphRAG 分析结果</h3>
                    <button onclick="this.closest('.analysis-modal').remove()" 
                            style="background: none; border: none; font-size: 24px; cursor: pointer;">×</button>
                </div>
                
                <div style="margin-bottom: 20px; padding: 16px; background: #f8fafc; border-radius: 8px;">
                    <h4 style="margin: 0 0 8px 0; color: #374151;">📄 文件信息</h4>
                    <p style="margin: 4px 0; color: #6b7280;">文件名: ${fileName}</p>
                    <p style="margin: 4px 0; color: #6b7280;">分析时间: ${fullAnalysis?.timestamp || '未知'}</p>
                    <p style="margin: 4px 0; color: #6b7280;">置信度: ${safePercent(confidence)}%</p>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <h4 style="margin: 0 0 12px 0; color: #374151;">🏷️ 识别的概念</h4>
                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                        ${concepts.map(concept => `
                            <span style="background: #dbeafe; color: #1e40af; padding: 4px 8px; border-radius: 4px; font-size: 12px;">
                                ${concept}
                            </span>
                        `).join('')}
                    </div>
                </div>
                
                ${fullAnalysis?.entities ? `
                <div style="margin-bottom: 20px;">
                    <h4 style="margin: 0 0 12px 0; color: #374151;">👥 识别的实体</h4>
                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                        ${fullAnalysis.entities.map(entity => `
                            <span style="background: #dcfce7; color: #166534; padding: 4px 8px; border-radius: 4px; font-size: 12px;">
                                ${entity}
                            </span>
                        `).join('')}
                    </div>
                </div>
                ` : ''}
                
                <div style="margin-bottom: 20px;">
                    <h4 style="margin: 0 0 12px 0; color: #374151;">📍 智能分类路径</h4>
                    <p style="background: #fef3c7; color: #92400e; padding: 12px; border-radius: 8px; margin: 0;">
                        ${fullAnalysis?.knowledgeTreePath || '未知'}
                    </p>
                </div>
                
                <div>
                    <h4 style="margin: 0 0 12px 0; color: #374151;">📝 内容摘要</h4>
                    <div style="background: #f9fafb; padding: 16px; border-radius: 8px; border-left: 4px solid #3b82f6; max-height: 300px; overflow-y: auto;">
                        ${fullAnalysis?.extractedContent || summary || '暂无摘要'}
                    </div>
                </div>
                
                <div style="text-align: center; margin-top: 24px;">
                    <button onclick="this.closest('.analysis-modal').remove()" 
                            style="background: #3b82f6; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                        关闭
                    </button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
        };
        
        // 🔥 新函数：直接添加已分析的文件到知识库
        async function addAnalyzedFileToKnowledgeTree(analysisResult, suggestedPath, fileName) {
            console.log('📁 Adding analyzed file to knowledge tree:', fileName, '->', suggestedPath);
            
            // 解析路径
            const pathParts = suggestedPath.split('/').filter(part => part.trim());
            
            // 创建知识库条目，使用已分析的内容
            const knowledgeEntry = {
                id: generateUniqueId(),
                name: fileName,
                content: analysisResult.extractedContent || '文档内容解析完成',
                path: suggestedPath,
                pathParts: pathParts,
                type: analysisResult.fileType || 'unknown',
                size: analysisResult.fileSize || 0,
                uploadDate: new Date().toISOString(),
                lastModified: new Date().toISOString(),
                // 附加AI分析结果
                aiAnalysis: {
                    concepts: analysisResult.concepts || [],
                    entities: analysisResult.entities || [],
                    confidence: analysisResult.confidence || 0.8,
                    summary: analysisResult.extractedContent || ''
                }
            };
            
            // 添加到知识库存储
            await saveToKnowledgeBase(knowledgeEntry);
            console.log('💾 File saved to knowledge base');
            
            // 🔥 不再需要刷新整个知识树，因为文件已直接添加到DOM
            console.log('✅ 文件已添加到知识树，无需重新生成');
            
            console.log('✅ Analyzed file successfully added to knowledge base');
        }
        
        // 将文件添加到知识树
        async function addFileToKnowledgeTree(file, suggestedPath, fileName) {
            console.log('📁 Adding file to knowledge tree:', fileName, '->', suggestedPath);
            
            // 读取文件内容
            const content = await readFileContent(file);
            
            // 解析路径
            const pathParts = suggestedPath.split('/').filter(part => part.trim());
            
            // 创建或获取知识库条目
            const knowledgeEntry = {
                id: generateUniqueId(),
                name: fileName,
                content: content,
                path: suggestedPath,
                pathParts: pathParts,
                type: getFileType(file),
                size: file.size,
                uploadDate: new Date().toISOString(),
                lastModified: file.lastModified ? new Date(file.lastModified).toISOString() : new Date().toISOString()
            };
            
            // 添加到知识库存储
            await saveToKnowledgeBase(knowledgeEntry);
            
            console.log('✅ File successfully added to knowledge base');
        }
        
        // 读取并解析文件内容
        async function readFileContent(file) {
            console.log('📄 Reading file content:', file.name, 'Type:', file.type);
            
            // 对于PDF文件，使用PDF.js解析
            if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {
                console.log('🔍 Detected PDF file, using PDF parsing');
                return await extractPDFText(file);
            }
            
            // 对于其他文本文件，使用普通文本读取
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => {
                    const content = e.target.result || '';
                    console.log(`📝 Text file content extracted: ${content.length} characters`);
                    resolve(content);
                };
                reader.onerror = e => {
                    console.error('❌ Failed to read file content:', e);
                    resolve(''); // 返回空字符串而不是reject
                };
                reader.readAsText(file);
            });
        }
        
        // 从PDF文件中提取文本内容 - 使用PDF.js
        async function extractPDFText(file) {
            try {
                console.log('📖 Starting PDF text extraction using PDF.js for:', file.name);
                
                const arrayBuffer = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
                
                // 配置PDF.js worker
                if (typeof pdfjsLib !== 'undefined') {
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                    
                    // 加载PDF文档
                    const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                    console.log('📖 PDF loaded successfully, total pages:', pdf.numPages);
                    
                    let fullText = '';
                    
                    // 遍历所有页面提取文本
                    for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                        try {
                            const page = await pdf.getPage(pageNum);
                            const textContent = await page.getTextContent();
                            
                            const pageText = textContent.items.map(item => item.str).join(' ');
                            fullText += pageText + '\n\n';
                            
                            console.log(`✅ Page ${pageNum} extracted: ${pageText.length} characters`);
                        } catch (pageError) {
                            console.error(`❌ Error extracting page ${pageNum}:`, pageError);
                            fullText += `[Page ${pageNum} extraction failed]\n\n`;
                        }
                    }
                    
                    console.log('✅ PDF text extraction completed:', fullText.length, 'total characters');
                    return fullText.trim();
                } else {
                    console.error('❌ PDF.js not available, falling back to simple extraction');
                    return await fallbackPDFExtraction(arrayBuffer);
                }
                
            } catch (error) {
                console.error('❌ PDF text extraction failed:', error);
                return `PDF文件: ${file.name} (提取失败: ${error.message})`;
            }
        }
        
        // 备用PDF提取方法
        async function fallbackPDFExtraction(arrayBuffer) {
            try {
                const uint8Array = new Uint8Array(arrayBuffer);
                const decoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: false });
                const pdfString = decoder.decode(uint8Array);
                
                let text = '';
                
                // 查找文本内容的简单正则表达式
                const textMatches = pdfString.match(/BT\s+.*?\s+ET/gs);
                if (textMatches) {
                    for (const match of textMatches) {
                        const textContent = match.match(/\((.*?)\)/g);
                        if (textContent) {
                            textContent.forEach(t => {
                                text += t.replace(/[()]/g, '') + ' ';
                            });
                        }
                    }
                }
                
                if (text.length < 50) {
                    const lines = pdfString.split('\n');
                    for (const line of lines) {
                        if (line.length > 10 && 
                            !line.match(/^[<>%\d\s]+$/) &&
                            !line.includes('obj') &&
                            !line.includes('endobj') &&
                            !line.includes('stream') &&
                            !line.includes('endstream')) {
                            
                            const cleanLine = line.replace(/[^\w\s\u4e00-\u9fff.,!?;:()\-]/g, '').trim();
                            if (cleanLine.length > 5) {
                                text += cleanLine + '\n';
                            }
                        }
                    }
                }
                
                console.log(`✅ Fallback PDF text extraction completed: ${text.length} characters`);
                
                if (text.length < 50) {
                    return `PDF文件：${file.name}\n\n提取的文本内容较少。这可能是因为PDF包含图片、扫描内容或特殊格式。\n\n建议：\n- 如果是扫描PDF，请使用OCR工具转换\n- 如果是加密PDF，请先解锁\n- 可以手动复制粘贴文本内容到编辑框`;
                }
                
                return text.trim();
                
            } catch (error) {
                console.error('❌ Fallback PDF text extraction failed:', error);
                return `PDF文件：${file.name}\n\nPDF文本提取失败：${error.message}\n\n建议：\n- 检查PDF文件是否完整\n- 尝试重新上传\n- 可以手动复制粘贴文本内容`;
            }
        }
        
        // 保存到知识库
        async function saveToKnowledgeBase(entry) {
            console.log('💾 保存文件到知识库:', entry.name, '路径:', entry.path);
            
            // 获取现有的知识库数据，确保保持原有结构
            let knowledgeBase = JSON.parse(localStorage.getItem('intelligentWorkflowKB') || '{}');
            console.log('📚 现有知识库结构:', Object.keys(knowledgeBase));
            
            // 按路径组织数据 - 简化版本，直接添加到顶级类别
            const pathParts = entry.pathParts;
            const categoryName = pathParts[0]; // 使用第一级作为主要类别
            
            // 确保类别存在
            if (!knowledgeBase[categoryName]) {
                console.log('🆕 创建新类别:', categoryName);
                knowledgeBase[categoryName] = {
                    _metadata: {
                        type: 'folder',
                        created: new Date().toISOString()
                    },
                    files: [],
                    children: {}
                };
            }
            
            // 确保files数组存在
            if (!knowledgeBase[categoryName].files) {
                knowledgeBase[categoryName].files = [];
            }
            
            // 检查文件是否已存在（避免重复）
            const existingFileIndex = knowledgeBase[categoryName].files.findIndex(f => f.name === entry.name);
            if (existingFileIndex >= 0) {
                console.log('🔄 更新现有文件:', entry.name);
                knowledgeBase[categoryName].files[existingFileIndex] = entry;
            } else {
                console.log('📄 添加新文件:', entry.name);
                knowledgeBase[categoryName].files.push(entry);
            }
            
            // 保存到localStorage
            localStorage.setItem('intelligentWorkflowKB', JSON.stringify(knowledgeBase));
            
            // 🔍 调试输出
            console.log('📊 Knowledge base after save:', {
                totalCategories: Object.keys(knowledgeBase).length,
                entry: entry,
                pathParts: pathParts,
                savedStructure: knowledgeBase
            });
        }
        
        // 跳转到知识库
        async function navigateToKnowledgeTree(suggestedPath, fileName) {
            console.log('🧭 Navigating to knowledge tree:', suggestedPath, fileName);
            
            // 显示加载状态
            showNotification('🧭 正在跳转到知识库...', 'info');
            
            // 确保知识面板是打开的
            const knowledgePanel = document.getElementById('knowledgePanel');
            if (!knowledgePanel || !knowledgePanel.classList.contains('open')) {
                console.log('📚 Opening knowledge panel...');
                openKnowledgePanel();
                
                // 同时激活知识库步骤
                const knowledgeStep = document.querySelector('[data-step="knowledge"]');
                const inputStep = document.querySelector('[data-step="input"]');
                
                if (knowledgeStep && inputStep) {
                    inputStep.classList.remove('active');
                    knowledgeStep.classList.add('active');
                    console.log('✅ Activated knowledge step');
                }
            } else {
                console.log('✅ Knowledge panel already open');
            }
            
            // 智能重试导航到知识树
            function tryNavigateToPath(retries = 3, delay = 800) {
                setTimeout(() => {
                    try {
                        // 检查知识库面板是否可见
                        const knowledgePanel = document.getElementById('knowledgePanel');
                        if (!knowledgePanel || !knowledgePanel.classList.contains('open')) {
                            console.log('🔄 Knowledge panel not ready, retrying...');
                            if (retries > 0) {
                                tryNavigateToPath(retries - 1, delay + 300);
                                return;
                            }
                        }
                        
                        // 🔥 不再重新生成知识树，文件已直接添加到DOM
                        console.log('🔄 跳过知识树重建，使用现有结构');
                        
                        // 等待知识树DOM更新
                        setTimeout(() => {
                            try {
                                expandToPath(suggestedPath, fileName);
                                showNotification(`🎯 已跳转到 "${suggestedPath}"`, 'success');
                            } catch (expandError) {
                                console.error('❌ Path expansion failed:', expandError);
                                if (retries > 0) {
                                    console.log(`🔄 Retrying navigation (${retries} attempts left)`);
                                    tryNavigateToPath(retries - 1, delay + 300);
                                } else {
                                    showNotification('⚠️ 路径展开失败，但文件已成功添加到知识库', 'warning');
                                }
                            }
                        }, 200);
                        
                    } catch (error) {
                        console.error('❌ Navigation failed:', error);
                        if (retries > 0) {
                            tryNavigateToPath(retries - 1, delay + 300);
                        } else {
                            showNotification('⚠️ 跳转到知识库时出现问题，但文件已保存', 'warning');
                        }
                    }
                }, delay);
            }
            
            tryNavigateToPath();
        }
        
        // 🌐 从后端同步现有文档数据
        async function syncDocumentsFromBackend() {
            console.log('🔄 尝试从后端同步现有文档...');
            
            try {
                const response = await fetch('http://127.0.0.1:3001/api/documents', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    timeout: 5000
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('📥 后端文档响应:', data);
                    
                    if (data.success && data.documents && data.documents.length > 0) {
                        console.log(`✅ 发现 ${data.documents.length} 个后端文档，开始同步到本地存储`);
                        
                        // 获取现有的持久化数据
                        let persistentTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
                        let analysisDB = JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}');
                        
                        for (const doc of data.documents) {
                            console.log('📄 同步文档:', doc.title);
                            
                            // 根据文档类型确定分类
                            let category = '📂 未分类';
                            if (doc.type === 'github_project') {
                                category = '🔗 开源项目';
                            }
                            
                            // 添加到知识树 - 使用正确的数据结构
                            if (!persistentTree[category]) {
                                persistentTree[category] = {
                                    files: [],
                                    aiSuggested: true,
                                    concepts: [],
                                    confidence: 0.9
                                };
                            }
                            
                            // 确保 files 数组存在
                            if (!persistentTree[category].files) {
                                persistentTree[category].files = [];
                            }
                            
                            // 检查是否已存在该文件
                            const existingFileIndex = persistentTree[category].files.findIndex(f => f.name === doc.title);
                            
                            const fileData = {
                                name: doc.title,
                                id: doc.id,
                                type: doc.type || 'document',
                                content_length: doc.content_length,
                                created_at: doc.created_at,
                                entities_count: doc.entities_count || 0,
                                relationships_count: doc.relationships_count || 0,
                                source: 'backend_sync'
                            };
                            
                            if (existingFileIndex >= 0) {
                                // 更新现有文件
                                persistentTree[category].files[existingFileIndex] = fileData;
                            } else {
                                // 添加新文件
                                persistentTree[category].files.push(fileData);
                            }
                            
                            // 获取详细内容并添加到分析数据库
                            try {
                                const contentResponse = await fetch(`http://127.0.0.1:3001/api/documents/${doc.id}/content`, {
                                    timeout: 5000
                                });
                                
                                if (contentResponse.ok) {
                                    const contentData = await contentResponse.json();
                                    if (contentData.success && contentData.document) {
                                        const timestamp = new Date().toISOString();
                                        const key = `${doc.title}_${timestamp}`;
                                        
                                        analysisDB[key] = {
                                            title: doc.title,
                                            content: contentData.document.content.raw_content || '',
                                            analysis: contentData.document.analysis || {},
                                            structure: contentData.document.document_structure || {},
                                            timestamp: timestamp,
                                            source: 'backend_sync'
                                        };
                                        
                                        // 🔧 修复：为fileData添加storageKey，以便openFileWithLocalTool能找到文件内容
                                        fileData.storageKey = key;
                                        
                                        // 💾 保存文件数据到localStorage（用于openFileWithLocalTool函数）
                                        const fileStorageData = {
                                            fileName: doc.title,
                                            textContent: contentData.document.content.raw_content || '',
                                            analysis: contentData.document.analysis || {},
                                            structure: contentData.document.document_structure || {},
                                            timestamp: timestamp,
                                            source: 'backend_sync'
                                        };
                                        localStorage.setItem(key, JSON.stringify(fileStorageData));
                                        
                                        console.log(`✅ 已同步文档内容: ${doc.title}, 存储键: ${key}`);
                                    }
                                }
                            } catch (contentError) {
                                console.warn(`⚠️ 获取文档内容失败: ${doc.title}`, contentError);
                            }
                        }
                        
                        // 保存更新后的数据
                        localStorage.setItem('intelligentWorkflowKnowledgeTree', JSON.stringify(persistentTree));
                        localStorage.setItem('graphRAGAnalysisDB', JSON.stringify(analysisDB));
                        
                        console.log('✅ 后端文档同步完成');
                        return true;
                    } else {
                        console.log('📭 后端暂无文档数据');
                        return false;
                    }
                } else {
                    console.warn('⚠️ 后端文档接口响应异常:', response.status);
                    return false;
                }
            } catch (error) {
                console.warn('⚠️ 后端同步失败，可能服务未启动:', error.message);
                return false;
            }
        }
        
        // 🔄 页面加载时恢复知识树
        async function regenerateKnowledgeTree() {
            console.log('🌳 重新生成知识树，恢复持久化数据');
            
            const treeContainer = document.getElementById('knowledgeTree');
            if (!treeContainer) {
                console.error('❌ Tree container not found!');
                return;
            }
            
            // 🌐 首先尝试从后端同步数据
            const backendSyncSuccess = await syncDocumentsFromBackend();
            
            // 🔥 从持久化的知识树恢复（现在包含后端同步的数据）
            const persistentTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
            const hasPeristentData = Object.keys(persistentTree).length > 0;
            
            console.log('📊 持久化知识树数据:', hasPeristentData ? '存在' : '不存在');
            console.log('📁 分类数量:', Object.keys(persistentTree).length);
            console.log('🌐 后端同步状态:', backendSyncSuccess ? '成功' : '失败/无数据');
            
            if (hasPeristentData) {
                console.log('🔄 从持久化数据恢复知识树（包含后端数据）');
                restoreKnowledgeTreeFromPersistentData(persistentTree, treeContainer);
            } else {
                // 回退到原有的知识库数据
                const legacyKnowledgeBase = JSON.parse(localStorage.getItem('intelligentWorkflowKB') || '{}');
                const hasExistingNodes = treeContainer.querySelector('.tree-node');
                
                if (hasExistingNodes) {
                    console.log('✅ 保持现有知识树结构');
                    updateExistingKnowledgeTree(legacyKnowledgeBase);
                } else if (Object.keys(legacyKnowledgeBase).length > 0) {
                    console.log('🔄 从传统知识库恢复');
                    buildTreeFromKnowledgeBase(legacyKnowledgeBase, treeContainer);
                } else {
                    console.log('📁 显示空状态');
                    treeContainer.innerHTML = '<div class="empty-message" style="padding: 20px; color: #666; text-align: center;">📁 知识库为空，请上传文档开始使用</div>';
                }
            }
        }
        
        // 🧹 清理函数（调试用）
        window.clearAllKnowledgeData = function() {
            console.log('🧹 清理所有知识库数据');
            localStorage.removeItem('intelligentWorkflowKnowledgeTree');
            localStorage.removeItem('intelligentWorkflowKB');
            localStorage.removeItem('graphRAGAnalysisDB');
            
            // 清理所有文件存储
            const keys = Object.keys(localStorage);
            keys.forEach(key => {
                if (key.startsWith('file_')) {
                    localStorage.removeItem(key);
                    console.log('🗑️ 删除文件:', key);
                }
            });
            
            // 重新生成知识树
            const treeContainer = document.getElementById('knowledgeTree');
            if (treeContainer) {
                treeContainer.innerHTML = '<div class="empty-message" style="padding: 20px; color: #666; text-align: center;">📁 知识库已清空</div>';
            }
            
            console.log('✅ 所有数据已清理完成');
        };
        
        // 🧹 清理知识树中的重复文件
        window.cleanupDuplicateFiles = function() {
            console.log('🧹 开始清理知识树中的重复文件');
            
            try {
                // 获取知识树数据
                const knowledgeTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
                const fileTracker = new Map(); // 追踪文件名出现次数
                let duplicatesRemoved = 0;
                
                // 第一遍：统计所有文件
                for (const [categoryName, categoryData] of Object.entries(knowledgeTree)) {
                    if (categoryData.files) {
                        categoryData.files.forEach(file => {
                            const fileName = file.name;
                            if (!fileTracker.has(fileName)) {
                                fileTracker.set(fileName, []);
                            }
                            fileTracker.get(fileName).push({ category: categoryName, file });
                        });
                    }
                }
                
                // 第二遍：清理重复文件（保留最新的）
                for (const [fileName, locations] of fileTracker.entries()) {
                    if (locations.length > 1) {
                        console.log(`🔍 发现重复文件 "${fileName}" 出现在 ${locations.length} 个位置`);
                        
                        // 按添加时间排序，保留最新的
                        locations.sort((a, b) => new Date(b.file.addedAt || 0) - new Date(a.file.addedAt || 0));
                        const keepLocation = locations[0];
                        const removeLocations = locations.slice(1);
                        
                        console.log(`📌 保留: ${keepLocation.category}/${fileName}`);
                        
                        // 移除重复的文件
                        for (const removeLocation of removeLocations) {
                            const category = knowledgeTree[removeLocation.category];
                            if (category && category.files) {
                                const beforeCount = category.files.length;
                                category.files = category.files.filter(f => f.name !== fileName);
                                const afterCount = category.files.length;
                                
                                if (beforeCount > afterCount) {
                                    duplicatesRemoved++;
                                    console.log(`🗑️ 从 "${removeLocation.category}" 中移除重复文件 "${fileName}"`);
                                }
                            }
                        }
                    }
                }
                
                // 保存清理后的数据
                localStorage.setItem('intelligentWorkflowKnowledgeTree', JSON.stringify(knowledgeTree));
                
                // 重新生成知识树显示
                regenerateKnowledgeTree();
                
                console.log(`✅ 清理完成！移除了 ${duplicatesRemoved} 个重复文件`);
                alert(`清理完成！\n移除了 ${duplicatesRemoved} 个重复文件\n请刷新页面查看结果`);
                
            } catch (error) {
                console.error('❌ 清理重复文件失败:', error);
                alert('清理失败：' + error.message);
            }
        }

        // 🧪 测试和重置拖拽功能
        window.resetDragAndDrop = function() {
            console.log('🧪 重置拖拽功能状态...');
            window.isProcessingFiles = false;
            window.lastProcessedSignature = null;
            window.currentAnalysisResults = {};
            window.currentUploadedFiles = [];
            
            // 清理所有文件锁
            Object.keys(window).forEach(key => {
                if (key.startsWith('saving_')) {
                    window[key] = false;
                }
            });
            
            console.log('✅ 拖拽功能状态已重置');
            alert('拖拽功能已重置！现在应该可以正常拖拽文件了。');
        }

        // 🔍 调试函数：查看当前存储状态
        window.debugKnowledgeStorage = function() {
            console.log('🔍 调试知识库存储状态:');
            console.log('📊 新持久化知识树:', JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}'));
            console.log('📊 旧知识库:', JSON.parse(localStorage.getItem('intelligentWorkflowKB') || '{}'));
            console.log('📊 GraphRAG分析库:', Object.keys(JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}')).length, '条记录');
            console.log('📊 文件存储:', Object.keys(localStorage).filter(k => k.startsWith('file_')).length, '个文件');
            
            // 列出所有localStorage键
            console.log('📊 所有localStorage键:', Object.keys(localStorage));
        };
        
        // 🔧 测试文件内容存储
        window.testFileContent = function(fileName) {
            console.log('🔧 测试文件内容存储:', fileName);
            
            // 查找所有相关的存储键
            const allKeys = Object.keys(localStorage);
            const fileKeys = allKeys.filter(key => key.startsWith('file_') && key.includes(fileName));
            
            console.log('📁 找到相关存储键:', fileKeys);
            
            fileKeys.forEach(key => {
                const dataStr = localStorage.getItem(key);
                if (dataStr) {
                    try {
                        const data = JSON.parse(dataStr);
                        console.log(`📄 存储键: ${key}`);
                        console.log('  - 文件名:', data.name);
                        console.log('  - 文件类型:', data.type);
                        console.log('  - 文件大小:', data.size);
                        console.log('  - 有完整内容:', !!data.hasLocalContent);
                        console.log('  - 有文本内容:', !!data.textContent, data.textContent?.length);
                        if (data.textContent) {
                            console.log('  - 文本内容预览:', data.textContent.substring(0, 200));
                        }
                    } catch (e) {
                        console.error('❌ 解析存储数据失败:', e);
                    }
                }
            });
        };
        
        // 🔧 测试拖拽功能状态
        window.testDragDrop = function() {
            console.log('🔧 测试拖拽功能状态...');
            
            const inputContainer = document.querySelector('.multimodal-input-container');
            const fileDropZone = document.querySelector('.file-drop-zone');
            
            console.log('📋 拖拽元素检查:');
            console.log('  - Input Container存在:', !!inputContainer);
            console.log('  - File Drop Zone存在:', !!fileDropZone);
            
            if (inputContainer) {
                // 检查事件监听器（虽然无法直接检查，但可以触发测试）
                console.log('  - Input Container classes:', inputContainer.classList.toString());
                console.log('  - Input Container styles:', inputContainer.style.cssText);
            }
            
            if (fileDropZone) {
                console.log('  - File Drop Zone classes:', fileDropZone.classList.toString());
                console.log('  - File Drop Zone styles:', fileDropZone.style.cssText);
            }
            
            // 检查是否在文件模式
            const fileInputMode = document.getElementById('fileInputMode');
            console.log('  - 文件输入模式显示:', fileInputMode?.style.display !== 'none');
            
            console.log('💡 请尝试拖拽文件到输入区域查看控制台输出');
        };
        
        // 🔧 测试删除真实文件功能
        window.testDeleteRealFile = function() {
            console.log('🔧 测试删除真实文件...');
            
            const knowledgeTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
            console.log('📊 当前知识树:', knowledgeTree);
            
            // 找到第一个真实文件
            for (const [categoryName, categoryData] of Object.entries(knowledgeTree)) {
                if (categoryData.files && categoryData.files.length > 0) {
                    const realFile = categoryData.files[0];
                    console.log(`🎯 找到真实文件: "${realFile.name}" 在分类 "${categoryName}" 中`);
                    
                    // 模拟删除
                    console.log('🗑️ 开始删除测试...');
                    cleanupFileFromPersistentData(realFile.name);
                    
                    const newTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
                    console.log('📊 删除后知识树:', newTree);
                    return;
                }
            }
            
            console.log('⚠️ 没有找到真实文件');
        };
        
        // 🔧 测试删除功能是否正常绑定
        window.testDeleteFunction = function() {
            console.log('🔧 Testing delete function binding...');
            
            // 检查函数是否存在
            console.log('🔧 window.deleteNode exists:', typeof window.deleteNode);
            
            // 查找删除按钮
            const deleteButtons = document.querySelectorAll('button[onclick*="deleteNode"]');
            console.log('🔧 Found delete buttons:', deleteButtons.length);
            
            deleteButtons.forEach((btn, index) => {
                console.log(`🔧 Button ${index}:`, btn.outerHTML);
            });
            
            // 查找所有.node-action按钮
            const actionButtons = document.querySelectorAll('.node-action');
            console.log('🔧 Found action buttons:', actionButtons.length);
            
            actionButtons.forEach((btn, index) => {
                const text = btn.textContent || btn.innerHTML;
                if (text.includes('🗑️')) {
                    console.log(`🔧 Delete button ${index}:`, btn.outerHTML);
                }
            });
        };
        
        // 🗑️ 清理文件的持久化数据
        function cleanupFileFromPersistentData(fileName) {
            console.log('🗑️ 清理文件持久化数据:', fileName);
            
            try {
                // 🔥 清理新的知识树结构
                let knowledgeTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
                let fileRemoved = false;
                
                console.log('🔍 正在搜索文件名:', fileName);
                console.log('🔍 知识树结构:', Object.keys(knowledgeTree));
                
                for (const [categoryName, categoryData] of Object.entries(knowledgeTree)) {
                    if (categoryData.files) {
                        console.log(`🔍 分类 "${categoryName}" 中的文件:`, categoryData.files.map(f => f.name));
                        const beforeCount = categoryData.files.length;
                        categoryData.files = categoryData.files.filter(file => {
                            const matches = file.name === fileName;
                            if (!matches) {
                                console.log(`🔍 文件名不匹配: "${file.name}" !== "${fileName}"`);
                            }
                            return !matches;
                        });
                        if (categoryData.files.length < beforeCount) {
                            fileRemoved = true;
                            console.log(`🗑️ 从分类 "${categoryName}" 中移除文件 "${fileName}"`);
                        }
                    }
                }
                
                localStorage.setItem('intelligentWorkflowKnowledgeTree', JSON.stringify(knowledgeTree));
                
                // 🔥 同时清理旧的知识库结构  
                let knowledgeBase = JSON.parse(localStorage.getItem('intelligentWorkflowKB') || '{}');
                for (const [categoryName, categoryData] of Object.entries(knowledgeBase)) {
                    if (categoryData.files) {
                        const beforeCount = categoryData.files.length;
                        categoryData.files = categoryData.files.filter(file => file.name !== fileName);
                        if (categoryData.files.length < beforeCount) {
                            fileRemoved = true;
                            console.log(`🗑️ 从旧知识库分类 "${categoryName}" 中移除文件 "${fileName}"`);
                        }
                    }
                }
                localStorage.setItem('intelligentWorkflowKB', JSON.stringify(knowledgeBase));
                
                // 清理GraphRAG分析数据
                let analysisDB = JSON.parse(localStorage.getItem('graphRAGAnalysisDB') || '{}');
                delete analysisDB[fileName];
                localStorage.setItem('graphRAGAnalysisDB', JSON.stringify(analysisDB));
                
                // 清理文件存储
                const storageKeys = Object.keys(localStorage).filter(key => key.startsWith('file_') && key.includes(fileName));
                storageKeys.forEach(key => {
                    localStorage.removeItem(key);
                    console.log(`🗑️ 移除文件存储: ${key}`);
                });
                
                console.log('✅ 文件持久化数据已完全清理, 文件已移除:', fileRemoved);
                
            } catch (error) {
                console.error('❌ 清理文件数据失败:', error);
            }
        }
        
        // 🗑️ 清理分类的持久化数据
        function cleanupCategoryFromPersistentData(categoryName) {
            console.log('🗑️ 清理分类持久化数据:', categoryName);
            
            try {
                // 🔥 清理新的知识树结构
                let knowledgeTree = JSON.parse(localStorage.getItem('intelligentWorkflowKnowledgeTree') || '{}');
                const treeHadCategory = categoryName in knowledgeTree;
                delete knowledgeTree[categoryName];
                localStorage.setItem('intelligentWorkflowKnowledgeTree', JSON.stringify(knowledgeTree));
                
                // 🔥 同时清理旧的知识库结构
                let knowledgeBase = JSON.parse(localStorage.getItem('intelligentWorkflowKB') || '{}');
                const baseHadCategory = categoryName in knowledgeBase;
                delete knowledgeBase[categoryName];
                localStorage.setItem('intelligentWorkflowKB', JSON.stringify(knowledgeBase));
                
                console.log('✅ 分类持久化数据已完全清理:', {
                    fromTree: treeHadCategory,
                    fromBase: baseHadCategory
                });
                
            } catch (error) {
                console.error('❌ 清理分类数据失败:', error);
            }
        }
        
        // 🔄 从持久化数据恢复知识树
        function restoreKnowledgeTreeFromPersistentData(persistentTree, treeContainer) {
            console.log('🔄 从持久化数据恢复知识树');
            
            // 🔥 智能合并：只添加不存在的分类，保留现有内容
            console.log('🔄 智能合并知识树内容，保留现有结构');
            
            // 遍历每个分类
            for (const [categoryName, categoryData] of Object.entries(persistentTree)) {
                console.log(`📂 检查分类: ${categoryName} (${categoryData.files?.length || 0} 文件)`);
                
                // 🔍 检查分类是否已存在
                let existingCategory = findNodeByTitle(categoryName);
                
                if (!existingCategory) {
                    console.log(`➕ 创建新分类: ${categoryName}`);
                    // 创建分类节点（不自动添加）
                    const categoryNode = createIntelligentCategoryNode(categoryName, {
                        aiSuggested: categoryData.aiSuggested || false,
                        concepts: categoryData.concepts || [],
                        confidence: categoryData.confidence || 0.8
                    }, false);
                    
                    // 手动添加到知识树容器
                    treeContainer.appendChild(categoryNode);
                    existingCategory = categoryNode;
                } else {
                    console.log(`✅ 分类 "${categoryName}" 已存在，跳过创建`);
                }
                
                // 恢复分类下的文件
                if (categoryData.files && categoryData.files.length > 0) {
                    const childrenContainer = existingCategory.querySelector('.node-children');
                    
                    for (const fileData of categoryData.files) {
                        console.log(`📄 恢复文件: ${fileData.name}`);
                        
                        // 🔥 检查文件是否已存在，避免重复添加
                        const existingFiles = childrenContainer.querySelectorAll('.node-title');
                        const fileExists = Array.from(existingFiles).some(title => title.textContent.trim() === fileData.name);
                        
                        if (!fileExists) {
                            // 创建文件节点
                            const fileNode = createRestoredFileNode(fileData);
                            if (childrenContainer) {
                                childrenContainer.appendChild(fileNode);
                            }
                        } else {
                            console.log(`⚠️ 文件 "${fileData.name}" 已存在，跳过重复创建`);
                        }
                    }
                    
                    // 展开有文件的分类
                    expandNodePath(existingCategory);
                }
            }
            
            console.log('✅ 知识树恢复完成');
        }
        
        // 🔄 创建恢复的文件节点
        function createRestoredFileNode(fileData) {
            const fileNode = document.createElement('div');
            fileNode.className = 'tree-node';
            
            const confidenceIcon = (fileData.aiAnalysis?.confidence || 0) > 0.8 ? '🎯' : '📄';
            
            fileNode.innerHTML = `
                <div class="node-content" onclick="openFileWithLocalTool(event, this)" draggable="true" 
                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                    <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                    <div class="node-icon file">${confidenceIcon}</div>
                    <div class="node-title" ondblclick="editNodeTitle(event, this)">${fileData.name}</div>
                    <div class="node-actions">
                        <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                        <button class="node-action" onclick="editNode(event, this)">✏️</button>
                        <button class="node-action" onclick="deleteNode(event, this)">🗑️</button>
                        <button class="node-action" onclick="showGraphRAGAnalysis(event, this)" title="查看AI分析">🧠</button>
                    </div>
                </div>
                <div class="node-children"></div>
            `;
            
            // 恢复文件属性
            fileNode.setAttribute('data-file-name', fileData.name);
            fileNode.setAttribute('data-file-size', fileData.size);
            fileNode.setAttribute('data-file-type', fileData.type);
            fileNode.setAttribute('data-file-storage-key', fileData.storageKey);
            fileNode.setAttribute('data-ai-concepts', JSON.stringify(fileData.aiAnalysis?.concepts || []));
            fileNode.setAttribute('data-ai-confidence', fileData.aiAnalysis?.confidence || 0);
            fileNode.setAttribute('data-ai-summary', fileData.aiAnalysis?.summary || '');
            
            return fileNode;
        }
        
        // 🔥 更新现有知识树，添加新文件但保持原有结构和交互
        function updateExistingKnowledgeTree(knowledgeBase) {
            console.log('🔄 更新现有知识树结构');
            
            // 遍历知识库中的新数据，查找需要添加的文件
            Object.keys(knowledgeBase).forEach(categoryName => {
                const category = knowledgeBase[categoryName];
                if (category.files && category.files.length > 0) {
                    // 检查这个类别的文件是否已经在知识树中
                    const existingCategoryNode = findNodeByTitle(categoryName);
                    
                    if (existingCategoryNode) {
                        console.log(`✅ 找到现有类别: ${categoryName}`);
                        // 添加新文件到现有类别
                        addFilesToExistingCategory(existingCategoryNode, category.files);
                    } else {
                        console.log(`🆕 创建新类别: ${categoryName}`);
                        // 创建新的类别节点
                        createNewCategoryNode(categoryName, category);
                    }
                }
            });
        }
        
        // 在知识树中查找具有指定标题的节点
        function findNodeByTitle(title) {
            const knowledgeTree = document.getElementById('knowledgeTree');
            if (!knowledgeTree) return null;
            
            const titleElements = knowledgeTree.querySelectorAll('.node-title');
            for (const element of titleElements) {
                if (element.textContent.trim() === title) {
                    return element.closest('.tree-node');
                }
            }
            return null;
        }
        
        // 向现有类别添加文件
        function addFilesToExistingCategory(categoryNode, files) {
            const childrenContainer = categoryNode.querySelector('.node-children');
            if (!childrenContainer) return;
            
            files.forEach(file => {
                // 检查文件是否已存在
                const existingFile = findNodeByTitle(file.name);
                if (!existingFile) {
                    console.log(`📄 添加新文件到现有类别: ${file.name}`);
                    const fileNode = createFileNode(file);
                    childrenContainer.appendChild(fileNode);
                } else {
                    console.log(`✅ 文件已存在: ${file.name}`);
                }
            });
        }
        
        // 创建新的类别节点（完整交互功能）
        function createNewCategoryNode(categoryName, categoryData) {
            const knowledgeTree = document.getElementById('knowledgeTree');
            if (!knowledgeTree) return;
            
            const categoryNode = document.createElement('div');
            categoryNode.className = 'tree-node';
            categoryNode.innerHTML = `
                <div class="node-content" onclick="selectNode(this, event)" draggable="true" 
                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                    <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                    <div class="node-icon folder">📁</div>
                    <div class="node-title" ondblclick="editNodeTitle(event, this)">${categoryName}</div>
                    <div class="node-actions">
                        <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                        <button class="node-action" onclick="editNode(event, this)">✏️</button>
                        <button class="node-action" onclick="deleteNode(event, this)">🗑️</button>
                    </div>
                </div>
                <div class="node-children"></div>
            `;
            
            knowledgeTree.appendChild(categoryNode);
            
            // 添加文件到新类别
            if (categoryData.files) {
                addFilesToExistingCategory(categoryNode, categoryData.files);
            }
        }
        
        // 创建文件节点（完整交互功能）
        function createFileNode(file) {
            const fileNode = document.createElement('div');
            fileNode.className = 'tree-node';
            fileNode.innerHTML = `
                <div class="node-content" onclick="openFileWithLocalTool(event, this)" draggable="true" 
                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                    <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                    <div class="node-icon file">📄</div>
                    <div class="node-title" ondblclick="editNodeTitle(event, this)">${file.name}</div>
                    <div class="node-actions">
                        <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                        <button class="node-action" onclick="editNode(event, this)">✏️</button>
                        <button class="node-action" onclick="deleteNode(event, this)">🗑️</button>
                    </div>
                </div>
                <div class="node-children"></div>
            `;
            
            // 存储文件内容数据
            fileNode.setAttribute('data-file-content', file.content || '');
            fileNode.setAttribute('data-file-id', file.id || '');
            
            return fileNode;
        }
        
        // 从知识库构建树
        function buildTreeFromKnowledgeBase(data, container, level = 0) {
            console.log(`📂 Building tree at level ${level}, keys:`, Object.keys(data));
            
            Object.keys(data).forEach(key => {
                const item = data[key];
                console.log(`📄 Processing item: ${key}`, item);
                
                // 兼容多种数据结构
                const isFolder = (item._metadata && item._metadata.type === 'folder') || 
                                (item.type === 'category') ||
                                (item.children && Object.keys(item.children).length > 0) ||
                                (item.files && Array.isArray(item.files));
                
                if (isFolder) {
                    // 创建文件夹节点
                    const folderDiv = document.createElement('div');
                    folderDiv.className = 'category-item';
                    folderDiv.style.paddingLeft = `${level * 20}px`;
                    
                    folderDiv.innerHTML = `
                        <span class="toggle-arrow">▶</span>
                        <span class="category-icon">📁</span>
                        <span class="category-name">${key}</span>
                        <span class="file-count">${item.files?.length || 0} files</span>
                    `;
                    
                    container.appendChild(folderDiv);
                    
                    // 创建子容器
                    const subContainer = document.createElement('div');
                    subContainer.className = 'subcategory';
                    subContainer.style.display = 'none';
                    container.appendChild(subContainer);
                    
                    // 添加点击展开功能
                    folderDiv.addEventListener('click', () => {
                        const arrow = folderDiv.querySelector('.toggle-arrow');
                        if (subContainer.style.display === 'none') {
                            subContainer.style.display = 'block';
                            arrow.textContent = '▼';
                        } else {
                            subContainer.style.display = 'none';
                            arrow.textContent = '▶';
                        }
                    });
                    
                    // 递归添加子项
                    if (item.children) {
                        buildTreeFromKnowledgeBase(item.children, subContainer, level + 1);
                    }
                    
                    // 添加文件
                    if (item.files && item.files.length > 0) {
                        item.files.forEach(file => {
                            const fileDiv = document.createElement('div');
                            fileDiv.className = 'file-item';
                            fileDiv.style.paddingLeft = `${(level + 1) * 20}px`;
                            fileDiv.innerHTML = `
                                <span class="file-icon">📄</span>
                                <span class="file-name">${file.name}</span>
                                <span class="file-size">${formatFileSize(file.size)}</span>
                            `;
                            
                            // 添加点击查看功能
                            fileDiv.addEventListener('click', () => {
                                showFileContent(file);
                            });
                            
                            subContainer.appendChild(fileDiv);
                        });
                    }
                }
            });
        }
        
        // 自动创建分类路径到知识库
        async function createCategoryPath(categoryPath) {
            console.log('🆕 Creating category path:', categoryPath);
            
            const knowledgeBase = JSON.parse(localStorage.getItem('intelligentWorkflowKB') || '{}');
            const pathParts = categoryPath.split('/').filter(p => p.trim());
            
            let currentLevel = knowledgeBase;
            let currentPath = '';
            
            // 逐级创建路径
            for (const part of pathParts) {
                currentPath += (currentPath ? '/' : '') + part;
                
                if (!currentLevel[part]) {
                    console.log(`✨ Creating category: "${part}" at path: ${currentPath}`);
                    currentLevel[part] = {
                        _metadata: { 
                            type: 'folder',
                            autoCreated: true,
                            createdAt: new Date().toISOString()
                        },
                        children: {},
                        files: []
                    };
                }
                currentLevel = currentLevel[part].children;
            }
            
            // 保存更新后的知识库
            localStorage.setItem('intelligentWorkflowKB', JSON.stringify(knowledgeBase));
            console.log('✅ Category path created and saved to localStorage');
        }
        
        // 提取文件内容用于保存
        async function readFileContentForSave(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => {
                    const content = e.target.result || '';
                    console.log(`📄 Extracted content from ${file.name}: ${content.length} characters`);
                    resolve(content);
                };
                reader.onerror = e => {
                    console.error('❌ Failed to read file content:', e);
                    resolve(''); // 返回空字符串而不是reject
                };
                reader.readAsText(file);
            });
        }
        
        // 将文档保存到localStorage知识库中
        function saveDocumentToLocalStorage(targetPath, fileName, fileContent = null) {
            console.log('💾 Saving document to localStorage:', targetPath, fileName);
            
            const knowledgeBase = JSON.parse(localStorage.getItem('intelligentWorkflowKB') || '{}');
            const pathParts = targetPath.split(/[/>]/).filter(p => p.trim());
            
            let currentLevel = knowledgeBase;
            
            // 导航到最终路径
            for (const part of pathParts) {
                if (!currentLevel[part]) {
                    // 如果路径不存在，创建它
                    currentLevel[part] = {
                        _metadata: { 
                            type: 'folder',
                            autoCreated: true,
                            createdAt: new Date().toISOString()
                        },
                        children: {},
                        files: []
                    };
                }
                
                // 确保files数组存在
                if (!currentLevel[part].files) {
                    currentLevel[part].files = [];
                }
                
                // 如果这是最后一级，添加文件
                if (part === pathParts[pathParts.length - 1]) {
                    // 检查文件是否已存在
                    const existingFile = currentLevel[part].files.find(f => f.name === fileName);
                    if (!existingFile) {
                        const fileEntry = {
                            name: fileName,
                            type: 'document',
                            addedAt: new Date().toISOString(),
                            source: 'ai_upload'
                        };
                        
                        // 添加文件内容
                        if (fileContent) {
                            fileEntry.content = fileContent;
                            console.log(`✅ Document "${fileName}" with content (${fileContent.length} chars) saved to localStorage`);
                        } else {
                            console.warn(`⚠️ Document "${fileName}" saved without content`);
                        }
                        
                        currentLevel[part].files.push(fileEntry);
                        console.log(`✅ Document "${fileName}" saved to localStorage at path: ${targetPath}`);
                    }
                } else {
                    // 继续深入
                    currentLevel = currentLevel[part].children;
                }
            }
            
            // 保存更新后的知识库
            localStorage.setItem('intelligentWorkflowKB', JSON.stringify(knowledgeBase));
        }
        
        // 从localStorage知识库中获取文档内容
        function getContentFromKnowledgeBase(fileName) {
            console.log('🔍 Looking for content in knowledge base:', fileName);
            
            try {
                const knowledgeBase = JSON.parse(localStorage.getItem('intelligentWorkflowKB') || '{}');
                
                // 递归搜索所有层级的文件
                function searchInLevel(level, depth = 0) {
                    const indent = '  '.repeat(depth);
                    console.log(`${indent}🔍 Searching level:`, Object.keys(level));
                    
                    for (const key in level) {
                        const item = level[key];
                        
                        // 检查files数组
                        if (item.files && Array.isArray(item.files)) {
                            console.log(`${indent}📁 Checking files in "${key}":`, item.files.length);
                            for (const file of item.files) {
                                console.log(`${indent}  📄 File: "${file.name}"`);
                                if (file.name === fileName && file.content) {
                                    console.log(`${indent}  ✅ Found content for "${fileName}":`, file.content.substring(0, 100) + '...');
                                    return file.content;
                                }
                            }
                        }
                        
                        // 递归搜索子级
                        if (item.children && typeof item.children === 'object') {
                            const result = searchInLevel(item.children, depth + 1);
                            if (result) return result;
                        }
                    }
                    return null;
                }
                
                const content = searchInLevel(knowledgeBase);
                if (content) {
                    console.log('✅ Content found in knowledge base for:', fileName);
                } else {
                    console.log('❌ No content found in knowledge base for:', fileName);
                }
                
                return content;
                
            } catch (error) {
                console.error('❌ Error reading from knowledge base:', error);
                return null;
            }
        }

        // 展开到指定路径
        async function expandToPath(targetPath, fileName) {
            console.log('🎯 Expanding to path:', targetPath, fileName);
            
            // 检查知识树是否存在
            const categoryTree = document.getElementById('knowledgeTree');
            if (!categoryTree) {
                console.error('❌ Knowledge tree not found, retrying...');
                throw new Error('Knowledge tree container not found');
            }
            
            const pathParts = targetPath.split(/[/>]/).map(p => p.trim()).filter(p => p); // 支持 / 和 > 分隔符，去除空格
            console.log('📂 Path parts:', pathParts);
            
            // 逐级展开路径，如果路径不存在则自动创建
            // 从知识树的根容器开始
            let currentContainer = categoryTree;
            let currentPath = '';
            
            for (let i = 0; i < pathParts.length; i++) {
                const part = pathParts[i];
                currentPath += (currentPath ? '/' : '') + part;
                console.log(`🔍 Looking for category: "${part}" in path: ${currentPath}`);
                
                if (!currentContainer) {
                    console.error('❌ Container not found for part:', part);
                    break;
                }
                
                // 🔍 统一查找现有分类节点（支持不同类型的节点结构）
                const allTreeNodes = currentContainer.querySelectorAll('.tree-node');
                let foundCategory = false;
                
                console.log(`🔍 Searching in ${allTreeNodes.length} existing nodes for: "${part}"`);
                
                // 查找现有分类（统一处理所有类型的节点）
                for (const node of allTreeNodes) {
                    const titleElement = node.querySelector('.node-title');
                    if (titleElement && titleElement.textContent.trim() === part) {
                        console.log(`✅ Found existing category: "${part}"`);
                        // 展开这个节点
                        const expandBtn = node.querySelector('.node-expand');
                        const childrenContainer = node.querySelector('.node-children');
                        if (expandBtn && childrenContainer) {
                            expandBtn.innerHTML = '▼';
                            childrenContainer.classList.add('expanded');
                            currentContainer = childrenContainer;
                            foundCategory = true;
                            break;
                        }
                    }
                }
                
                // 如果分类不存在才创建新的
                if (!foundCategory) {
                    console.log(`🆕 Creating new tree-node: "${part}"`);
                    const newNode = createTreeNode(part, 'folder', false);
                    currentContainer.appendChild(newNode);
                    
                    // 更新当前容器到新节点的子容器
                    const childrenContainer = newNode.querySelector('.node-children');
                    if (childrenContainer) {
                        currentContainer = childrenContainer;
                    }
                }
            }
            
            // 🎯 只负责导航到文件位置，不创建文件（文件已在addFileWithAIGuidanceAndStorage中创建）
            console.log(`🎯 Navigating to document "${fileName}" location`);
            console.log(`📍 Current container:`, currentContainer);
            console.log(`📍 Container class:`, currentContainer?.className);
            console.log(`📍 Container children count:`, currentContainer?.children.length);
            
            if (currentContainer && fileName) {
                // 🔍 查找并高亮已存在的文件
                const existingFile = Array.from(currentContainer.querySelectorAll(':scope > .tree-node')).find(node => {
                    const titleElement = node.querySelector('.node-title');
                    return titleElement && titleElement.textContent.trim() === fileName;
                });
                
                if (existingFile) {
                    console.log(`✅ Found existing document "${fileName}", highlighting it`);
                    // 高亮已存在的文件
                    const existingNodeContent = existingFile.querySelector('.node-content');
                    if (existingNodeContent) {
                        existingNodeContent.style.backgroundColor = '#f0f9ff';
                        existingNodeContent.style.border = '2px solid #3b82f6';
                        
                        // 滚动到视图
                        setTimeout(() => {
                            existingNodeContent.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }, 300);
                        
                        // 3秒后移除高亮
                        setTimeout(() => {
                            existingNodeContent.style.backgroundColor = '';
                            existingNodeContent.style.border = '';
                        }, 3000);
                    }
                    console.log(`🎯 Document "${fileName}" highlighted successfully`);
                } else {
                    console.log(`⚠️ Document "${fileName}" not found in expected location`);
                }
            }
        }
        
        // 显示替代建议
        function showAlternatives(index) {
            console.log('🔄 Showing alternatives for index:', index);
            const alternativesDiv = document.getElementById(`alternatives-${index}`);
            
            if (alternativesDiv) {
                const isHidden = alternativesDiv.style.display === 'none' || alternativesDiv.style.display === '';
                alternativesDiv.style.display = isHidden ? 'block' : 'none';
                
                // 添加视觉反馈
                if (isHidden) {
                    alternativesDiv.style.animation = 'fadeIn 0.3s ease-in';
                    console.log('✅ 显示其他选项');
                } else {
                    console.log('✅ 隐藏其他选项');
                }
            } else {
                console.warn('⚠️ 未找到alternatives div，index:', index);
                
                // 调试：列出所有可用的alternatives divs
                const allAlternatives = document.querySelectorAll('[id^="alternatives-"]');
                console.log('🔍 可用的alternatives divs:', Array.from(allAlternatives).map(div => div.id));
                
                // 显示友好的错误提示
                showNotification('⚠️ 未找到其他选项，请重试', 'warning');
            }
        }
        
        // 重试分析
        async function retryAnalysis(fileName, index) {
            console.log(`🔄 重试分析: ${fileName}`);
            showNotification(`🔄 正在重试分析 "${fileName}"`);
            
            // 这里可以重新触发分析流程
        }
        
        // 清理上传区域
        function clearUploadArea() {
            console.log('🧹 Clearing upload area');
            
            // 清空文件容器
            const container = document.getElementById('uploadedFiles');
            if (container) {
                container.innerHTML = '';
            }
            
            // 清空URL内容区域
            const urlContent = document.getElementById('urlContent');
            if (urlContent) {
                urlContent.style.display = 'none';
                urlContent.innerHTML = '';
            }
            
            // 清空语音转录区域
            const voiceTranscript = document.getElementById('voiceTranscript');
            if (voiceTranscript) {
                voiceTranscript.style.display = 'none';
                voiceTranscript.innerHTML = '';
            }
            
            // 🔥 清空结果显示区域
            const resultsContainer = document.getElementById('results');
            if (resultsContainer) {
                resultsContainer.innerHTML = '';
                console.log('🧹 已清空结果显示区域');
            }
            
            // 重置文件输入
            const fileInputs = document.querySelectorAll('input[type="file"]');
            fileInputs.forEach(input => {
                input.value = '';
            });
            
            // 清空全局文件变量
            window.currentUploadedFiles = [];
            
            // 🔥 清空全局结果缓存
            window.lastAnalysisResult = null;
            window.lastProcessedContent = null;
            
            // 重置上传区域状态
            const uploadArea = document.querySelector('.upload-area');
            if (uploadArea) {
                uploadArea.style.borderColor = '#e2e8f0';
                uploadArea.style.backgroundColor = 'white';
            }
            
            // 🔄 智能输入区域无需切换模式，因为已经统一了
            console.log('🤖 Smart input area - no mode switching needed');
            
            console.log('✅ Upload area cleared');
        }
        
        // 生成唯一ID
        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }
        
        // 获取文件类型
        function getFileType(file) {
            const extension = file.name.split('.').pop()?.toLowerCase();
            const mimeType = file.type;
            
            if (mimeType.startsWith('text/')) return 'text';
            if (mimeType.startsWith('application/')) return 'application';
            if (mimeType.startsWith('image/')) return 'image';
            
            return extension || 'unknown';
        }
        
        // 显示文件内容
        function showFileContent(file) {
            console.log('👁️ Showing file content:', file.name);
            
            // 创建模态框显示文件内容
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.5); z-index: 9999;
                display: flex; align-items: center; justify-content: center;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white; padding: 24px; border-radius: 12px; 
                    max-width: 80%; max-height: 80%; overflow-y: auto;
                    box-shadow: 0 25px 80px rgba(0,0,0,0.3);
                ">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <h3 style="margin: 0; color: #1f2937;">📄 ${file.name}</h3>
                        <button onclick="this.closest('div').remove()" style="
                            background: #ef4444; color: white; border: none;
                            width: 32px; height: 32px; border-radius: 50%; cursor: pointer;
                        ">✕</button>
                    </div>
                    
                    <div style="
                        background: #f8fafc; border: 1px solid #e2e8f0; 
                        padding: 16px; border-radius: 8px; white-space: pre-wrap;
                        font-family: 'Courier New', monospace; font-size: 12px;
                        max-height: 400px; overflow-y: auto;
                    ">
                        ${file.content || '内容加载中...'}
                    </div>
                    
                    <div style="margin-top: 16px; font-size: 12px; color: #6b7280;">
                        路径: ${file.path} | 大小: ${formatFileSize(file.size)} | 上传: ${new Date(file.uploadDate).toLocaleString()}
                    </div>
                </div>
            `;
            
            // 点击背景关闭
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
            
            document.body.appendChild(modal);
        }
        
        // CSS 动画样式
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideInUp {
                from {
                    opacity: 0;
                    transform: translateY(30px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
            
            @keyframes spin {
                from { transform: rotate(0deg); }
                to { transform: rotate(360deg); }
            }
            
            .spinner {
                animation: spin 1s linear infinite;
            }
            
            @keyframes modalSlideIn {
                from { 
                    opacity: 0; 
                    transform: scale(0.9) translateY(-20px); 
                }
                to { 
                    opacity: 1; 
                    transform: scale(1) translateY(0); 
                }
            }
        `;
        document.head.appendChild(style);
        
        // Process uploaded files
        function processUploadedFilesLegacy(files) {
            // Legacy function for compatibility
            // Simulate AI content extraction and categorization
            setTimeout(() => {
                processFilesWithAI(files);
            }, 1000);
        }

        function getFileIcon(mimeType) {
            if (mimeType.includes('pdf')) return '📄';
            if (mimeType.includes('word') || mimeType.includes('document')) return '📝';
            if (mimeType.includes('excel') || mimeType.includes('spreadsheet')) return '📊';
            if (mimeType.includes('image')) return '🖼️';
            if (mimeType.includes('text')) return '📋';
            return '📎';
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1048576) return Math.round(bytes / 1024) + ' KB';
            return Math.round(bytes / 1048576 * 100) / 100 + ' MB';
        }

        window.removeFile = function(button) {
            button.parentElement.remove();
        }

        // Voice recording
        window.toggleVoiceRecording = function() {
            const btn = document.getElementById('voiceBtn');
            const status = document.getElementById('voiceStatus');
            const transcript = document.getElementById('voiceTranscript');
            
            if (!isRecording) {
                // Start recording
                startVoiceRecording();
                btn.innerHTML = '⏹️ Stop Recording';
                btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                status.textContent = '🔴';
                isRecording = true;
            } else {
                // Stop recording
                stopVoiceRecording();
                btn.innerHTML = '🎤 Start Recording';
                btn.style.background = 'linear-gradient(135deg, #ef4444, #dc2626)';
                status.textContent = '🎙️';
                isRecording = false;
            }
        }

        function startVoiceRecording() {
            if ('webkitSpeechRecognition' in window) {
                recognition = new webkitSpeechRecognition();
                recognition.continuous = true;
                recognition.interimResults = true;
                
                recognition.onresult = function(event) {
                    let transcript = '';
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        transcript += event.results[i][0].transcript;
                    }
                    document.getElementById('voiceTranscript').textContent = transcript;
                    document.getElementById('voiceTranscript').style.display = 'block';
                };
                
                recognition.start();
            } else {
                showNotification('⚠️ Voice recognition not supported in this browser');
            }
        }

        function stopVoiceRecording() {
            if (recognition) {
                recognition.stop();
                recognition = null;
            }
        }

        // URL content fetching
        window.fetchUrlContent = function() {
            const url = document.getElementById('urlInput').value;
            const content = document.getElementById('urlContent');
            
            if (!url) {
                showNotification('⚠️ Please enter a valid URL');
                return;
            }
            
            // Simulate URL content fetching
            content.style.display = 'block';
            content.innerHTML = '<div style="text-align: center; padding: 20px; color: #6b7280;">🔄 Fetching content...</div>';
            
            setTimeout(() => {
                content.innerHTML = `
                    <h3 style="margin: 0 0 12px 0; color: #1f2937;">📖 Content Preview</h3>
                    <p style="color: #4b5563; line-height: 1.6;">
                        This is a simulated preview of the fetched content from: <strong>${url}</strong>
                        <br><br>
                        In a real implementation, this would use a web scraping service or API to extract the actual content from the provided URL, including text, images, and metadata.
                    </p>
                    <div style="margin-top: 16px; padding: 12px; background: #f3f4f6; border-radius: 6px; font-size: 12px; color: #6b7280;">
                        <strong>Note:</strong> URL content fetching requires backend integration with services like Puppeteer, Scrapy, or commercial APIs like Mercury or Diffbot.
                    </div>
                `;
                showNotification('🔗 URL content fetched successfully!');
            }, 1500);
        }

        // AI Content Processing System (Simulation)
        function processFilesWithAI(files) {
            showNotification('🤖 AI is analyzing your files...');
            
            Array.from(files).forEach(async (file, index) => {
                setTimeout(async () => {
                    try {
                        const analysis = await simulateAIAnalysis(file);
                        showAIAnalysisResult(file, analysis);
                    } catch (error) {
                        console.error('Analysis failed for file:', file.name, error);
                        showAIAnalysisResult(file, {
                            category: { name: "❌ Analysis Failed", confidence: 0, reason: "Service unavailable" },
                            entities: [], relationships: [], keyInsights: ["Analysis service unavailable"]
                        });
                    }
                }, (index + 1) * 1500);
            });
        }

        async function simulateAIAnalysis(file) {
            // GraphRAG-powered multi-modal analysis
            console.log('🚀 Starting GraphRAG-powered analysis for:', file.name, file.type, file.size);
            
            try {
                // Use GraphRAG service for analysis
                const graphRAGResult = await graphRAGService.analyzeContent(file, {
                    includeGraph: true,
                    extractEntities: true,
                    identifyRelationships: true,
                    generateInsights: true
                });
                
                console.log('📊 GraphRAG analysis complete:', graphRAGResult);
                
                // Transform GraphRAG result to match expected format
                const transformedResult = {
                    category: {
                        name: graphRAGResult.bestMatch?.name || "📈 Analytics & Data",
                        confidence: graphRAGResult.confidence || 0.8,
                        reason: graphRAGResult.bestMatch?.reason || "Analyzed using GraphRAG multi-modal intelligence",
                        isNewCategory: graphRAGResult.isNewCategory || false
                    },
                    entities: graphRAGResult.entities || [],
                    relationships: graphRAGResult.relationships || [],
                    concepts: graphRAGResult.concepts || [],
                    keyInsights: graphRAGResult.keyInsights || [],
                    suggestedActions: graphRAGResult.suggestedActions || [
                        `Add to knowledge base under ${graphRAGResult.bestMatch?.name || "General"}`,
                        "Create cross-reference with related documents",
                        "Schedule for team review",
                        "Include in next insight analysis"
                    ],
                    reasoning: graphRAGResult.reasoning || [],
                    graphData: graphRAGResult.graphData || null,
                    isSimulated: graphRAGResult.isSimulated || false,
                    serviceStatus: graphRAGResult.serviceStatus || 'connected'
                };
                
                // Add GraphRAG-specific enhancements
                if (graphRAGResult.summary) {
                    transformedResult.summary = graphRAGResult.summary;
                }
                
                return transformedResult;
                
            } catch (error) {
                console.error('❌ GraphRAG analysis failed, using fallback:', error);
                // Fallback to enhanced analysis
                const fallbackResult = await performEnhancedAnalysis(file, 
                    graphRAGService.getExistingCategories(), 
                    graphRAGService.getPotentialNewCategories()
                );
                
                return {
                    category: {
                        name: fallbackResult.bestMatch?.name || "📈 Analytics & Data",
                        confidence: fallbackResult.confidence || 0.7,
                        reason: fallbackResult.bestMatch?.reason || "Fallback analysis due to service unavailability",
                        isNewCategory: fallbackResult.isNewCategory || false
                    },
                    entities: [
                        { name: "Content Marketing Strategy", type: "concept", confidence: 0.8 },
                        { name: "Digital Transformation", type: "theme", confidence: 0.7 }
                    ],
                    relationships: [
                        { source: "Content Marketing", target: "Digital Strategy", type: "supports", strength: 0.8 }
                    ],
                    keyInsights: [
                        "Document contains strategic planning elements",
                        "GraphRAG service temporarily unavailable - using enhanced fallback",
                        "Integration opportunities with existing content workflows"
                    ],
                    suggestedActions: [
                        `Add to knowledge base under ${fallbackResult.bestMatch?.name || "General"}`,
                        "Create cross-reference with related documents", 
                        "Retry GraphRAG analysis when service is available"
                    ],
                    reasoning: fallbackResult.factors || [],
                    isSimulated: true,
                    serviceStatus: 'fallback'
                };
            }
        }
        
        // Keep the original function structure but update the content
        function originalSimulateAIAnalysis(file) {
            
            const existingCategories = [
                { 
                    name: "📊 Market Research", 
                    confidence: 0.85, 
                    reason: "Contains market data and consumer insights",
                    keywords: ["market", "research", "survey", "consumer", "audience", "demographic", "trend", "analysis"],
                    fileTypes: ["xlsx", "csv", "pdf", "docx"],
                    minConfidence: 0.7
                },
                { 
                    name: "✍️ Content Strategy", 
                    confidence: 0.78, 
                    reason: "Includes content planning and editorial guidelines",
                    keywords: ["content", "blog", "editorial", "writing", "article", "copy", "seo", "publishing"],
                    fileTypes: ["docx", "txt", "md", "pdf"],
                    minConfidence: 0.6
                },
                { 
                    name: "📱 Social Media", 
                    confidence: 0.92, 
                    reason: "Social media metrics and campaign data detected",
                    keywords: ["social", "instagram", "tiktok", "facebook", "twitter", "linkedin", "engagement", "follower"],
                    fileTypes: ["png", "jpg", "jpeg", "pdf", "xlsx"],
                    minConfidence: 0.8
                },
                { 
                    name: "📈 Analytics & Data", 
                    confidence: 0.89, 
                    reason: "Performance metrics and statistical analysis",
                    keywords: ["analytics", "data", "kpi", "metrics", "performance", "dashboard", "report", "statistics"],
                    fileTypes: ["xlsx", "csv", "json", "pdf"],
                    minConfidence: 0.75
                },
                { 
                    name: "🎯 Campaign Planning", 
                    confidence: 0.74, 
                    reason: "Campaign objectives and target audience info",
                    keywords: ["campaign", "strategy", "plan", "launch", "marketing", "promotion", "advertising"],
                    fileTypes: ["pptx", "pdf", "docx"],
                    minConfidence: 0.65
                }
            ];
            
            // Potential new categories that AI might discover
            const potentialNewCategories = [
                { name: "🎨 Brand Design", confidence: 0.88, reason: "Visual branding and design assets detected" },
                { name: "📧 Email Marketing", confidence: 0.82, reason: "Email campaign templates and automation workflows" },
                { name: "🎥 Video Content", confidence: 0.90, reason: "Video production scripts and multimedia content" },
                { name: "📞 Customer Support", confidence: 0.75, reason: "Support documentation and customer service materials" },
                { name: "💰 Sales Materials", confidence: 0.83, reason: "Sales presentations and lead generation content" },
                { name: "🔍 SEO & Keywords", confidence: 0.87, reason: "Search engine optimization and keyword research" },
                { name: "📱 Mobile App", confidence: 0.79, reason: "Mobile application development and UX content" },
                { name: "🛒 E-commerce", confidence: 0.85, reason: "Product descriptions and online store content" },
                { name: "📊 Business Intelligence", confidence: 0.91, reason: "Business reporting and data visualization" },
                { name: "🎓 Training & Education", confidence: 0.73, reason: "Educational materials and training content" }
            ];
            
            // Create a consistent hash from filename for deterministic results
            const filename = file.name.toLowerCase();
            let hash = 0;
            for (let i = 0; i < filename.length; i++) {
                const char = filename.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            
            // Enhanced multi-factor analysis
            const analysisResults = performEnhancedAnalysis(file, existingCategories, potentialNewCategories);
            
            console.log('🔍 Analysis results:', analysisResults);
            
            let selectedCategory = analysisResults.bestMatch;
            selectedCategory.isNewCategory = analysisResults.isNewCategory;
            
            // Update reason with detailed analysis
            selectedCategory.reason = `${selectedCategory.reason} (Score: ${Math.round(analysisResults.confidence * 100)}%, based on ${analysisResults.factors.join(', ')})`;
            selectedCategory.confidence = analysisResults.confidence;
            
            return {
                category: selectedCategory,
                entities: [
                    "Australia Market", "Tech Industry", "B2B Strategy", 
                    "Content Marketing", "Social Media ROI"
                ],
                keywords: [
                    "market penetration", "audience engagement", "conversion rate",
                    "brand awareness", "competitive analysis"
                ],
                suggestedActions: [
                    "Add to knowledge base under " + selectedCategory.name,
                    "Create cross-reference with related documents",
                    "Schedule for team review",
                    "Include in next insight analysis"
                ]
            };
        }
        
        function performEnhancedAnalysis(file, existingCategories, potentialNewCategories) {
            const filename = file.name.toLowerCase();
            const fileExtension = filename.split('.').pop() || '';
            const fileSize = file.size;
            const allCategories = [...existingCategories, ...potentialNewCategories.map(cat => ({...cat, isNewCategory: true}))];
            
            console.log('📊 Analyzing file:', {filename, fileExtension, fileSize});
            
            let bestMatch = null;
            let bestScore = 0;
            let analysisFactors = [];
            
            // Score each category
            allCategories.forEach(category => {
                let score = 0;
                let factors = [];
                
                // 1. Keyword matching (40% weight)
                if (category.keywords) {
                    const keywordMatches = category.keywords.filter(keyword => 
                        filename.includes(keyword)
                    ).length;
                    const keywordScore = (keywordMatches / category.keywords.length) * 0.4;
                    score += keywordScore;
                    if (keywordMatches > 0) {
                        factors.push(`${keywordMatches} keyword matches`);
                    }
                }
                
                // 2. File type compatibility (30% weight)
                if (category.fileTypes && category.fileTypes.includes(fileExtension)) {
                    score += 0.3;
                    factors.push('compatible file type');
                }
                
                // 3. File size heuristics (15% weight)
                const sizeScore = getFileSizeScore(fileSize, category);
                score += sizeScore * 0.15;
                if (sizeScore > 0.5) {
                    factors.push('appropriate file size');
                }
                
                // 4. Pattern recognition (15% weight)
                const patternScore = getPatternScore(filename, category);
                score += patternScore * 0.15;
                if (patternScore > 0.5) {
                    factors.push('filename patterns');
                }
                
                // Apply minimum confidence threshold
                if (category.minConfidence && score < category.minConfidence) {
                    score *= 0.5; // Penalize low confidence matches
                }
                
                console.log(`📋 Category: ${category.name}, Score: ${score.toFixed(3)}, Factors: ${factors.join(', ')}`);
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMatch = {...category};
                    analysisFactors = factors;
                }
            });
            
            // If no good match found, use intelligent fallback
            if (bestScore < 0.3) {
                console.log('⚠️ Low confidence match, using intelligent fallback');
                bestMatch = getIntelligentFallback(file, existingCategories);
                analysisFactors = ['intelligent fallback based on file characteristics'];
                bestScore = 0.5;
            }
            
            return {
                bestMatch: bestMatch,
                confidence: Math.min(bestScore, 0.95), // Cap at 95%
                isNewCategory: bestMatch.isNewCategory || false,
                factors: analysisFactors
            };
        }
        
        function getFileSizeScore(fileSize, category) {
            // Different categories have different typical file sizes
            const sizeRanges = {
                "📊 Market Research": {min: 50000, max: 10000000}, // 50KB - 10MB
                "✍️ Content Strategy": {min: 5000, max: 500000},   // 5KB - 500KB
                "📱 Social Media": {min: 100000, max: 50000000},   // 100KB - 50MB
                "📈 Analytics & Data": {min: 10000, max: 100000000}, // 10KB - 100MB
                "🎯 Campaign Planning": {min: 100000, max: 20000000}  // 100KB - 20MB
            };
            
            const range = sizeRanges[category.name];
            if (!range) return 0.5; // Neutral score for unknown categories
            
            if (fileSize >= range.min && fileSize <= range.max) {
                return 1.0; // Perfect size match
            } else if (fileSize < range.min) {
                return Math.max(0.2, fileSize / range.min);
            } else {
                return Math.max(0.2, range.max / fileSize);
            }
        }
        
        function getPatternScore(filename, category) {
            // Advanced pattern recognition based on common naming conventions
            const patterns = {
                "📊 Market Research": [/research/i, /survey/i, /analysis/i, /report/i, /study/i],
                "✍️ Content Strategy": [/content/i, /blog/i, /article/i, /copy/i, /editorial/i],
                "📱 Social Media": [/social/i, /post/i, /campaign/i, /engagement/i],
                "📈 Analytics & Data": [/data/i, /analytics/i, /metrics/i, /dashboard/i, /kpi/i],
                "🎯 Campaign Planning": [/campaign/i, /strategy/i, /plan/i, /marketing/i, /launch/i]
            };
            
            const categoryPatterns = patterns[category.name] || [];
            const matches = categoryPatterns.filter(pattern => pattern.test(filename)).length;
            
            return matches > 0 ? Math.min(1.0, matches / categoryPatterns.length * 2) : 0;
        }
        
        function getIntelligentFallback(file, existingCategories) {
            const filename = file.name.toLowerCase();
            const fileExtension = filename.split('.').pop() || '';
            
            // Smart fallback based on file extension and basic patterns
            if (['xlsx', 'csv', 'json'].includes(fileExtension)) {
                return existingCategories.find(cat => cat.name === "📈 Analytics & Data") || existingCategories[0];
            } else if (['docx', 'txt', 'md'].includes(fileExtension)) {
                return existingCategories.find(cat => cat.name === "✍️ Content Strategy") || existingCategories[0];
            } else if (['pptx', 'ppt'].includes(fileExtension)) {
                return existingCategories.find(cat => cat.name === "🎯 Campaign Planning") || existingCategories[0];
            } else if (['png', 'jpg', 'jpeg', 'gif'].includes(fileExtension)) {
                return existingCategories.find(cat => cat.name === "📱 Social Media") || existingCategories[0];
            } else {
                // Default to first category
                return existingCategories[0];
            }
        }

        function showAIAnalysisResult(file, analysis) {
            // Create AI analysis modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.5); z-index: 9999;
                display: flex; align-items: center; justify-content: center;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white; padding: 32px; border-radius: 16px; max-width: 600px;
                    width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 25px 80px rgba(0,0,0,0.3);
                ">
                    <div style="display: flex; align-items: center; margin-bottom: 24px;">
                        <span style="font-size: 32px; margin-right: 12px;">🤖</span>
                        <h2 style="margin: 0; color: #1f2937;">AI Analysis Complete</h2>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <h3 style="color: #374151; font-size: 16px; margin: 0 0 8px 0;">📄 File: ${file.name}</h3>
                    </div>
                    
                    <!-- GraphRAG Analysis Results -->
                    <div style="background: ${analysis.category.isNewCategory ? '#fef3c7' : '#f0f9ff'}; border-left: 4px solid ${analysis.category.isNewCategory ? '#f59e0b' : '#0ea5e9'}; padding: 16px; margin-bottom: 20px; border-radius: 0 8px 8px 0; position: relative;">
                        <h4 style="margin: 0 0 8px 0; color: ${analysis.category.isNewCategory ? '#92400e' : '#0c4a6e'};">
                            ${analysis.isSimulated ? '🔬 Enhanced AI Analysis' : '🧠 GraphRAG Intelligence'} 
                            ${analysis.category.isNewCategory ? '🆕 New Category' : '🎯 Classification'}
                        </h4>
                        <div style="font-weight: 600; color: ${analysis.category.isNewCategory ? '#d97706' : '#1e40af'}; font-size: 18px;">${analysis.category.name}</div>
                        <div style="font-size: 14px; color: ${analysis.category.isNewCategory ? '#a16207' : '#0369a1'}; margin-top: 4px;">
                            Confidence: ${Math.round(analysis.category.confidence * 100)}% - ${analysis.category.reason}
                        </div>
                        
                        <!-- Service Status Indicator -->
                        <div style="position: absolute; top: 16px; right: 16px; display: flex; align-items: center; font-size: 12px;">
                            <div style="width: 8px; height: 8px; border-radius: 50%; margin-right: 6px; background: ${
                                analysis.serviceStatus === 'connected' ? '#10b981' : 
                                analysis.serviceStatus === 'multi-agent-fallback' ? '#8b5cf6' : 
                                analysis.serviceStatus === 'fallback' ? '#f59e0b' : '#ef4444'
                            };"></div>
                            ${
                                analysis.serviceStatus === 'connected' ? 'GraphRAG' : 
                                analysis.serviceStatus === 'multi-agent-fallback' ? 'Multi-Agent' : 
                                analysis.serviceStatus === 'fallback' ? 'Enhanced' : 'Offline'
                            }
                            ${analysis.isMultiAgent ? ' 🤖🔄🔬' : ''}
                        </div>
                        
                        ${analysis.category.isNewCategory ? `
                            <div style="background: rgba(251, 191, 36, 0.1); border-radius: 6px; padding: 12px; margin-top: 12px; border: 1px solid #fbbf24;">
                                <strong style="color: #92400e;">📋 New Category Action:</strong>
                                <div style="color: #a16207; font-size: 13px; margin-top: 4px;">
                                    This content doesn't fit existing categories. AI will create a new "${analysis.category.name}" section in your knowledge base.
                                </div>
                            </div>
                        ` : ''}
                    </div>
                    
                    ${analysis.isMultiAgent && analysis.multiAgentAnalysis ? `
                    <!-- Multi-Agent Analysis Section -->
                    <div style="background: linear-gradient(135deg, #8b5cf6, #7c3aed); color: white; padding: 20px; margin-bottom: 20px; border-radius: 12px; box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);">
                        <h4 style="margin: 0 0 16px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                            🤖 Multi-Agent Analysis Pipeline
                            <div style="background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 6px; font-size: 12px; margin-left: 12px;">
                                ${analysis.multiAgentAnalysis.fusedInsights?.activeAgents?.length || 0}/3 Active
                            </div>
                        </h4>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-bottom: 16px;">
                            ${['GraphAgent', 'HybridAgent', 'DeepResearchAgent'].map(agentName => {
                                const agent = analysis.multiAgentAnalysis[agentName.toLowerCase()] || analysis.multiAgentAnalysis[agentName.toLowerCase().replace('agent', 'Agent')];
                                const isActive = analysis.multiAgentAnalysis.fusedInsights?.activeAgents?.includes(agentName);
                                const icons = { GraphAgent: '🕸️', HybridAgent: '🔄', DeepResearchAgent: '🔍' };
                                
                                return `
                                    <div style="background: rgba(255,255,255,0.15); padding: 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2);">
                                        <div style="display: flex; align-items: center; margin-bottom: 6px;">
                                            <span style="font-size: 16px; margin-right: 6px;">${icons[agentName]}</span>
                                            <span style="font-size: 12px; font-weight: 500;">${agentName.replace('Agent', '')}</span>
                                            <div style="margin-left: auto;">
                                                ${isActive ? 
                                                    '<div style="width: 6px; height: 6px; background: #10b981; border-radius: 50%;"></div>' : 
                                                    '<div style="width: 6px; height: 6px; background: #ef4444; border-radius: 50%;"></div>'
                                                }
                                            </div>
                                        </div>
                                        <div style="font-size: 10px; opacity: 0.8; line-height: 1.3;">
                                            ${isActive ? 
                                                (agent?.confidence ? `Confidence: ${Math.round(agent.confidence * 100)}%` : 'Active') : 
                                                'Inactive'
                                            }
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        
                        ${analysis.multiAgentAnalysis.fusedInsights?.fusedInsights?.length > 0 ? `
                        <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2);">
                            <h5 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 600;">🔮 Fused Insights</h5>
                            <ul style="margin: 0; padding-left: 16px; font-size: 12px; line-height: 1.4;">
                                ${analysis.multiAgentAnalysis.fusedInsights.fusedInsights.map(insight => `
                                    <li style="margin-bottom: 4px; opacity: 0.9;">${insight}</li>
                                `).join('')}
                            </ul>
                        </div>
                        ` : ''}
                        
                        ${analysis.multiAgentAnalysis.fusedInsights?.agentConsensus ? `
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.2);">
                            <div style="font-size: 12px; opacity: 0.8;">
                                Consensus: ${analysis.multiAgentAnalysis.fusedInsights.agentConsensus.agreementLevel}
                            </div>
                            <div style="font-size: 12px; opacity: 0.8;">
                                Topics: ${analysis.multiAgentAnalysis.fusedInsights.agentConsensus.commonTopics?.length || 0}
                            </div>
                        </div>
                        ` : ''}
                    </div>
                    ` : ''}
                    
                    ${analysis.hasGraphReasoning && analysis.graphReasoning ? `
                    <!-- Graph-Based Reasoning Section -->
                    <div style="background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 20px; margin-bottom: 20px; border-radius: 12px; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);">
                        <h4 style="margin: 0 0 16px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                            🧠 Graph-Based Reasoning
                            <div style="background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 6px; font-size: 12px; margin-left: 12px;">
                                Score: ${Math.round((analysis.graphReasoning.reasoningScore || 0) * 100)}%
                            </div>
                        </h4>
                        
                        ${analysis.graphReasoning.centralConcepts?.length > 0 ? `
                        <div style="background: rgba(255,255,255,0.15); padding: 12px; border-radius: 8px; margin-bottom: 12px; border: 1px solid rgba(255,255,255,0.2);">
                            <h5 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 600;">🎯 Central Concepts</h5>
                            <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                ${analysis.graphReasoning.centralConcepts.slice(0, 3).map(concept => `
                                    <div style="background: rgba(255,255,255,0.2); padding: 6px 10px; border-radius: 6px; font-size: 12px;">
                                        ${concept.label} (${concept.connectivity} connections)
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        ` : ''}
                        
                        ${analysis.enhancedInsights?.length > 0 ? `
                        <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2);">
                            <h5 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 600;">💡 Graph-Enhanced Insights</h5>
                            <ul style="margin: 0; padding-left: 16px; font-size: 12px; line-height: 1.4;">
                                ${analysis.enhancedInsights.slice(0, 3).map(insight => `
                                    <li style="margin-bottom: 4px; opacity: 0.9;">
                                        ${insight.content} 
                                        <span style="opacity: 0.7; font-size: 10px;">(${Math.round((insight.confidence || 0) * 100)}%)</span>
                                    </li>
                                `).join('')}
                            </ul>
                        </div>
                        ` : ''}
                        
                        ${analysis.reasoningPaths?.length > 0 ? `
                        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.2);">
                            <h5 style="margin: 0 0 8px 0; font-size: 12px; font-weight: 600; opacity: 0.9;">🔍 Reasoning Path Preview</h5>
                            <div style="font-size: 11px; opacity: 0.8; line-height: 1.3;">
                                ${analysis.reasoningPaths[0].steps.slice(0, 2).join(' → ')}...
                            </div>
                        </div>
                        ` : ''}
                    </div>
                    ` : ''}
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 20px;">
                        <div>
                            <h4 style="margin: 0 0 8px 0; color: #374151; font-size: 14px;">🔍 Key Entities</h4>
                            <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                ${analysis.entities.map(entity => `
                                    <span style="background: #ddd6fe; color: #5b21b6; padding: 4px 8px; border-radius: 12px; font-size: 12px;">
                                        ${entity}
                                    </span>
                                `).join('')}
                            </div>
                        </div>
                        <div>
                            <h4 style="margin: 0 0 8px 0; color: #374151; font-size: 14px;">🏷️ Keywords</h4>
                            <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                ${analysis.keywords.map(keyword => `
                                    <span style="background: #fed7d7; color: #c53030; padding: 4px 8px; border-radius: 12px; font-size: 12px;">
                                        ${keyword}
                                    </span>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 24px;">
                        <h4 style="margin: 0 0 8px 0; color: #374151; font-size: 14px;">💡 Suggested Actions</h4>
                        <ul style="margin: 0; padding-left: 20px; color: #4b5563;">
                            ${analysis.suggestedActions.map(action => `<li style="margin-bottom: 4px;">${action}</li>`).join('')}
                        </ul>
                    </div>
                    
                    <div style="display: flex; gap: 12px; justify-content: flex-end;">
                        <button onclick="this.closest('.modal').remove()" style="
                            background: #e5e7eb; color: #374151; border: none; padding: 10px 20px;
                            border-radius: 8px; cursor: pointer; font-weight: 500;
                        ">Cancel</button>
                        <button onclick="acceptAISuggestion('${file.name}', '${analysis.category.name}'); this.closest('.modal').remove()" style="
                            background: #667eea; color: white; border: none; padding: 10px 20px;
                            border-radius: 8px; cursor: pointer; font-weight: 600;
                        ">✅ Accept & Add to Knowledge Base</button>
                    </div>
                    
                    <!-- Knowledge Graph Visualization Section -->
                    ${analysis.graphData && (analysis.graphData.nodes?.length > 0 || analysis.graphData.edges?.length > 0) ? `
                        <div style="margin: 24px 0; border-top: 1px solid #e5e7eb; padding-top: 20px;">
                            <h4 style="margin: 0 0 12px 0; color: #374151; font-size: 15px; font-weight: 600;">🕸️ Knowledge Graph Visualization</h4>
                            <div id="graph-${Date.now()}" style="background: linear-gradient(135deg, #f9fafb, #f3f4f6); border: 2px solid #e5e7eb; border-radius: 8px; height: 280px; position: relative; overflow: hidden; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);">
                                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #6b7280;">
                                    <div style="font-size: 48px; margin-bottom: 12px; opacity: 0.6;">🕸️</div>
                                    <div style="font-size: 16px; font-weight: 600; color: #374151; margin-bottom: 6px;">Interactive Knowledge Graph</div>
                                    <div style="font-size: 13px; margin: 6px 0; color: #6b7280;">
                                        <span style="background: #ddd6fe; color: #7c3aed; padding: 2px 8px; border-radius: 12px; margin: 0 4px;">
                                            ${analysis.graphData.nodes?.length || 0} entities
                                        </span>
                                        <span style="background: #fecaca; color: #dc2626; padding: 2px 8px; border-radius: 12px; margin: 0 4px;">
                                            ${analysis.graphData.edges?.length || 0} relationships
                                        </span>
                                    </div>
                                    <button onclick="visualizeGraph('${Date.now()}', ${JSON.stringify(analysis.graphData).replace(/"/g, '&quot;')})" 
                                            style="margin-top: 12px; padding: 8px 20px; background: linear-gradient(135deg, #8b5cf6, #7c3aed); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; box-shadow: 0 2px 4px rgba(139, 92, 246, 0.2); transition: all 0.2s;">
                                        🎯 Visualize Knowledge Graph
                                    </button>
                                </div>
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
            
            modal.classList.add('modal');
            document.body.appendChild(modal);
        }

        window.acceptAISuggestion = function(filename, category) {
            console.log('🔄 Processing AI suggestion for:', filename, category);
            
            // Check if this is a new category that needs to be created
            const newCategories = [
                "🎨 Brand Design", "📧 Email Marketing", "🎥 Video Content", "📞 Customer Support",
                "💰 Sales Materials", "🔍 SEO & Keywords", "📱 Mobile App", "🛒 E-commerce",
                "📊 Business Intelligence", "🎓 Training & Education"
            ];
            
            const isNewCategory = newCategories.includes(category);
            
            if (isNewCategory) {
                console.log('🆕 Creating new category:', category);
                const success = createNewCategoryAndAddFile(filename, category);
                if (success) {
                    showNotification(`🎉 Created new category "${category}" and added "${filename}"!\n📍 位置: ${category} > ${filename}`);
                    console.log(`✅ New category created and file added: ${category} > ${filename}`);
                } else {
                    showNotification(`❌ 创建新类别时出错`);
                }
            } else {
                // Existing category logic
                const categoryMapping = {
                    "📊 Market Research": "Marketing Strategy",
                    "✍️ Content Strategy": "Content Creation", 
                    "📱 Social Media": "Marketing Strategy",
                    "📈 Analytics & Data": "Content Creation",
                    "🎯 Campaign Planning": "Marketing Strategy"
                };
                
                const targetFolder = categoryMapping[category] || "Marketing Strategy";
                const success = addFileToKnowledgeTree(filename, category, targetFolder);
                
                if (success) {
                    showNotification(`🎉 文件 "${filename}" 已成功添加到知识库！\n📍 位置: ${targetFolder} > ${getSubfolderName(category)} > ${filename}`);
                    console.log(`✅ File ${filename} added to knowledge tree: ${targetFolder} > ${getSubfolderName(category)} > ${filename}`);
                } else {
                    showNotification(`❌ 添加文件 "${filename}" 到知识库时出错`);
                }
            }
        }
        
        function getSubfolderName(category) {
            const subfolders = {
                "📊 Market Research": "市场研究文档",
                "✍️ Content Strategy": "内容策略文档", 
                "📱 Social Media": "社交媒体文档",
                "📈 Analytics & Data": "数据分析文档",
                "🎯 Campaign Planning": "营销活动文档"
            };
            return subfolders[category] || "其他文档";
        }
        
        // 删除了重复的错误版本的addFileToKnowledgeTree函数，使用7165行的正确版本
        
        function createNewCategoryAndAddFile(filename, categoryName) {
            try {
                console.log('🏗️ Creating new main category:', categoryName);
                
                // Find the knowledge tree container
                const knowledgeTree = document.getElementById('knowledgeTree');
                if (!knowledgeTree) {
                    console.error('❌ Knowledge tree not found');
                    return false;
                }
                
                // Create the new main category folder
                const newMainCategory = document.createElement('div');
                newMainCategory.className = 'tree-node';
                newMainCategory.innerHTML = `
                    <div class="node-content" onclick="selectNode(this, event)" draggable="true" 
                         ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                         ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                        <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                        <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                        <div class="node-icon folder">📁</div>
                        <div class="node-title" ondblclick="editNodeTitle(event, this)">${categoryName}</div>
                        <div class="node-actions">
                            <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                            <button class="node-action" onclick="editNode(event, this)">✏️</button>
                            <button class="node-action" onclick="deleteNode(event, this)">🗑️</button>
                        </div>
                    </div>
                    <div class="node-children expanded">
                        <div class="tree-node">
                            <div class="node-content" onclick="openFileWithLocalTool(event, this)" draggable="true" 
                                 ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                                 ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                                <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                                <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                                <div class="node-icon file">📄</div>
                                <div class="node-title" ondblclick="editNodeTitle(event, this)">${filename}</div>
                                <div class="node-actions">
                                    <button class="action-btn" title="Edit" onclick="editNodeContent(event, this)">✏️</button>
                                    <button class="action-btn" title="Delete" onclick="deleteNode(event, this)">🗑️</button>
                                </div>
                            </div>
                            <div class="node-children"></div>
                        </div>
                    </div>
                `;
                
                // Add the new category to the knowledge tree
                knowledgeTree.appendChild(newMainCategory);
                
                // Expand the new folder to show the file
                const expandBtn = newMainCategory.querySelector('.node-expand');
                if (expandBtn) {
                    expandBtn.textContent = '▼';
                }
                
                // Initialize event handlers for the new elements
                updateEventHandlers(newMainCategory);
                
                console.log(`✅ New category "${categoryName}" created with file "${filename}"`);
                return true;
                
            } catch (error) {
                console.error('❌ Error creating new category:', error);
                return false;
            }
        }
        
        function getOrCreateSubfolder(parentNode, subfolderName) {
            // Check if subfolder already exists
            const existingChildren = parentNode.querySelector('.node-children');
            if (existingChildren) {
                const childNodes = existingChildren.querySelectorAll('.tree-node');
                for (let child of childNodes) {
                    const titleElement = child.querySelector('.node-title');
                    if (titleElement && titleElement.textContent.trim() === subfolderName) {
                        return child; // Found existing subfolder
                    }
                }
            }
            
            // Create new subfolder
            const subfolderNode = document.createElement('div');
            subfolderNode.className = 'tree-node';
            subfolderNode.innerHTML = `
                <div class="node-content" onclick="selectNode(this, event)" draggable="true" 
                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                    <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                    <div class="node-icon folder">📁</div>
                    <div class="node-title" ondblclick="editNodeTitle(event, this)">${subfolderName}</div>
                    <div class="node-actions">
                        <button class="action-btn" title="Add Content" onclick="addNodeContent(event, this)">📝</button>
                        <button class="action-btn" title="Delete" onclick="deleteNode(event, this)">🗑️</button>
                    </div>
                </div>
                <div class="node-children"></div>
            `;
            
            // Add to parent's children
            let parentChildren = parentNode.querySelector('.node-children');
            if (!parentChildren) {
                parentChildren = document.createElement('div');
                parentChildren.className = 'node-children';
                parentNode.appendChild(parentChildren);
            }
            parentChildren.appendChild(subfolderNode);
            
            return subfolderNode;
        }
        
        function createFileNode(filename, category) {
            const fileNode = document.createElement('div');
            fileNode.className = 'tree-node';
            fileNode.innerHTML = `
                <div class="node-content" onclick="openFileWithLocalTool(event, this)" draggable="true" 
                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                    <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                    <div class="node-icon file">📄</div>
                    <div class="node-title" ondblclick="editNodeTitle(event, this)">${filename}</div>
                    <div class="node-actions">
                        <button class="action-btn" title="Edit" onclick="editNodeContent(event, this)">✏️</button>
                        <button class="action-btn" title="Delete" onclick="deleteNode(event, this)">🗑️</button>
                    </div>
                </div>
                <div class="node-children"></div>
            `;
            
            return fileNode;
        }
        
        function expandFoldersToShow(folderNode) {
            const expandBtn = folderNode.querySelector('.node-expand');
            const children = folderNode.querySelector('.node-children');
            
            if (expandBtn && children) {
                expandBtn.textContent = '▼';
                children.classList.add('expanded');
                children.style.display = 'block';
            }
        }

    </script>

    <!-- Knowledge Base Panel (integrated) -->
    <div id="knowledgePanel" class="knowledge-panel">
        <div class="panel-header">
            <div class="panel-title">📚 Knowledge Base</div>
            <button class="close-btn" onclick="closeKnowledgePanel()">×</button>
        </div>

        <div class="panel-content" style="display: flex; gap: 20px;">

            <!-- 主要区域：知识树 -->
            <div class="tree-section" style="flex: 2; min-width: 500px;">
                <div class="tree-header">
                    <div style="font-weight: 600; font-size: 16px;">📚 Knowledge Tree</div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <button class="filter-btn" onclick="addNewFolder()">📁 Add Folder</button>
                    </div>
                </div>

                <div class="search-box">
                    <input type="text" class="search-input" placeholder="Search knowledge..." onkeyup="searchKnowledge(this.value)">
                    <button class="filter-btn">🔍</button>
                </div>

                <!-- Selected Documents Floating Panel -->
                <div id="selectedDocsPanel" style="
                    position: fixed; right: -350px; top: 50%; transform: translateY(-50%);
                    width: 320px; max-height: 70vh; overflow-y: auto;
                    background: white; border: 2px solid #e2e8f0; border-radius: 16px;
                    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
                    transition: right 0.4s ease; z-index: 1000; cursor: move;
                " draggable="false">
                    <!-- Expand/Collapse Button -->
                    <div style="
                        position: absolute; left: -40px; top: 20px;
                        width: 40px; height: 60px; background: white;
                        border: 2px solid #e2e8f0; border-right: none; border-radius: 8px 0 0 8px;
                        display: flex; align-items: center; justify-content: center;
                        cursor: pointer; transition: all 0.3s ease;
                    " onclick="toggleSelectedDocsPanel()" id="selectedDocsPanelToggle">
                        <span style="font-size: 18px; color: #6b7280;">📋</span>
                    </div>
                    
                    <div style="padding: 20px;">
                        <!-- Draggable Header -->
                        <div id="selectedDocsPanelHeader" style="
                            margin: -20px -20px 16px -20px; padding: 16px 20px;
                            background: linear-gradient(135deg, #667eea, #764ba2);
                            border-radius: 16px 16px 0 0; cursor: move;
                            user-select: none; position: relative;
                        ">
                            <button onclick="toggleSelectedDocsPanel()" style="
                                position: absolute; top: 12px; right: 16px; 
                                background: rgba(255,255,255,0.2); border: none; width: 28px; height: 28px; 
                                border-radius: 50%; cursor: pointer; color: white; font-size: 16px;
                                display: flex; align-items: center; justify-content: center;
                                transition: all 0.2s ease;
                            " onmouseover="this.style.background='rgba(255,255,255,0.3)'" 
                               onmouseout="this.style.background='rgba(255,255,255,0.2)'">✕</button>
                            <h4 style="
                                margin: 0; color: white; font-size: 16px; 
                                font-weight: 700; display: flex; align-items: center; gap: 8px;
                            ">
                                🎯 Selected for Analysis
                                <span id="selectionCount" style="
                                    background: rgba(255,255,255,0.2); color: white; padding: 2px 8px; 
                                    border-radius: 12px; font-size: 12px; font-weight: 600;
                                ">0</span>
                            </h4>
                        </div>
                        <div id="selectedDocsCards" style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 20px; max-height: 300px; overflow-y: auto;">
                            <!-- Selected document cards will appear here -->
                        </div>
                        <div style="text-align: center; padding: 12px; color: #6b7280; font-size: 14px;" id="emptySelectionMsg">
                            Select documents from the knowledge tree to start analysis
                        </div>
                    </div>
                </div>

                <div class="knowledge-tree" id="knowledgeTree">
                    <!-- Marketing Strategy Folder -->
                    <div class="tree-node">
                        <div class="node-content" onclick="selectNode(this, event)" draggable="true" 
                             ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                             ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                            <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                            <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                            <div class="node-icon folder">📁</div>
                            <div class="node-title" ondblclick="editNodeTitle(event, this)">Marketing Strategy</div>
                            <div class="node-actions">
                                <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                                <button class="node-action" onclick="editNode(event, this)">✏️</button>
                            </div>
                        </div>
                        <div class="node-children">
                            <div class="tree-node">
                                <div class="node-content" onclick="showNodeContent(event, this)" draggable="true" 
                                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                                    <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                                    <div class="node-icon file">📄</div>
                                    <div class="node-title" ondblclick="editNodeTitle(event, this)">澳洲市场用户画像分析</div>
                                    <div class="node-actions">
                                        <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                                        <button class="node-action" onclick="editNode(event, this)">✏️</button>
                                                <button class="node-action" onclick="deleteNode(event, this)">🗑️</button>
                                    </div>
                                </div>
                                <div class="node-tags">
                                    <span class="tag">用户调研</span>
                                    <span class="tag">澳洲市场</span>
                                </div>
                                <div class="node-children"></div>
                            </div>
                            <div class="tree-node">
                                <div class="node-content" onclick="showNodeContent(event, this)" draggable="true" 
                                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                                    <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                                    <div class="node-icon file">📄</div>
                                    <div class="node-title" ondblclick="editNodeTitle(event, this)">悉尼科技圈竞品分析</div>
                                    <div class="node-actions">
                                        <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                                        <button class="node-action" onclick="editNode(event, this)">✏️</button>
                                                <button class="node-action" onclick="deleteNode(event, this)">🗑️</button>
                                    </div>
                                </div>
                                <div class="node-tags">
                                    <span class="tag">竞品分析</span>
                                    <span class="tag">科技行业</span>
                                </div>
                                <div class="node-children"></div>
                            </div>
                            <div class="tree-node">
                                <div class="node-content" onclick="showNodeContent(event, this)" draggable="true" 
                                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                                    <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                                    <div class="node-icon file">📄</div>
                                    <div class="node-title" ondblclick="editNodeTitle(event, this)">AI营销策略案例库</div>
                                    <div class="node-actions">
                                        <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                                        <button class="node-action" onclick="editNode(event, this)">✏️</button>
                                                <button class="node-action" onclick="deleteNode(event, this)">🗑️</button>
                                    </div>
                                </div>
                                <div class="node-tags">
                                    <span class="tag">案例研究</span>
                                    <span class="tag">AI营销</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Content Creation Folder -->
                    <div class="tree-node">
                        <div class="node-content" onclick="selectNode(this, event)" draggable="true" 
                             ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                             ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                            <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                            <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                            <div class="node-icon folder">📁</div>
                            <div class="node-title" ondblclick="editNodeTitle(event, this)">Content Creation</div>
                            <div class="node-actions">
                                <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                                <button class="node-action" onclick="editNode(event, this)">✏️</button>
                            </div>
                        </div>
                        <div class="node-children">
                            <div class="tree-node">
                                <div class="node-content" onclick="showNodeContent(event, this)" draggable="true" 
                                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                                    <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                                    <div class="node-icon file">📄</div>
                                    <div class="node-title" ondblclick="editNodeTitle(event, this)">爆款文案写作模板</div>
                                    <div class="node-actions">
                                        <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                                        <button class="node-action" onclick="editNode(event, this)">✏️</button>
                                                <button class="node-action" onclick="deleteNode(event, this)">🗑️</button>
                                    </div>
                                </div>
                                <div class="node-tags">
                                    <span class="tag">文案模板</span>
                                    <span class="tag">爆款公式</span>
                                </div>
                                <div class="node-children"></div>
                            </div>
                            <div class="tree-node">
                                <div class="node-content" onclick="showNodeContent(event, this)" draggable="true" 
                                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                                    <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                                    <div class="node-icon file">📄</div>
                                    <div class="node-title" ondblclick="editNodeTitle(event, this)">AI写作提示词库</div>
                                    <div class="node-actions">
                                        <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                                        <button class="node-action" onclick="editNode(event, this)">✏️</button>
                                                <button class="node-action" onclick="deleteNode(event, this)">🗑️</button>
                                    </div>
                                </div>
                                <div class="node-tags">
                                    <span class="tag">AI提示词</span>
                                    <span class="tag">写作助手</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Social Media Folder -->
                    <div class="tree-node">
                        <div class="node-content" onclick="selectNode(this, event)" draggable="true" 
                             ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                             ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                            <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                            <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                            <div class="node-icon folder">📁</div>
                            <div class="node-title" ondblclick="editNodeTitle(event, this)">Social Media</div>
                            <div class="node-actions">
                                <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                                <button class="node-action" onclick="editNode(event, this)">✏️</button>
                            </div>
                        </div>
                        <div class="node-children">
                            <div class="tree-node">
                                <div class="node-content" onclick="openFileWithLocalTool(event, this)" draggable="true" 
                                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                                    <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                                    <div class="node-icon file">📄</div>
                                    <div class="node-title" ondblclick="editNodeTitle(event, this)">LinkedIn澳洲B2B运营指南</div>
                                    <div class="node-actions">
                                        <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                                        <button class="node-action" onclick="editNode(event, this)">✏️</button>
                                                <button class="node-action" onclick="deleteNode(event, this)">🗑️</button>
                                    </div>
                                </div>
                                <div class="node-tags">
                                    <span class="tag">LinkedIn</span>
                                    <span class="tag">B2B营销</span>
                                </div>
                                <div class="node-children"></div>
                            </div>
                            <div class="tree-node">
                                <div class="node-content" onclick="openFileWithLocalTool(event, this)" draggable="true" 
                                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                                    <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                                    <div class="node-icon file">📄</div>
                                    <div class="node-title" ondblclick="editNodeTitle(event, this)">Instagram视觉营销素材库</div>
                                    <div class="node-actions">
                                        <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                                        <button class="node-action" onclick="editNode(event, this)">✏️</button>
                                                <button class="node-action" onclick="deleteNode(event, this)">🗑️</button>
                                    </div>
                                </div>
                                <div class="node-tags">
                                    <span class="tag">Instagram</span>
                                    <span class="tag">视觉营销</span>
                                </div>
                                <div class="node-children"></div>
                            </div>
                            <div class="tree-node">
                                <div class="node-content" onclick="openFileWithLocalTool(event, this)" draggable="true" 
                                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                                    <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                                    <div class="node-icon file">📄</div>
                                    <div class="node-title" ondblclick="editNodeTitle(event, this)">TikTok短视频脚本模板</div>
                                    <div class="node-actions">
                                        <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                                        <button class="node-action" onclick="editNode(event, this)">✏️</button>
                                                <button class="node-action" onclick="deleteNode(event, this)">🗑️</button>
                                    </div>
                                </div>
                                <div class="node-tags">
                                    <span class="tag">TikTok</span>
                                    <span class="tag">短视频</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Analytics Folder -->
                    <div class="tree-node">
                        <div class="node-content" onclick="selectNode(this, event)" draggable="true" 
                             ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                             ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                            <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                            <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                            <div class="node-icon folder">📁</div>
                            <div class="node-title" ondblclick="editNodeTitle(event, this)">Analytics & Data</div>
                            <div class="node-actions">
                                <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                                <button class="node-action" onclick="editNode(event, this)">✏️</button>
                            </div>
                        </div>
                        <div class="node-children">
                            <div class="tree-node">
                                <div class="node-content" onclick="showNodeContent(event, this)" draggable="true" 
                                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                                    <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                                    <div class="node-icon file">📄</div>
                                    <div class="node-title" ondblclick="editNodeTitle(event, this)">内容营销KPI指标体系</div>
                                    <div class="node-actions">
                                        <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                                        <button class="node-action" onclick="editNode(event, this)">✏️</button>
                                                <button class="node-action" onclick="deleteNode(event, this)">🗑️</button>
                                    </div>
                                </div>
                                <div class="node-tags">
                                    <span class="tag">KPI</span>
                                    <span class="tag">数据分析</span>
                                </div>
                                <div class="node-children"></div>
                            </div>
                            <div class="tree-node">
                                <div class="node-content" onclick="showNodeContent(event, this)" draggable="true" 
                                     ondragstart="handleDragStart(event)" ondragover="handleDragOver(event)" 
                                     ondrop="handleDrop(event)" ondragend="handleDragEnd(event)">
                                    <div class="node-checkbox" onclick="toggleNodeSelection(event, this)">✓</div>
                                    <div class="node-expand" onclick="toggleNode(event, this)">▶</div>
                                    <div class="node-icon file">📄</div>
                                    <div class="node-title" ondblclick="editNodeTitle(event, this)">Google Analytics 4 配置指南</div>
                                    <div class="node-actions">
                                        <button class="node-action" onclick="addChildItem(event, this)">➕</button>
                                        <button class="node-action" onclick="editNode(event, this)">✏️</button>
                                                <button class="node-action" onclick="deleteNode(event, this)">🗑️</button>
                                    </div>
                                </div>
                                <div class="node-tags">
                                    <span class="tag">GA4</span>
                                    <span class="tag">网站分析</span>
                                </div>
                                <div class="node-children"></div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>

            <!-- 右侧：简化预览提示 -->
            <div class="preview-section" id="contentPreviewSection" style="flex: 0 0 280px; border-left: 1px solid #e5e7eb; padding: 20px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                <div style="text-align: center; color: #6b7280;">
                    <div style="font-size: 32px; margin-bottom: 12px; opacity: 0.6;">📄</div>
                    <h4 style="margin: 0 0 8px 0; font-size: 14px; color: #374151; font-weight: 600;">Select a document to preview</h4>
                    <p style="margin: 0; font-size: 12px; line-height: 1.4;">Click on any document in the knowledge tree to view its content here</p>
                </div>
            </div>
        </div>

        <div class="panel-footer">
            <div class="footer-actions">
                <button class="footer-btn" onclick="exportSelectedKnowledge()">📤 Export Selected</button>
                <button id="mainInsightAnalysisBtn" class="footer-btn primary" onclick="startInsightAnalysis()" style="
                    background: linear-gradient(135deg, #667eea, #764ba2); 
                    color: white; font-weight: 700; padding: 12px 24px; 
                    font-size: 16px; border-radius: 8px; opacity: 0.5; 
                    cursor: not-allowed;
                " disabled>
                    🧠 Start Insight Analysis
                </button>
            </div>
        </div>
    </div>

    <div id="panelOverlay" class="panel-overlay" onclick="closeKnowledgePanel()"></div>

    <style>
        /* Knowledge Base Panel Styles */
        .knowledge-panel { position: fixed; top: 0; right: -1200px; width: 1200px; height: 100vh; background: white; box-shadow: -5px 0 30px rgba(0, 0, 0, 0.2); transition: right 0.3s ease; z-index: 2000; display: flex; flex-direction: column; }
        .knowledge-panel.open { right: 0; }
        .panel-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.5); opacity: 0; visibility: hidden; transition: all 0.3s ease; z-index: 1999; }
        .panel-overlay.show { opacity: 1; visibility: visible; }
        .panel-header { background: linear-gradient(135deg, #8b5cf6, #6366f1); color: white; padding: 20px; display: flex; justify-content: space-between; align-items: center; }
        .panel-title { font-size: 18px; font-weight: 600; display: flex; align-items: center; gap: 10px; }
        .close-btn { background: none; border: none; color: white; font-size: 20px; cursor: pointer; padding: 5px; border-radius: 4px; transition: background 0.2s ease; }
        .close-btn:hover { background: rgba(255, 255, 255, 0.2); }
        .panel-content { flex: 1; overflow: hidden; display: flex; flex-direction: row; }
        .tree-section { flex: 2; padding: 20px; overflow-y: auto; }
        .tree-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
        .search-box { display: flex; gap: 8px; margin-bottom: 16px; }
        .search-input { flex: 1; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px; }
        .filter-btn { padding: 8px 12px; border: 1px solid #d1d5db; background: white; border-radius: 6px; cursor: pointer; font-size: 12px; }
        .knowledge-tree { background: #f9fafb; border-radius: 8px; padding: 12px; }
        .tree-node { margin: 4px 0; }
        .node-content { display: flex; align-items: center; padding: 8px; border-radius: 6px; cursor: pointer; transition: all 0.2s ease; gap: 8px; }
        .node-checkbox { width: 18px; height: 18px; border: 2px solid #9ca3af; border-radius: 3px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; }
        .node-checkbox.selected { background: #10b981; border-color: #10b981; color: white; }
        .preview-section { flex: 0 0 280px; border-left: 1px solid #e5e7eb; padding: 20px; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .node-content:hover { background: #e5e7eb; }
        .node-content[draggable="true"]:hover { cursor: grab; }
        .node-content.dragging { opacity: 0.5; transform: rotate(2deg); }
        .node-content.drag-over { background: #e0e7ff !important; border: 2px dashed #8b5cf6; }
        .node-expand { width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 12px; }
        .node-icon { width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; border-radius: 4px; font-size: 14px; }
        .node-icon.folder { background: #fef3c7; }
        .node-icon.file { background: #dbeafe; }
        .node-title { flex: 1; font-size: 14px; font-weight: 500; }
        .node-actions { opacity: 0; display: flex; gap: 4px; transition: opacity 0.2s ease; }
        .node-content:hover .node-actions { opacity: 1; }
        .node-action { width: 24px; height: 24px; border: none; background: none; cursor: pointer; border-radius: 4px; font-size: 12px; color: #6b7280; }
        .node-action:hover { background: #f3f4f6; color: #374151; }
        .node-select-btn { 
            width: 24px; 
            height: 24px; 
            border: none; 
            background: none; 
            cursor: pointer; 
            border-radius: 4px; 
            font-size: 14px; 
            color: #9ca3af; 
            transition: all 0.2s ease;
            opacity: 1 !important;
            display: inline-flex !important;
            align-items: center;
            justify-content: center;
            margin-left: 4px;
        }
        .node-select-btn:hover { background: #f3f4f6; }
        .node-select-btn[data-selected="true"] { color: #10b981; background: #d1fae5; }
        .node-select-btn[data-selected="false"] { color: #9ca3af; }
        .node-children { margin-left: 24px; display: none; }
        .node-children.expanded { display: block; }
        .node-tags { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 4px; }
        .tag { background: #f3f4f6; color: #6b7280; padding: 2px 6px; border-radius: 10px; font-size: 10px; }
        .templates-section { margin-top: 20px; }
        .templates-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px; }
        .template-card { background: white; border: 1px solid #e5e7eb; border-radius: 8px; padding: 12px; cursor: pointer; transition: all 0.2s ease; }
        .template-card:hover { border-color: #8b5cf6; box-shadow: 0 4px 12px rgba(139, 92, 246, 0.1); }
        .template-title { font-size: 12px; font-weight: 600; margin-bottom: 4px; }
        .template-desc { font-size: 10px; color: #6b7280; }
        .panel-footer { padding: 20px; border-top: 1px solid #e5e7eb; background: #f9fafb; }
        .footer-actions { display: flex; gap: 8px; }
        .footer-btn { flex: 1; padding: 10px; border: 1px solid #d1d5db; background: white; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 500; }
        .footer-btn.primary { background: linear-gradient(135deg, #8b5cf6, #6366f1); color: white; border: none; }
        @media (max-width: 768px) { .knowledge-panel { width: 100vw; right: -100vw; } }
        @keyframes slideInRight { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideInUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes rotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    </style>
    
    <script>
        // 渲染真正的交互式D3.js知识图谱
        function renderInteractiveKnowledgeGraph(graphData) {
            console.log('🎨 Rendering interactive knowledge graph:', graphData);
            console.log('🔍 Graph data structure:', {
                hasNodes: !!(graphData && graphData.nodes),
                nodeCount: graphData?.nodes?.length || 0,
                hasLinks: !!(graphData && graphData.links),
                linkCount: graphData?.links?.length || 0
            });
            
            const container = document.getElementById('knowledgeGraphContainer');
            console.log('📦 Container element:', container);
            console.log('📦 Container dimensions:', container ? `${container.offsetWidth}x${container.offsetHeight}` : 'N/A');
            
            if (!container) {
                console.error('❌ Knowledge graph container not found');
                return;
            }
            
            // 清空容器
            container.innerHTML = '';
            console.log('🧹 Container cleared');
            
            // 如果没有图数据，显示占位符
            if (!graphData || !graphData.nodes || graphData.nodes.length === 0) {
                console.log('⚠️ No graph data available, showing placeholder');
                container.innerHTML = `
                    <div style="
                        display: flex; flex-direction: column; align-items: center; 
                        justify-content: center; height: 100%; color: #6b7280;
                    ">
                        <div style="font-size: 48px; margin-bottom: 16px;">🔍</div>
                        <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">数据解析中</div>
                        <div style="font-size: 14px;">正在分析 ${graphData?.metadata || '未知'} 数据结构...</div>
                        <div style="font-size: 12px; margin-top: 8px; opacity: 0.7;">
                            调试信息: nodes=${graphData?.nodes?.length || 0}, links=${graphData?.links?.length || 0}
                        </div>
                    </div>
                `;
                return;
            }
            
            console.log('✅ Graph data validation passed, proceeding with rendering');
            
            // 图谱尺寸
            const width = container.offsetWidth;
            const height = 450;
            
            // 创建SVG画布
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .style('background', '#fafafa')
                .style('border-radius', '8px');
            
            // 添加缩放功能
            const g = svg.append('g');
            const zoom = d3.zoom()
                .scaleExtent([0.5, 3])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });
            svg.call(zoom);
            
            // 处理数据
            const nodes = graphData.nodes.map(d => ({
                ...d,
                id: d.id,
                name: d.name || d.id,
                type: d.type || 'entity',
                category: d.category || 'default',
                weight: d.weight || 1
            }));
            
            const links = graphData.links.map(d => ({
                ...d,
                source: d.source,
                target: d.target,
                type: d.type || 'related',
                weight: d.weight || 1
            }));
            
            // 颜色配置
            const colorScale = {
                'entity': '#8b5cf6',     // 紫色 - 实体
                'concept': '#06b6d4',    // 青色 - 概念  
                'person': '#f59e0b',     // 橙色 - 人物
                'organization': '#10b981', // 绿色 - 组织
                'product': '#ef4444',    // 红色 - 产品
                'default': '#6b7280'     // 灰色 - 默认
            };
            
            // 创建力仿真
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(80).strength(0.8))
                .force('charge', d3.forceManyBody().strength(-200))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(25));
            
            // 绘制连接线
            const link = g.append('g')
                .selectAll('line')
                .data(links)
                .enter().append('line')
                .attr('stroke', '#94a3b8')
                .attr('stroke-opacity', 0.6)
                .attr('stroke-width', d => Math.sqrt(d.weight * 2));
            
            // 绘制连接线标签
            const linkLabel = g.append('g')
                .selectAll('text')
                .data(links)
                .enter().append('text')
                .attr('font-size', 10)
                .attr('fill', '#64748b')
                .attr('text-anchor', 'middle')
                .text(d => d.type === 'co_occurs' ? '' : (d.type || ''));
            
            // 绘制节点
            const node = g.append('g')
                .selectAll('circle')
                .data(nodes)
                .enter().append('circle')
                .attr('r', d => 8 + (d.weight || 1) * 4)
                .attr('fill', d => colorScale[d.type] || colorScale.default)
                .attr('stroke', '#fff')
                .attr('stroke-width', 2)
                .style('cursor', 'pointer')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            // 节点标签
            const nodeLabel = g.append('g')
                .selectAll('text')
                .data(nodes)
                .enter().append('text')
                .attr('font-size', 11)
                .attr('font-weight', 'bold')
                .attr('fill', '#1f2937')
                .attr('text-anchor', 'middle')
                .attr('dy', '.35em')
                .text(d => d.name.length > 8 ? d.name.substring(0, 8) + '...' : d.name)
                .style('pointer-events', 'none');
            
            // 添加交互效果
            node.on('mouseover', function(event, d) {
                // 高亮当前节点和相关连接
                d3.select(this)
                    .transition()
                    .duration(200)
                    .attr('r', d => 12 + (d.weight || 1) * 4)
                    .attr('stroke-width', 3);
                
                // 显示详细信息
                showNodeTooltip(event, d);
                
                // 高亮相关连接
                link.style('stroke-opacity', l => 
                    l.source.id === d.id || l.target.id === d.id ? 1 : 0.2
                );
                
                // 高亮相关节点
                node.style('opacity', n => {
                    const connected = links.some(l => 
                        (l.source.id === d.id && l.target.id === n.id) ||
                        (l.target.id === d.id && l.source.id === n.id)
                    );
                    return n.id === d.id || connected ? 1 : 0.3;
                });
            })
            .on('mouseout', function(event, d) {
                // 恢复原始样式
                d3.select(this)
                    .transition()
                    .duration(200)
                    .attr('r', d => 8 + (d.weight || 1) * 4)
                    .attr('stroke-width', 2);
                
                hideNodeTooltip();
                
                // 恢复所有连接和节点的透明度
                link.style('stroke-opacity', 0.6);
                node.style('opacity', 1);
            })
            .on('click', function(event, d) {
                // 点击节点时的详细信息
                showNodeDetails(d);
            });
            
            // 仿真更新
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                linkLabel
                    .attr('x', d => (d.source.x + d.target.x) / 2)
                    .attr('y', d => (d.source.y + d.target.y) / 2);
                
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                nodeLabel
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
            
            // 拖拽函数
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            // 添加图谱控制按钮
            const controls = d3.select(container)
                .append('div')
                .style('position', 'absolute')
                .style('top', '10px')
                .style('right', '10px')
                .style('display', 'flex')
                .style('gap', '8px');
            
            // 重置视图按钮
            controls.append('button')
                .style('width', '32px')
                .style('height', '32px')
                .style('border', 'none')
                .style('background', 'rgba(139, 69, 196, 0.9)')
                .style('color', 'white')
                .style('border-radius', '6px')
                .style('cursor', 'pointer')
                .style('font-size', '14px')
                .text('⌂')
                .attr('title', '重置视图')
                .on('click', function() {
                    svg.transition().duration(750).call(
                        zoom.transform,
                        d3.zoomIdentity
                    );
                });
            
            console.log('✅ Interactive knowledge graph rendered successfully');
        }
        
        // 显示节点悬停提示
        function showNodeTooltip(event, node) {
            // 移除已存在的提示
            hideNodeTooltip();
            
            const tooltip = d3.select('body')
                .append('div')
                .attr('id', 'node-tooltip')
                .style('position', 'absolute')
                .style('background', 'rgba(0, 0, 0, 0.8)')
                .style('color', 'white')
                .style('padding', '8px 12px')
                .style('border-radius', '6px')
                .style('font-size', '12px')
                .style('pointer-events', 'none')
                .style('z-index', '10000')
                .style('opacity', 0);
            
            tooltip.html(`
                <strong>${node.name}</strong><br>
                类型: ${node.type || '未知'}<br>
                权重: ${node.weight || 1}
            `)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 10) + 'px')
            .transition()
            .duration(200)
            .style('opacity', 1);
        }
        
        // 隐藏节点提示
        function hideNodeTooltip() {
            d3.select('#node-tooltip').remove();
        }
        
        // 显示节点详细信息
        function showNodeDetails(node) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0, 0, 0, 0.7); z-index: 15000;
                display: flex; align-items: center; justify-content: center;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white; border-radius: 12px; padding: 24px;
                    max-width: 400px; width: 90%; position: relative;
                    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
                ">
                    <button onclick="this.closest('div').parentElement.remove()" 
                            style="position: absolute; top: 12px; right: 12px; 
                                   background: none; border: none; font-size: 20px; 
                                   cursor: pointer; color: #6b7280;
                                   width: 28px; height: 28px; display: flex;
                                   align-items: center; justify-content: center;
                                   border-radius: 6px;">✕</button>
                    
                    <h3 style="margin: 0 0 16px 0; color: #1f2937; font-size: 18px;">
                        🔍 实体详情
                    </h3>
                    
                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        <div><strong>名称:</strong> ${node.name}</div>
                        <div><strong>类型:</strong> <span style="background: #e0e7ff; color: #3730a3; padding: 2px 8px; border-radius: 12px; font-size: 12px;">${node.type || '未知'}</span></div>
                        <div><strong>分类:</strong> ${node.category || '默认'}</div>
                        <div><strong>重要度:</strong> <span style="color: #059669;">${node.weight || 1}</span></div>
                        ${node.properties ? `<div><strong>其他属性:</strong><br><pre style="background: #f3f4f6; padding: 8px; border-radius: 4px; font-size: 11px; white-space: pre-wrap;">${JSON.stringify(node.properties, null, 2)}</pre></div>` : ''}
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // 确保图谱渲染函数在页面加载后可用
        if (typeof window !== 'undefined') {
            // 立即重写函数，不等待DOM加载
            const originalShow = window.showCrossDocumentResults;
            
            window.showCrossDocumentResults = function(results) {
                console.log('🎯 showCrossDocumentResults called with:', results);
                
                // 调用原始函数（如果存在）
                if (originalShow) {
                    originalShow(results);
                }
                
                // 多次尝试渲染图谱，确保成功
                const attemptRender = (attempt = 1) => {
                    console.log(`🎨 Render attempt ${attempt} with results:`, results);
                    
                    const container = document.getElementById('knowledgeGraphContainer');
                    if (container && results) {
                        // 使用 generateGraphData 生成图谱数据
                        const graphData = generateGraphData(results);
                        console.log('📊 Generated graph data for rendering:', graphData);
                        
                        if (graphData && graphData.nodes && graphData.nodes.length > 0) {
                            renderInteractiveKnowledgeGraph(graphData);
                            console.log('✅ Knowledge graph rendered successfully on attempt', attempt);
                            return; // 成功渲染，停止重试
                        }
                    }
                    
                    if (attempt < 5) {
                        console.log(`⏳ Retrying render in ${attempt * 200}ms (attempt ${attempt + 1})`);
                        setTimeout(() => attemptRender(attempt + 1), attempt * 200);
                    } else {
                        console.error('❌ Failed to render knowledge graph after 5 attempts');
                        console.log('Container found:', !!container);
                        console.log('Results available:', !!results);
                        console.log('Results details:', results);
                    }
                };
                
                // 立即尝试一次，然后延迟尝试
                attemptRender(1);
                setTimeout(() => attemptRender(2), 500);
                setTimeout(() => attemptRender(3), 1000);
            };
            
            console.log('🔧 Knowledge graph renderer setup complete');
        }
    </script>
</body>
</html>